{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Welcome to the Zero to Mastery Data Science and Machine Learning Bootcamp!","text":"<p>This webpage contains all of the materials for the Zero to Mastery Data Science and Machine Learning Bootcamp.</p>"},{"location":"#quick-links","title":"Quick Links","text":"<ul> <li>\ud83d\udcda Get the course materials on the course GitHub</li> <li>\ud83c\udfa5 Watch the first 10 hours of the course on YouTube</li> <li>\ud83e\udd13 Read more on the course page</li> <li>\ud83d\udcbb Sign up to the course on Zero to Mastery and start coding</li> </ul>"},{"location":"#contents","title":"Contents","text":"<p>The following contents are listed in suggested chronological order.</p> <p>But feel free to mix in match in anyway you feel fit.</p> Section Resource Description 00 A 6 step framework for approaching machine learning projects A guideline for different kinds of machine learning projects and how to break them down into smaller steps. 01 Introduction to NumPy NumPy stands for Numerical Python. It's one of the most used Python libraries for numerical processing (which is what much of data science and machine learning is). 02 Introduction to pandas pandas is a Python library for manipulating and analysing data. You can imagine pandas as a programmatic form of an Excel spreadsheet. 03 Introduction to Matplotlib Matplotlib helps to visualize data. You can create plots and graphs programmatically based on various data sources. 04 Introduction to Scikit-Learn Scikit-Learn or sklearn is full of data processing techniques as well as pre-built machine learning algorithms for many different tasks. 05 Milestone Project 1: End-to-end Heart Disease Classification Here we'll put together everything we've gone through in the previous sections to create a machine learning model that is capable of classifying if someone has heart disease or not based on their health characteristics. We'll start with a raw dataset and work through performing an exploratory data analysis (EDA) on it before trying out several different machine learning models to see which performs best. 06 Milestone Project 2: End-to-end Bulldozer Price Prediction In this project we'll work with an open-source dataset of bulldozer sales information. We'll use this data to build a machine learning model capable of predicting the sales price of a bulldozer based on several input parameters such as size and brand. Since this dataset isn't perfect, we'll work through several data preprocessing steps before building a model. And since we'll be working towards predicting a number (price of bulldozers), this project is known as regression project. 07 Introduction to TensorFlow/Keras and Deep Learning TensorFlow/Keras are deep learning frameworks written in Python. Originally created by Google and are now open-source. These frameworks allow you to build and train neural networks, one of the most powerful kinds of machine learning models. In this section we'll learn about deep learning and TensorFlow/Keras by building Dog Vision \ud83d\udc36\ud83d\udc41\ufe0f, a neural network to identify dog breeds in images. 07 Communicating your work One of the most important parts of machine learning and any software project is communicating what you've found/done. This module takes the learnings from the previous sections and gives tips and tricks on how you can communicate your work to others. <p>If you have any questions, leave an issue/discussion on the course GitHub.</p>"},{"location":"#author","title":"Author","text":"<p>Daniel Bourke</p> <p>Last update: 30 October 2024</p>"},{"location":"a-6-step-framework-for-approaching-machine-learning-projects/","title":"A 6 Step Framework for Approaching Machine Learning Projects","text":"<p>Machine learning is broad. The media makes it sound like magic. Reading this article will change that. It will give you an overview of the most common types of problems machine learning can be used for. And at the same time give you a framework to approach your future machine learning proof of concept projects.</p> <p>First, we\u2019ll clear up some definitions.</p> <p>How is machine learning, artificial intelligence and data science different?</p> <p>These three topics can be hard to understand because there are no formal definitions. Even after being a machine learning engineer for over a year, I don\u2019t have a good answer to this question. I\u2019d be suspicious of anyone who claims they do.</p> <p>To avoid confusion, we\u2019ll keep it simple. For this article, you can consider machine learning the process of finding patterns in data to understand something more or to predict some kind of future event.</p> <p>The following steps have a bias towards building something and seeing how it works. Learning by doing.</p>"},{"location":"a-6-step-framework-for-approaching-machine-learning-projects/#6-steps-for-your-next-machine-learning-project","title":"6 steps for your next machine learning project","text":"<p>A machine learning pipeline can be broken down into three major steps. Data collection, data modelling and deployment. All influence one another.</p> <p>You may start a project by collecting data, model it, realise the data you collected was poor, go back to collecting data, model it again, find a good model, deploy it, find it doesn\u2019t work, make another model, deploy it, find it doesn\u2019t work again, go back to data collection. It\u2019s a cycle.</p> <p>Wait, what does model mean? What\u2019s does deploy mean? How do I collect data?</p> <p>Great questions.</p> <p>How you collect data will depend on your problem. We will look at examples in a minute. But one way could be your customer purchases in a spreadsheet.</p> <p>Modelling refers to using a machine learning algorithm to find insights within your collected data.</p> <p>What\u2019s the difference between a normal algorithm and a machine learning algorithm?</p> <p>Like a cooking recipe for your favourite chicken dish, a normal algorithm is a set of instructions on how to turn a set of ingredients into that honey mustard masterpiece.</p> <p>What makes a machine learning algorithm different is instead of having the set of instructions, you start with the ingredients and the final dish ready to go. The machine learning algorithm then looks at the ingredients and the final dish and works out the set of instructions.</p> <p>There are many different types of machine learning algorithms and some perform better than others on different problems. But the premise remains, they all have the goal of finding patterns or sets of instructions in data.</p> <p>Deployment is taking your set of instructions and using it in an application. This application could be anything from recommending products to customers on your online store to a hospital trying to better predict disease presence.</p> <p>The specifics of these steps will be different for each project. But the principles within each remain similar.</p> <p>This article focuses on data modelling. It assumes you have already collected data, and are looking to build a machine learning proof of concept with it. Let\u2019s break down how you might approach it.</p> Machine learning projects can be broken into three steps, data collection, data modelling and deployment. This article focuses on steps within the data modelling phase and assumes you already have data. Full version on Whimsical. <ol> <li>Problem definition\u200a\u2014\u200aWhat business problem are we trying to solve? How can it be phrased as a machine learning problem?</li> <li>Data\u200a\u2014\u200aIf machine learning is getting insights out of data, what data we have? How does it match the problem definition? Is our data structured or unstructured? Static or streaming?</li> <li>Evaluation\u200a\u2014\u200aWhat defines success? Is a 95% accurate machine learning model good enough?</li> <li>Features\u200a\u2014\u200aWhat parts of our data are we going to use for our model? How can what we already know influence this?</li> <li>Modelling\u200a\u2014\u200aWhich model should you choose? How can you improve it? How do you compare it with other models?</li> <li>Experimentation\u200a\u2014\u200aWhat else could we try? Does our deployed model do as we expected? How do the other steps change based on what we\u2019ve found?</li> </ol> <p>Let\u2019s dive a little deeper in each.</p>"},{"location":"a-6-step-framework-for-approaching-machine-learning-projects/#1-problem-definition-rephrase-your-business-problem-as-a-machine-learning-problem","title":"1. Problem definition\u200a\u2014\u200aRephrase your business problem as a machine learning problem","text":"<p>To help decide whether or not your business could use machine learning, the first step is to match the business problem you\u2019re trying to solve a machine learning problem.</p> <p>The four major types of machine learning are supervised learning, unsupervised learning, transfer learning and reinforcement learning (there\u2019s semi-supervised as well but I\u2019ve left it out for brevity). The three most used in business applications are supervised learning, unsupervised learning and transfer learning.</p>"},{"location":"a-6-step-framework-for-approaching-machine-learning-projects/#supervised-learning","title":"Supervised learning","text":"<p>Supervised learning, is called supervised because you have data and labels. A machine learning algorithm tries to learn what patterns in the data lead to the labels. The supervised part happens during training. If the algorithm guesses a wrong label, it tries to correct itself.</p> <p>For example, if you were trying to predict heart disease in a new patient. You may have the anonymised medical records of 100 patients as the data and whether or not they had heart disease as the label.</p> <p>A machine learning algorithm could look at the medical records (inputs) and whether or not a patient had heart disease (outputs) and then figure out what patterns in the medical records lead to heart disease.</p> <p>Once you\u2019ve got a trained algorithm, you could pass through the medical records (input) of a new patient through it and get a prediction of whether or not they have heart disease (output). It\u2019s important to remember this prediction isn\u2019t certain. It comes back as a probability.</p> <p>The algorithm says, \u201cbased on what I\u2019ve seen before, it looks like this new patients medical records are 70% aligned to those who have heart disease.\u201d</p>"},{"location":"a-6-step-framework-for-approaching-machine-learning-projects/#unsupervised-learning","title":"Unsupervised learning","text":"<p>Unsupervised learning is when you have data but no labels. The data could be the purchase history of your online video game store customers. Using this data, you may want to group similar customers together so you can offer them specialised deals. You could use a machine learning algorithm to group your customers by purchase history.</p> <p>After inspecting the groups, you provide the labels. There may be a group interested in computer games, another group who prefer console games and another which only buy discounted older games. This is called clustering.</p> <p>What\u2019s important to remember here is the algorithm did not provide these labels. It found the patterns between similar customers and using your domain knowledge, you provided the labels.</p>"},{"location":"a-6-step-framework-for-approaching-machine-learning-projects/#transfer-learning","title":"Transfer learning","text":"<p>Transfer learning is when you take the information an existing machine learning model has learned and adjust it to your own problem.</p> <p>Training a machine learning model from scratch can be expensive and time-consuming. The good news is, you don\u2019t always have to. When machine learning algorithms find patterns in one kind of data, these patterns can be used in another type of data.</p> <p>Let\u2019s say you\u2019re a car insurance company and wanted to build a text classification model to classify whether or not someone submitting an insurance claim for a car accident is at fault (caused the accident) or not at fault (didn\u2019t cause the accident).</p> <p>You could start with an existing text model, one which has read all of Wikipedia and has remembered all the patterns between different words, such as, which word is more likely to come next after another. Then using your car insurance claims (data) along with their outcomes (labels), you could tweak the existing text model to your own problem.</p> <p>If machine learning can be used in your business, it\u2019s likely it\u2019ll fall under one of these three types of learning. But let\u2019s break them down further into classification, regression and recommendation.</p> <ul> <li>Classification\u200a\u2014\u200aDo you want to predict whether something is one thing or another? Such as whether a customer will churn or not churn? Or whether a patient has heart disease or not? Note, there can be more than two things. Two classes is called binary classification, more than two classes is called multi-class classification. Multi-label is when an item can belong to more than one class.</li> <li>Regression\u200a\u2014\u200aDo you want to predict a specific number of something? Such as how much a house will sell for? Or how many customers will visit your site next month?</li> <li>Recommendation\u200a\u2014\u200aDo you want to recommend something to someone? Such as products to buy based on their previous purchases? Or articles to read based on their reading history?</li> </ul> <p>Now you know these things, your next step is to define your business problem in machine learning terms.</p> <p>Let\u2019s use the car insurance example from before. You receive thousands of claims per day which your staff read and decide whether or not the person sending in the claim is at fault or not.</p> <p>But now the number of claims are starting to come in faster than your staff can handle them. You\u2019ve got thousands of examples of past claims which are labelled at fault or not at fault.</p> <p>Can machine learning help?</p> <p>You already know the answer. But let\u2019s see. Does this problem fit into any of the three above? Classification, regression or recommendation?</p> <p>Let\u2019s rephrase it.</p> <p>We\u2019re a car insurance company who want to classify incoming car insurance claims into at fault or not at fault.</p> <p>See the keyword? Classify.</p> <p>It turns out, this could potentially be a machine learning classification problem. I say potentially because there\u2019s a chance it might not work.</p> <p>When it comes to defining your business problem as a machine learning problem, start simple, more than one sentence is too much. Add complexity when required.</p>"},{"location":"a-6-step-framework-for-approaching-machine-learning-projects/#2-data-if-machine-learning-is-getting-insights-out-of-data-what-data-do-you-have","title":"2. Data\u200a\u2014\u200aIf machine learning is getting insights out of data, what data do you have?","text":"<p>The data you have or need to collect will depend on the problem you want to solve.</p> <p>If you already have data, it\u2019s likely it will be in one of two forms. Structured or unstructured. Within each of these, you have static or streaming data.</p> <ul> <li>Structured data\u200a\u2014\u200aThink a table of rows and columns, an Excel spreadsheet of customer transactions, a database of patient records. Columns can be numerical, such as average heart rate, categorical, such as sex, or ordinal, such as chest pain intensity.</li> <li>Unstructured data\u200a\u2014\u200aAnything not immediately able to be put into row and column format, images, audio files, natural language text.</li> <li>Static data\u200a\u2014\u200aExisting historical data which is unlikely to change. Your companies customer purchase history is a good example.</li> <li>Streaming data\u200a\u2014\u200aData which is constantly updated, older records may be changed, newer records are constantly being added.</li> </ul> <p>There are overlaps.</p> <p>Your static structured table of information may have columns which contain natural language text and photos and be updated constantly.</p> <p>For predicting heart disease, one column may be sex, another average heart rate, another average blood pressure, another chest pain intensity.</p> <p>For the insurance claim example, one column may be the text a customer has sent in for the claim, another may be the image they\u2019ve sent in along with the text and a final a column being the outcome of the claim. This table gets updated with new claims or altered results of old claims daily.</p> Two examples of structured data with different kinds of data within it. Table 1.0 has numerical and categorical data. Table 2.0 has unstructured data with images and natural language text but is presented in a structured manner. <p>The principle remains. You want to use the data you have to gains insights or predict something.</p> <p>For supervised learning, this involves using the feature variable(s) to predict the target variable(s). A feature variable for predicting heart disease could be sex with the target variable being whether or not the patient has heart disease.</p> Table 1.0 broken into ID column (yellow, not used for building machine learning model), feature variables (orange) and target variables (green). A machine learning model finds the patterns in the feature variables and predicts the target variables. <p>For unsupervised learning, you won\u2019t have labels. But you\u2019ll still want to find patterns. Meaning, grouping together similar samples and finding samples which are outliers.</p> <p>For transfer learning, your problem stays a supervised learning problem, except you\u2019re leveraging the patterns machine learning algorithms have learned from other data sources separate from your own.</p> <p>Remember, if you\u2019re using a customers data to improve your business or to offer them a better service, it\u2019s important to let them know. This is why you see \u201cthis site uses cookies\u201d popups everywhere. The website uses how you browse the site, likely along with some kind of machine learning to improve their offering.</p>"},{"location":"a-6-step-framework-for-approaching-machine-learning-projects/#3-evaluation-what-defines-success-is-a-95-accurate-machine-learning-model-good-enough","title":"3. Evaluation\u200a\u2014\u200aWhat defines success? Is a 95% accurate machine learning model good enough?","text":"<p>You\u2019ve defined your business problem in machine learning terms and you have data. Now define what defines success. There are different evaluation metrics for classification, regression and recommendation problems. Which one you choose will depend on your goal.</p> <p>For this project to be successful, the model needs to be over 95% accurate at whether someone is at fault or not at fault.</p> <p>A 95% accurate model may sound pretty good for predicting who\u2019s at fault in an insurance claim. But for predicting heart disease, you\u2019ll likely want better results.</p> <p>Other things you should take into consideration for classification problems.</p> <ul> <li>False negatives\u200a\u2014\u200aModel predicts negative, actually positive. In some cases, like email spam prediction, false negatives aren\u2019t too much to worry about. But if a self-driving cars computer vision system predicts no pedestrian when there was one, this is not good.</li> <li>False positives\u200a\u2014\u200aModel predicts positive, actually negative. Predicting someone has heart disease when they don\u2019t, might seem okay. Better to be safe right? Not if it negatively affects the person\u2019s lifestyle or sets them on a treatment plan they don\u2019t need.</li> <li>True negatives\u200a\u2014\u200aModel predicts negative, actually negative. This is good.</li> <li>True positives\u200a\u2014\u200aModel predicts positive, actually positive. This is good.</li> <li>Precision\u200a\u2014\u200aWhat proportion of positive predictions were actually correct? A model that produces no false positives has a precision of 1.0.</li> <li>Recall\u200a\u2014\u200aWhat proportion of actual positives were predicted correctly? A model that produces no false negatives has a recall of 1.0.</li> <li>F1 score\u200a\u2014\u200aA combination of precision and recall. The closer to 1.0, the better.</li> <li>Receiver operating characteristic (ROC) curve &amp; Area under the curve (AUC)\u200a\u2014\u200aThe ROC curve is a plot comparing true positive and false positive rate. The AUC metric is the area under the ROC curve. A model whose predictions are 100% wrong has an AUC of 0.0, one whose predictions are 100% right has an AUC of 1.0.</li> </ul> <p>For regression problems (where you want to predict a number), you\u2019ll want to minimise the difference between what your model predicts and what the actual value is. If you\u2019re trying to predict the price a house will sell for, you\u2019ll want your model to get as close as possible to the actual price. To do this, use MAE or RMSE.</p> <ul> <li>Mean absolute error (MAE)\u200a\u2014\u200aThe average difference between your model's predictions and the actual numbers.</li> <li>Root mean square error (RMSE)\u200a\u2014\u200aThe square root of the average of squared differences between your model's predictions and the actual numbers.</li> </ul> <p>Use RMSE if you want large errors to be more significant. Such as, predicting a house to be sold at $300,000 instead of $200,000 and being off by $100,000 is more than twice as bad as being off by $50,000. Or MAE if being off by $100,000 is twice as bad as being off by $50,000.</p> <p>Recommendation problems are harder to test in experimentation. One way to do so is to take a portion of your data and hide it away. When your model is built, use it to predict recommendations for the hidden data and see how it lines up.</p> <p>Let\u2019s say you\u2019re trying to recommend customers products on your online store. You have historical purchase data from 2010\u20132019. You could build a model on the 2010\u20132018 data and then use it to predict 2019 purchases. Then it becomes a classification problem because you\u2019re trying to classify whether or not someone is likely to buy an item.</p> <p>However, traditional classification metrics aren\u2019t the best for recommendation problems. Precision and recall have no concept of ordering.</p> <p>If your machine learning model returned back a list of 10 recommendations to be displayed to a customer on your website, you\u2019d want the best ones to be displayed first right?</p> <ul> <li>Precision @ k (precision up to k)\u200a\u2014\u200aSame as regular precision, however, you choose the cutoff, k. For example, precision at 5, means we only care about the top 5 recommendations. You may have 10,000 products. But you can\u2019t recommend them all to your customers.</li> </ul> <p>To begin with, you may not have an exact figure for each of these. But knowing what metrics you should be paying attention to gives you an idea of how to evaluate your machine learning project.</p>"},{"location":"a-6-step-framework-for-approaching-machine-learning-projects/#4-features-what-features-does-your-data-have-and-which-can-you-use-to-build-your-model","title":"4. Features\u200a\u2014\u200aWhat features does your data have and which can you use to build your model?","text":"<p>Not all data is the same. And when you hear someone referring to features, they\u2019re referring to different kinds of data within data.</p> <p>The three main types of features are categorical, continuous (or numerical) and derived.</p> <ul> <li> <p>Categorical features\u200a\u2014\u200aOne or the other(s). For example, in our heart disease problem, the sex of the patient. Or for an online store, whether or not someone has made a purchase or not.</p> </li> <li> <p>Continuous (or numerical) features\u200a\u2014\u200aA numerical value such as average heart rate or the number of times logged in. Derived features\u200a\u2014\u200aFeatures you create from the data. Often referred to as feature engineering. Feature engineering is how a subject matter expert takes their knowledge and encodes it into the data. You might combine the number of times logged in with timestamps to make a feature called time since last login. Or turn dates from numbers into \u201cis a weekday (yes)\u201d and \u201cis a weekday (no)\u201d.</p> </li> </ul> <p>Text, images and almost anything you can imagine can also be a feature. Regardless, they all get turned into numbers before a machine learning algorithm can model them.</p> <p>Some important things to remember when it comes to features.</p> <ul> <li>Keep them the same during experimentation (training) and production (testing)\u200a\u2014\u200aA machine learning model should be trained on features which represent as close as possible to what it will be used for in a real system.</li> <li>Work with subject matter experts\u200a\u2014\u200aWhat do you already know about the problem, how can that influence what features you use? Let your machine learning engineers and data scientists know this.</li> <li>Are they worth it?\u200a\u2014\u200aIf only 10% of your samples have a feature, is it worth incorporating it in a model? Have a preference for features with the most coverage. The ones where lots of samples have data for.</li> <li>Perfect equals broken\u200a\u2014\u200aIf your model is achieving perfect performance, you\u2019ve likely got feature leakage somewhere. Which means the data your model has trained on is being used to test it. No model is perfect.</li> </ul> <p>You can use features to create a simple baseline metric. A subject matter expert on customer churn may know someone is 80% likely to cancel their membership after 3 weeks of not logging in.</p> <p>Or a real estate agent who knows the sale prices of houses might know houses with over 5 bedrooms and 4 bathrooms sell for over $500,000.</p> <p>These are simplified and don\u2019t have to be exact. But it\u2019s what you\u2019re going to use to see whether machine learning can improve upon or not.</p>"},{"location":"a-6-step-framework-for-approaching-machine-learning-projects/#5-modelling-which-model-should-you-choose-how-can-you-improve-it-how-do-you-compare-it-with-other-models","title":"5. Modelling\u200a\u2014\u200aWhich model should you choose? How can you improve it? How do you compare it with other models?","text":"<p>Once you\u2019ve defined your problem, prepared your data, evaluation criteria and features it\u2019s time to model.</p> <p>Modelling breaks into three parts, choosing a model, improving a model, comparing it with others.</p>"},{"location":"a-6-step-framework-for-approaching-machine-learning-projects/#choosing-a-model","title":"Choosing a model","text":"<p>When choosing a model, you\u2019ll want to take into consideration, interpretability and ease to debug, amount of data, training and prediction limitations.</p> <ul> <li>Interpretability and ease to debug\u200a\u2014\u200aWhy did a model make a decision it made? How can the errors be fixed?</li> <li>Amount of data\u200a\u2014\u200aHow much data do you have? Will this change?</li> <li>Training and prediction limitations\u200a\u2014\u200aThis ties in with the above, how much time and resources do you have for training and prediction?</li> </ul> <p>To address these, start simple. A state of the art model can be tempting to reach for. But if it requires 10x the compute resources to train and prediction times are 5x longer for a 2% boost in your evaluation metric, it might not be the best choice.</p> <p>Linear models such as logistic regression are usually easier to interpret, are very fast for training and predict faster than deeper models such as neural networks.</p> <p>But it\u2019s likely your data is from the real world. Data from the real world isn\u2019t always linear.</p> <p>What then?</p> <p>Ensembles of decision trees and gradient boosted algorithms (fancy words, definitions not important for now) usually work best on structured data, like Excel tables and dataframes. Look into random forests, XGBoost and CatBoost.</p> A non-exhaustive example of all the different tools you can use for machine learning/data science. <p>Deep models such as neural networks generally work best on unstructured data like images, audio files and natural language text. However, the trade-off is they usually take longer to train, are harder to debug and prediction time takes longer. But this doesn\u2019t mean you shouldn\u2019t use them.</p> <p>Transfer learning is an approach which takes advantage of deep models and linear models. It involves taking a pre-trained deep model and using the patterns it has learned as the inputs to your linear model. This saves dramatically on training time and allows you to experiment faster.</p> <p>Where do I find pre-trained models?</p> <p>Pre-trained models are available on PyTorch hub, TensorFlow hub, model zoo and within the fast.ai framework. This is a good place to look first for building any kind of proof of concept.</p> <p>What about the other kinds of models?</p> <p>For building a proof of concept, it\u2019s unlikely you\u2019ll have to ever build your own machine learning model. People have already written code for these.</p> <p>What you\u2019ll be focused on is preparing your inputs and outputs in a way they can be used with an existing model. This means having your data and labels strictly defined and understanding what problem you\u2019re trying to solve.</p>"},{"location":"a-6-step-framework-for-approaching-machine-learning-projects/#tuning-and-improving-a-model","title":"Tuning and improving a model","text":"<p>A model's first results isn\u2019t its last. Like tuning a car, machine learning models can be tuned to improve performance.</p> <p>Tuning a model involves changing hyperparameters such as learning rate or optimizer. Or model-specific architecture factors such as number of trees for random forests and number of and type of layers for neural networks.</p> <p>These used to be something a practitioner would have to tune by hand but are increasingly becoming automated. And should be wherever possible.</p> <p>Using a pre-trained model through transfer learning often has the added benefit of all of these steps been done.</p> <p>The priority for tuning and improving models should be reproducibility and efficiency. Someone should be able to reproduce the steps you\u2019ve taken to improve performance. And because your main bottleneck will be model training time, not new ideas to improve, your efforts should be dedicated towards efficiency.</p>"},{"location":"a-6-step-framework-for-approaching-machine-learning-projects/#comparing-models","title":"Comparing models","text":"<p>Compare apples to apples.</p> <ul> <li>Model 1, trained on data X, evaluated on data Y.</li> <li>Model 2, trained on data X, evaluated on data Y.</li> </ul> <p>Where model 1 and 2 can vary but not data X or data Y.</p>"},{"location":"a-6-step-framework-for-approaching-machine-learning-projects/#6-experimentation-what-else-could-we-try-how-do-the-other-steps-change-based-on-what-weve-found-does-our-deployed-model-do-as-we-expected","title":"6. Experimentation\u200a\u2014\u200aWhat else could we try? How do the other steps change based on what we\u2019ve found? Does our deployed model do as we expected?","text":"<p>This step involves all the other steps. Because machine learning is a highly iterative process, you\u2019ll want to make sure your experiments are actionable.</p> <p>Your biggest goal should be minimising the time between offline experiments and online experiments.</p> <p>Offline experiments are steps you take when your project isn\u2019t customer-facing yet. Online experiments happen when your machine learning model is in production.</p> <p>All experiments should be conducted on different portions of your data.</p> <ul> <li>Training data set\u200a\u2014\u200aUse this set for model training, 70\u201380% of your data is the standard.</li> <li>Validation/development data set\u200a\u2014\u200aUse this set for model tuning, 10\u201315% of your data is the standard.</li> <li>Test data set\u200a\u2014\u200aUse this set for model testing and comparison, 10\u201315% of your data is the standard.</li> </ul> <p>These amounts can fluctuate slightly, depending on your problem and the data you have.</p> <p>Poor performance on training data means the model hasn\u2019t learned properly. Try a different model, improve the existing one, collect more data, collect better data.</p> <p>Poor performance on test data means your model doesn\u2019t generalise well. Your model may be overfitting the training data. Use a simpler model or collect more data.</p> <p>Poor performance once deployed (in the real world) means there\u2019s a difference in what you trained and tested your model on and what is actually happening. Revisit step 1 &amp; 2. Ensure your data matches up with the problem you\u2019re trying to solve.</p> <p>When you implement a large experimental change, document what and why. Remember, like model tuning, someone, including your future self, should be able to reproduce what you\u2019ve done.</p> <p>This means saving updated models and updated datasets regularly.</p>"},{"location":"a-6-step-framework-for-approaching-machine-learning-projects/#putting-it-together-in-a-proof-of-concept","title":"Putting it together in a proof of concept","text":"<p>Many businesses have heard of machine learning but aren\u2019t sure where to start. One of the best places to start is to use the six steps above to build a proof of concept.</p> <p>A proof of concept should not be seen as something to fundamentally change how your business operates but as an exploration into whether machine learning can bring your business value.</p> <p>After all, you\u2019re not after fancy solutions to keep up with the hype. You\u2019re after solutions which add value.</p> <p>Put a timeline on a proof of concept, 2, 6 and 12 weeks are good amounts. With good data, a good machine learning and data science practitioner can get 80\u201390% of the final modelling results in a relatively small timeframe.</p> <p>Have your subject matter experts and machine learning engineers and data scientists work together. There is nothing worse than a machine learning engineer building a great model which models the wrong thing.</p> <p>If a web designer could improve the layout of an online store to help a machine learning experiment, they should know.</p> <p>Remember, due to the nature of proof of concepts, it may turn out machine learning isn\u2019t something your business can take advantage of (unlikely). As a project manager, ensure you\u2019re aware of this. If you are a machine learning engineer or data scientist, be willing to accept your conclusions lead nowhere.</p> <p>But all is not lost.</p> <p>The value in something not working is now you know what doesn\u2019t work and can direct your efforts elsewhere. This is why setting a timeframe for experiments is helpful. There is never enough time but deadlines work wonders.</p> <p>If a machine learning proof of concept turns out well, take another step, if not, step back. Learning by doing is a faster process than thinking about something.</p>"},{"location":"a-6-step-framework-for-approaching-machine-learning-projects/#things-this-article-has-missed","title":"Things this article has missed","text":"<p>Each of these steps could deserve an article on their own. I\u2019ll work on it.</p> <p>In the meantime, there are some things to note.</p> <p>It\u2019s always about the data. Without good data to begin with, no machine learning model will help you. If you want to use machine learning in your business, it starts with good data collection.</p> <p>Deployment changes everything. A good model offline doesn\u2019t always mean a good model online. This article has focused on data modelling. Once you deploy a model, there\u2019s infrastructure management, data verification, model retraining, analysis and more. Any cloud provider has services for these but putting them together is still a bit of a dark art. Pay your data engineers well. If you\u2019re data engineer, share what you know.</p> <p>Data collection and model deployment are the longest parts of a machine learning pipeline. This article has only focused on modelling. And even then, it misses specifics on how to get your data ready to be modelled (other sections in this repo cover that).</p> <p>Tools of the trade vary. Machine learning is big tool comprised of many other tools. From code libraries and frameworks to different deployment architectures. There\u2019s usually several different ways to do the same thing. Best practice is continually being changed. This article focuses on things which don\u2019t.</p>"},{"location":"communicating-your-work/","title":"Communicating and Sharing Your Work as a Data Scientist/Machine Learning Engineer","text":"<p>This article is nearly 3000 words long but you can summarise it in 3.</p> <p>3 words in the form of a question.</p> <p>Whenever you're communicating your work, ask yourself, \"Who's it for?\".</p> <p>That's your start. Build upon it. Dig deeper. Got an idea of who your work is for? What questions will they have? What needs do they have? What concerns can you address before they arise?</p> <p>You'll never be able to fully answer these questions but it pays to think about them in advance.</p> <p>Having a conversation with your potential audience is a warm up for the actual conversation.</p> <p>Communicating your work is an unsolved challenge. But that's what makes it fun. What may make complete sense in your head could be a complete mystery to someone else.</p> <p>If you want your message to be heard, it's not enough for you to deliver it in a way someone can hear it. You have to deliver it in a way it can be understood.</p> <p>Imagine a man yelling in the middle of the street. His message can be heard. But no matter what he's talking about, it's unlikely it'll be understood.</p> <p>Let's break this down.</p> <p>After asking yourself, \"Who's it for?\", you'll start to realise there are two main audiences for your work. Those on your team, your boss, your manager, the people you sit next to and those who aren't, your clients, your customers, your fans. These can be broken down further and have plenty of overlaps but they're where we'll start.</p> <p>You'll also start to realise, your work isn't for everyone. A beginner's mistake is thinking too broadly. A message which appeals to everyone may convey information but it'll lack substance. You want the gut punch reaction.</p> <p>To begin, let's pretend you've asked yourself, \"Who's it for?\", and your answer is someone you work with, your teammates, your manager, someone on the internet reading about your latest technical project.</p>"},{"location":"communicating-your-work/#communicating-with-people-on-your-team","title":"Communicating with people on your team","text":"<p>All non-technical problems are communication problems. Often, you'll find these harder to solve than the technical problems. Technical problems, unless bounded by the laws of physics, have a finite solution. Communication problems don't.</p>"},{"location":"communicating-your-work/#what-do-they-need-to-know","title":"What do they need to know?","text":"<p>After asking yourself, \"Who's it for?\", a question you should follow up with is, \"What do they need to know?\".</p> <p>What your teammate may need to know might be different to what your manager needs to know.</p> <p>When answering this for yourself, lean on the side of excess. Write it down for later. The worst case is, you figure out what's not needed.</p> Start with \"Who's it for?\" and follow it up with \"What do they need to know?\". When answering these questions, write your questions and answers down. Writing helps to clear your thinking. It also gives you a resource you can refer to later."},{"location":"communicating-your-work/#the-project-manager-boss-senior-lead","title":"The Project Manager, Boss, Senior, Lead","text":"<p>Your project manager, Amber, has a mission. Aside from taking care of you and the team, she's determined to keep the project running on time and on budget.</p> <p>This translates to: keeping obstacles out of your way.</p> <p>So her questions will often come in some form of \"What's holding you back?\".</p> <p>It should go without saying, honesty is your best friend here. Life happens. When challenges come up, Amber should know about them.</p> <p>That's what Amber is there for. She's there to help oversee and figure out the challenges, she's there to connect you with people who might be able to help.</p> <p>When preparing a report, align it to the questions and concerns Amber may have. If you\u2019ve asked yourself, \u201cWhat does Amber need to know?\u201d, start with the answers.</p> Your bosses primary job is to take care of you and challenging you (if not, get a new boss). After this, it's in their best interest for projects to run on budget and time. This means keeping obstacles out of your way. If something is holding you back, you should let them know."},{"location":"communicating-your-work/#the-people-youre-working-with-sitting-next-to-in-the-group-chat","title":"The People You're Working With, Sitting Next to, in the Group Chat","text":"<p>It saddens me how many communication channels there are now. Most of them encourage communicating too often. Unless it's an emergency, \"Now\" is often never the best time.</p> <p>Projects you work on will have arbitrarily long timelines, with many milestones, plans and steps. Keep in mind the longer the timescale, the worse humans are at dealing with them.</p> <p>Break it down. Days and weeks are much easier units of time to understand.</p> Example of how a 6-month project becomes a day-by-day project. <p>What are you working on this week? Write it down, share it with the team. This not only consolidates your thinking, it gives your team an opportunity to ask questions and offer advice.</p> <p>Set a reminder for the end of each day. Have it ask, \"What did you work on today?\". Your response doesn't have to be long but it should be written down.</p> <p>You could use the following template.</p> <p>What I worked on today (1-3 points on what you did):</p> <ul> <li>What's working?</li> <li>What's not working?</li> <li>What could be improved?</li> </ul> <p>What I'm working on next:</p> <ul> <li>What's your next course of action? (based on the above)</li> <li>Why?</li> <li>What's holding you back?</li> </ul> <p>After you've written down answers, you should share them with your team.</p> <p>The beauty of a daily reflection like this is you've got a history, a playbook, a thought process. Plus, this style of communication is far better than little bits and pieces scattered throughout the day.</p> <p>You may be tempted to hold something back because it's not perfect, not fully thought out, but that's what your teammates are for. To help you figure it out. The same goes for the reverse. Help each other.</p> <p>Relate these daily and weekly communications back to the overall project goal. A 6-month project seems like a lot to begin with but breaking it down week by week, day by day, helps you and the people around you know what's going on.</p> <p>Take note of questions which arise. If a question gets asked more than 3 times, it should be documented somewhere for others to reference.</p> <p>You'll see some of the communication points for the people you're sitting with crossover with your project manager and vice versa. You're smart enough to figure out when to use each.</p>"},{"location":"communicating-your-work/#start-the-job-before-you-have-it","title":"Start the job before you have it","text":"<p>It can be hard to communicate with a project manager, boss or teammates if you don't have a job. And if you've recently learned some skills through an online course, it can be tempting to jump straight into the next one.</p> <p>But what are you really chasing?</p> <p>Are you after more certificates or more skills?</p> <p>No matter how good the course, you can assume the skills you learn there will be commoditised. That means, many other people will have gone through the same course, acquired the skills and then will be looking for similar jobs to what you are.</p> <p>If Janet posts a job vacancy and receives 673 applicants through an online form, you can imagine how hard it is for your resume to stand out.</p> <p>This isn't to say you shouldn't apply through an online form but if you're really serious about getting a role somewhere, start the job before you have it.</p> <p>How?</p> <p>By working on and sharing your own projects which relate to the role you're applying for.</p> <p>I call this the weekend project principle. During the week you're building foundational skills through various courses. But on the weekend, you design your own projects, projects inline with the role you're after and work on them.</p> <p>Let\u2019s see it in practice.</p> <p>Melissa and Henry apply for a data scientist role. They both make it through to interviews and are sitting with Janet. Janet looks at both their resumes and notices they've both done similar style courses.</p> <p>She asks Joe if he's worked on any of his own projects and he tells her, no he's only had a chance to work on coursework but has plenty of ideas.</p> <p>She asks Melissa the same. She pulls out her phone and tells Janet she's built a small app to help read food labels. Her daughter can't have gluten and got confused every time she tried to figure out what was in the food she was eating. The app isn't perfect but Melissa tells the story of how her daughter has figured out a few foods she should avoid and a few others which are fine.</p> <p>If you were Janet, who would you lean towards?</p> <p>Working on your own projects helps you build specific knowledge, they're what compound knowledge into skill, skill which can't be taught in courses.</p> <p>What should you work on?</p> <p>The hard part is you've unlimited options. The best part is you've got unlimited options.</p> <p>One method is to find the ideal company and ideal role you're going for. And then do your research.</p> <p>What does a person in that position day-to-day? Figure it out and then replicate it. Design yourself a 6-week project based on what you find.</p> <p>Why 6-weeks? The worst case is, if it doesn't work out, it's only 6 weeks. The best case is, you'll surprise yourself at what you can accomplish in 42-days.</p> <p>If you're still stuck, follow your interests. Use the same timeline except this time, choose something which excites you and see where it goes. Remember, the worst case is, after 6-weeks, you'll know whether to pursue it (another 6 weeks) or move onto the next thing.</p> <p>Now instead of only having a collection of certificates, you've got a story to tell. You've got evidence of you trying to put what you've learned into practice (exactly what you'll be doing in a job).</p> <p>And if you're wondering where the evidence comes from, it comes from you documenting your work.</p> <p>Where?</p> <p>On your own blog.</p> <p>Why a blog?</p> <p>We've discussed this before but it's worth repeating. Writing down what you're working on, helps solidify your thinking. It also helps others learn what you\u2019ve figured out.</p> <p>You could start with a post per week detailing how your 6-week project is going, what you've figured out, what you're doing next. Again, your project doesn't have to be perfect, none are, and your writing doesn't have to be perfect either.</p> <p>By the end of the 6-weeks, you'll have a series of articles detailing your work. </p> <p>Something you can point to and say, \"This is what I've done.\"</p> <p>If you're looking for resources to start a blog, Devblog by Hashnode and fast_template by the fast.ai team are both free and require almost zero setup. Medium is the next best place.</p> <p>Share your articles on Twitter, LinkedIn or even better, send them directly to the person in charge of hiring for the role you're after. You're crafty enough to find them.</p>"},{"location":"communicating-your-work/#communicating-with-those-outside-your-team","title":"Communicating with those outside your team","text":"<p>When answering \"Who's it for?\u201d results in someone who doesn't think like you, customers, clients, fans, it's also important to follow up with \"What do they need to know?\".</p> <p>A reminder: The line between people on your team and outside your team isn\u2019t set in stone. The goal of these exercises and techniques are to get you thinking from the perspective of the person you are trying to communicate with.</p>"},{"location":"communicating-your-work/#clients-customers-fans","title":"Clients, Customers &amp; Fans","text":"<p>I made a presentation for a board meeting once. We were there to present our results on a recent software proof of concept to some executives. Being an engineer, my presentation slides were clogged with detailed text, barely large enough to read. It contained every detail of the project, the techniques used, theories, code, acronyms with no definition. The presentation looked great to other engineers but caused the executives to squint, lean in and ignore everything being said in an attempt to read them.</p> <p>Once we made it through to the end, a slide with a visual appeared, to which, I palmed off as unnecessary but immediately sparked the interest of the executives.</p> <p>\"What's that?\", one asked.</p> <p>We spent the next 45-minutes discussing that one slide in detail. The slide which to me, didn\u2019t matter.</p> <p>The lesson here is what you think is important may be the opposite to others. And what's obvious to you could be amazing to others.</p> <p>Knowing this, you'll start to realise, unless they directly tell you, figuring out what your clients, customers and fans want to know is a challenge.</p> <p>There's a simple solution to this. </p> <p>Ask.</p> <p>Most people have a lot to offer but rarely volunteer it. Ask if what you're saying is clear, ask if there is anything else they'd like to see.</p> <p>You may get something left of field or things you're not sure of. In these cases, it's up to you to address them before they become larger issues.</p> <p>Don't forget, sometimes the best answer is \"I don't know, but I'll figure it out and get back to you,\" or \"that's not what we're focused on for now...\" (then bringing it back to what you are focused on).</p>"},{"location":"communicating-your-work/#what-story-are-you-telling","title":"What story are you telling?","text":"<p>You're going to underestimate and overestimate your work at the same time. This is a good thing. No one is going to care as much about your work as you. It's up to you to be your own biggest fan and harshest critique at the same time.</p> The first step of any creation is to make something you're proud of. The next step is to figure out how you could improve it. In other words, being your own biggest fan and harshest critique at the same time. <p>When sharing your work, you could drop the facts in. Nothing but a list of exactly what you did. But everyone else can do that too.</p> <p>Working what you've done into a story, sharing what worked, what didn't, why you went one direction and not another is hard. But that's exactly why it's worth it.</p> <p>I will say it until I go hoarse, how you deliver your message will depend on who your audience is.</p>"},{"location":"communicating-your-work/#being-specific-is-brave-put-it-in-writing-and-heres-what-ive-done","title":"Being specific is brave, put it in writing and here's what I've done","text":"<p>Starting with \"Who's it for?\", and following up with, \"What do they need to know?\", means you're going to have to be specific. And being specific means having to say, \u201cIt's not for you\" to a lot of people. Doing this takes courage but it also means the ones who do receive your message will engage with it more.</p> <p>You'll get lost in thought but found in the words. Writing is nature's way of showing how sloppy your thinking is. Break your larger projects down into a series of sub projects. </p> <p>What's on today? What's on this week? Tell yourself, tell your team.</p> <p>Take advantage of Cunningham's Law: Sometimes the best way to figure out the right answer isn't to ask a question, it's to put the wrong answer out there.</p> <p>Finally, remind yourself, you're not going for perfection. You're going for progress. Going for perfection gets in the way of progress.</p> <p>You know you should have your own blog, you know you should be building specific knowledge by working on your own your projects, you know you should be documenting what you've been working on.</p> <p>The upside of being able to say, \"Here's what I've done\", far outweighs the downside of potentially being wrong.</p>"},{"location":"communicating-your-work/#recommended-further-reading-and-resources","title":"Recommended Further Reading and Resources","text":"<p>This article was inspired by experience and a handful of other resources worth your time.</p> <ul> <li>Basecamp\u2019s guide to internal communication \u2013 if you're working on a team, this should be required reading for everyone.</li> <li>You Should Blog by Jeremy Howard from fast.ai \u2013 The fast.ai team not only teach amazing artificial intelligence and other technical skills, they teach you how to communicate them. The best thing is, they live and breath what they teach.</li> <li>How to Start Your Own Machine Learning Projects by Daniel Bourke \u2013 After learning foundational skills using courses, one of the hardest things to do next is to use the skills you've learned in your own projects. This article by yours truly gives a deeper breakdown into how to approach your own projects.</li> <li>Why you (yes, you) should blog by Rachel Thomas from fast.ai \u2013 Rachel Thomas not only has incredible technical skills, she's a phenomenal communicator. If you aren't convinced to start your own blog yet, this article will have you writing in no time.</li> <li>Fast Template by fast.ai \u2013 Starting a blog should be required for everyone learning some kind of skill. Fast Template by the fast.ai team makes it free and easy.</li> <li>Devblog by Hasnode \u2013 Your own blog, your own domain, readers ready to go, you own your content (automatic backups on GitHub), all ready to go. Start writing.</li> </ul>"},{"location":"end-to-end-bluebook-bulldozer-price-regression-v2/","title":"End-to-End Bulldozer Price Regression","text":"<p>View source code | Read notebook in online book format</p> In\u00a0[8]: Copied! <pre># Timestamp\nimport datetime\n\nimport datetime\nprint(f\"Notebook last run (end-to-end): {datetime.datetime.now()}\")\n</pre> # Timestamp import datetime  import datetime print(f\"Notebook last run (end-to-end): {datetime.datetime.now()}\") <pre>Notebook last run (end-to-end): 2024-10-30 11:54:38.504966\n</pre> In\u00a0[9]: Copied! <pre># Import data analysis tools \nimport pandas as pd\nimport numpy as np\nimport matplotlib\nimport matplotlib.pyplot as plt\n\n# Print the versions we're using (as long as your versions are equal or higher than these, the code should work)\nprint(f\"pandas version: {pd.__version__}\")\nprint(f\"NumPy version: {np.__version__}\")\nprint(f\"matplotlib version: {matplotlib.__version__}\")\n</pre> # Import data analysis tools  import pandas as pd import numpy as np import matplotlib import matplotlib.pyplot as plt  # Print the versions we're using (as long as your versions are equal or higher than these, the code should work) print(f\"pandas version: {pd.__version__}\") print(f\"NumPy version: {np.__version__}\") print(f\"matplotlib version: {matplotlib.__version__}\")  <pre>pandas version: 2.2.2\nNumPy version: 2.1.1\nmatplotlib version: 3.9.2\n</pre> <p>Now we've got our tools for data analysis ready, we can import the data and start to explore it.</p> <p>For this project, I've downloaded the data from Kaggle and stored it on the course GitHub under the file path <code>../data/bluebook-for-bulldozers</code>.</p> <p>We can write some code to check if the files are available locally (on our computer) and if not, we can download them.</p> <p>Note: If you're running this notebook on Google Colab, the code below will enable you to download the dataset programmatically. Just beware that each time Google Colab shuts down, the data will have to be redownloaded. There's also an example Google Colab notebook showing how to download the data programmatically.</p> In\u00a0[10]: Copied! <pre>from pathlib import Path\n\n# Check if 'bluebook-for-bulldozers' exists in the current or parent directory\n# Link to data (see the file \"bluebook-for-bulldozers\"): https://github.com/mrdbourke/zero-to-mastery-ml/tree/master/data\ndataset_dir = Path(\"../data/bluebook-for-bulldozers\")\nif not (dataset_dir.is_dir()):\n    print(f\"[INFO] Can't find existing 'bluebook-for-bulldozers' dataset in current directory or parent directory, downloading...\")\n\n    # Download and unzip the bluebook for bulldozers dataset\n    !wget https://github.com/mrdbourke/zero-to-mastery-ml/raw/refs/heads/master/data/bluebook-for-bulldozers.zip\n    !unzip bluebook-for-bulldozers.zip\n\n    # Ensure a data directory exists and move the downloaded dataset there\n    !mkdir ../data/\n    !mv bluebook-for-bulldozers ../data/\n    print(f\"[INFO] Current dataset dir: {dataset_dir}\")\n\n    # Remove .zip file from notebook directory\n    !rm -rf bluebook-for-bulldozers.zip\nelse:\n    # If the target dataset directory exists, we don't need to download it\n    print(f\"[INFO] 'bluebook-for-bulldozers' dataset exists, feel free to proceed!\")\n    print(f\"[INFO] Current dataset dir: {dataset_dir}\")\n</pre> from pathlib import Path  # Check if 'bluebook-for-bulldozers' exists in the current or parent directory # Link to data (see the file \"bluebook-for-bulldozers\"): https://github.com/mrdbourke/zero-to-mastery-ml/tree/master/data dataset_dir = Path(\"../data/bluebook-for-bulldozers\") if not (dataset_dir.is_dir()):     print(f\"[INFO] Can't find existing 'bluebook-for-bulldozers' dataset in current directory or parent directory, downloading...\")      # Download and unzip the bluebook for bulldozers dataset     !wget https://github.com/mrdbourke/zero-to-mastery-ml/raw/refs/heads/master/data/bluebook-for-bulldozers.zip     !unzip bluebook-for-bulldozers.zip      # Ensure a data directory exists and move the downloaded dataset there     !mkdir ../data/     !mv bluebook-for-bulldozers ../data/     print(f\"[INFO] Current dataset dir: {dataset_dir}\")      # Remove .zip file from notebook directory     !rm -rf bluebook-for-bulldozers.zip else:     # If the target dataset directory exists, we don't need to download it     print(f\"[INFO] 'bluebook-for-bulldozers' dataset exists, feel free to proceed!\")     print(f\"[INFO] Current dataset dir: {dataset_dir}\") <pre>[INFO] 'bluebook-for-bulldozers' dataset exists, feel free to proceed!\n[INFO] Current dataset dir: ../data/bluebook-for-bulldozers\n</pre> <p>Dataset downloaded!</p> <p>Let's check what files are available.</p> In\u00a0[11]: Copied! <pre>import os\n\nprint(f\"[INFO] Files/folders available in {dataset_dir}:\")\nos.listdir(dataset_dir)\n</pre> import os  print(f\"[INFO] Files/folders available in {dataset_dir}:\") os.listdir(dataset_dir) <pre>[INFO] Files/folders available in ../data/bluebook-for-bulldozers:\n</pre> Out[11]: <pre>['random_forest_benchmark_test.csv',\n 'Valid.csv',\n 'median_benchmark.csv',\n 'Valid.zip',\n 'TrainAndValid.7z',\n 'Test.csv',\n 'predictions.csv',\n 'Train.7z',\n 'TrainAndValid_object_values_as_categories.parquet',\n 'test_predictions.csv',\n 'ValidSolution.csv',\n 'train_tmp.csv',\n 'Machine_Appendix.csv',\n 'Train.csv',\n 'Valid.7z',\n 'TrainAndValid_object_values_as_categories.csv',\n 'TrainAndValid_object_values_as_categories_and_missing_values_filled.parquet',\n 'Data Dictionary.xlsx',\n 'TrainAndValid.csv',\n 'Train.zip',\n 'TrainAndValid.zip']</pre> <p>You can explore each of these files individually or read about them on the Kaggle Competition page.</p> <p>For now, the main file we're interested in is <code>TrainAndValid.csv</code> (this is also a combination of <code>Train.csv</code> and <code>Valid.csv</code>), this is a combination of the training and validation datasets.</p> <ul> <li>The training data (<code>Train.csv</code>) contains sale data from 1989 up to the end of 2011.</li> <li>The validation data (<code>Valid.csv</code>) contains sale data from January 1, 2012 - April 30, 2012.</li> <li>The test data (<code>Test.csv</code>) contains sale data from May 1, 2012 - November 2012.</li> </ul> <p>We'll use the training data to train our model to predict the sale price of bulldozers, we'll then validate its performance on the validation data to see if our model can be improved in any way. Finally, we'll evaluate our best model on the test dataset.</p> <p>But more on this later on.</p> <p>Let's import the <code>TrainAndValid.csv</code> file and turn it into a pandas DataFrame.</p> In\u00a0[12]: Copied! <pre># Import the training and validation set\ndf = pd.read_csv(filepath_or_buffer=\"../data/bluebook-for-bulldozers/TrainAndValid.csv\")\n</pre> # Import the training and validation set df = pd.read_csv(filepath_or_buffer=\"../data/bluebook-for-bulldozers/TrainAndValid.csv\") <pre>/var/folders/c4/qj4gdk190td18bqvjjh0p3p00000gn/T/ipykernel_20423/1127193594.py:2: DtypeWarning: Columns (13,39,40,41) have mixed types. Specify dtype option on import or set low_memory=False.\n  df = pd.read_csv(filepath_or_buffer=\"../data/bluebook-for-bulldozers/TrainAndValid.csv\")\n</pre> <p>Wonderful! We've got our DataFrame ready to explore.</p> <p>You might see a warning appear in the form:</p> <p><code>DtypeWarning: Columns (13,39,40,41) have mixed types. Specify dtype option on import or set low_memory=False. df = pd.read_csv(\"../data/bluebook-for-bulldozers/TrainAndValid.csv\")</code></p> <p>This is just saying that some of our columns have multiple/mixed data types. For example, a column may contain strings but also contain integers. This is okay for now and can be addressed later on if necessary.</p> <p>How about we get some information about our DataFrame?</p> In\u00a0[13]: Copied! <pre># Get info about DataFrame\ndf.info()\n</pre> # Get info about DataFrame df.info() <pre>&lt;class 'pandas.core.frame.DataFrame'&gt;\nRangeIndex: 412698 entries, 0 to 412697\nData columns (total 53 columns):\n #   Column                    Non-Null Count   Dtype  \n---  ------                    --------------   -----  \n 0   SalesID                   412698 non-null  int64  \n 1   SalePrice                 412698 non-null  float64\n 2   MachineID                 412698 non-null  int64  \n 3   ModelID                   412698 non-null  int64  \n 4   datasource                412698 non-null  int64  \n 5   auctioneerID              392562 non-null  float64\n 6   YearMade                  412698 non-null  int64  \n 7   MachineHoursCurrentMeter  147504 non-null  float64\n 8   UsageBand                 73670 non-null   object \n 9   saledate                  412698 non-null  object \n 10  fiModelDesc               412698 non-null  object \n 11  fiBaseModel               412698 non-null  object \n 12  fiSecondaryDesc           271971 non-null  object \n 13  fiModelSeries             58667 non-null   object \n 14  fiModelDescriptor         74816 non-null   object \n 15  ProductSize               196093 non-null  object \n 16  fiProductClassDesc        412698 non-null  object \n 17  state                     412698 non-null  object \n 18  ProductGroup              412698 non-null  object \n 19  ProductGroupDesc          412698 non-null  object \n 20  Drive_System              107087 non-null  object \n 21  Enclosure                 412364 non-null  object \n 22  Forks                     197715 non-null  object \n 23  Pad_Type                  81096 non-null   object \n 24  Ride_Control              152728 non-null  object \n 25  Stick                     81096 non-null   object \n 26  Transmission              188007 non-null  object \n 27  Turbocharged              81096 non-null   object \n 28  Blade_Extension           25983 non-null   object \n 29  Blade_Width               25983 non-null   object \n 30  Enclosure_Type            25983 non-null   object \n 31  Engine_Horsepower         25983 non-null   object \n 32  Hydraulics                330133 non-null  object \n 33  Pushblock                 25983 non-null   object \n 34  Ripper                    106945 non-null  object \n 35  Scarifier                 25994 non-null   object \n 36  Tip_Control               25983 non-null   object \n 37  Tire_Size                 97638 non-null   object \n 38  Coupler                   220679 non-null  object \n 39  Coupler_System            44974 non-null   object \n 40  Grouser_Tracks            44875 non-null   object \n 41  Hydraulics_Flow           44875 non-null   object \n 42  Track_Type                102193 non-null  object \n 43  Undercarriage_Pad_Width   102916 non-null  object \n 44  Stick_Length              102261 non-null  object \n 45  Thumb                     102332 non-null  object \n 46  Pattern_Changer           102261 non-null  object \n 47  Grouser_Type              102193 non-null  object \n 48  Backhoe_Mounting          80712 non-null   object \n 49  Blade_Type                81875 non-null   object \n 50  Travel_Controls           81877 non-null   object \n 51  Differential_Type         71564 non-null   object \n 52  Steering_Controls         71522 non-null   object \ndtypes: float64(3), int64(5), object(45)\nmemory usage: 166.9+ MB\n</pre> <p>Woah! Over 400,000 entries!</p> <p>That's a much larger dataset than what we've worked with before.</p> <p>One thing you might have noticed is that the <code>saledate</code> column value is being treated as a Python object (it's okay if you didn't notice, these things take practice).</p> <p>When the <code>Dtype</code> is <code>object</code>, it's saying that it's a string.</p> <p>However, when we look at it...</p> In\u00a0[15]: Copied! <pre>df[\"saledate\"][:10]\n</pre> df[\"saledate\"][:10] Out[15]: <pre>0    11/16/2006 0:00\n1     3/26/2004 0:00\n2     2/26/2004 0:00\n3     5/19/2011 0:00\n4     7/23/2009 0:00\n5    12/18/2008 0:00\n6     8/26/2004 0:00\n7    11/17/2005 0:00\n8     8/27/2009 0:00\n9      8/9/2007 0:00\nName: saledate, dtype: object</pre> <p>We can see that these <code>object</code>'s are in the form of dates.</p> <p>Since we're working on a time series problem (a machine learning problem with a time component), it's probably worth it to turn these strings into Python <code>datetime</code> objects.</p> <p>Before we do, let's try visualize our <code>saledate</code> column against our <code>SalePrice</code> column.</p> <p>To do so, we can create a scatter plot.</p> <p>And to prevent our plot from being too big, how about we visualize the first 1000 values?</p> In\u00a0[16]: Copied! <pre>fig, ax = plt.subplots()\nax.scatter(x=df[\"saledate\"][:1000], # visualize the first 1000 values\n           y=df[\"SalePrice\"][:1000])\nax.set_xlabel(\"Sale Date\")\nax.set_ylabel(\"Sale Price ($)\");\n</pre> fig, ax = plt.subplots() ax.scatter(x=df[\"saledate\"][:1000], # visualize the first 1000 values            y=df[\"SalePrice\"][:1000]) ax.set_xlabel(\"Sale Date\") ax.set_ylabel(\"Sale Price ($)\"); <p>Hmm... looks like the x-axis is quite crowded.</p> <p>Maybe we can fix this by turning the <code>saledate</code> column into <code>datetime</code> format.</p> <p>Good news is that is looks like our <code>SalePrice</code> column is already in <code>float64</code> format so we can view its distribution directly from the DataFrame using a histogram plot.</p> In\u00a0[17]: Copied! <pre># View SalePrice distribution \ndf.SalePrice.plot.hist(xlabel=\"Sale Price ($)\");\n</pre> # View SalePrice distribution  df.SalePrice.plot.hist(xlabel=\"Sale Price ($)\"); In\u00a0[18]: Copied! <pre>df = pd.read_csv(filepath_or_buffer=\"../data/bluebook-for-bulldozers/TrainAndValid.csv\",\n                 low_memory=False, # set low_memory=False to prevent mixed data types warning \n                 parse_dates=[\"saledate\"]) # can use the parse_dates parameter and specify which column to treat as a date column\n\n# With parse_dates... check dtype of \"saledate\"\ndf.info()\n</pre> df = pd.read_csv(filepath_or_buffer=\"../data/bluebook-for-bulldozers/TrainAndValid.csv\",                  low_memory=False, # set low_memory=False to prevent mixed data types warning                   parse_dates=[\"saledate\"]) # can use the parse_dates parameter and specify which column to treat as a date column  # With parse_dates... check dtype of \"saledate\" df.info() <pre>&lt;class 'pandas.core.frame.DataFrame'&gt;\nRangeIndex: 412698 entries, 0 to 412697\nData columns (total 53 columns):\n #   Column                    Non-Null Count   Dtype         \n---  ------                    --------------   -----         \n 0   SalesID                   412698 non-null  int64         \n 1   SalePrice                 412698 non-null  float64       \n 2   MachineID                 412698 non-null  int64         \n 3   ModelID                   412698 non-null  int64         \n 4   datasource                412698 non-null  int64         \n 5   auctioneerID              392562 non-null  float64       \n 6   YearMade                  412698 non-null  int64         \n 7   MachineHoursCurrentMeter  147504 non-null  float64       \n 8   UsageBand                 73670 non-null   object        \n 9   saledate                  412698 non-null  datetime64[ns]\n 10  fiModelDesc               412698 non-null  object        \n 11  fiBaseModel               412698 non-null  object        \n 12  fiSecondaryDesc           271971 non-null  object        \n 13  fiModelSeries             58667 non-null   object        \n 14  fiModelDescriptor         74816 non-null   object        \n 15  ProductSize               196093 non-null  object        \n 16  fiProductClassDesc        412698 non-null  object        \n 17  state                     412698 non-null  object        \n 18  ProductGroup              412698 non-null  object        \n 19  ProductGroupDesc          412698 non-null  object        \n 20  Drive_System              107087 non-null  object        \n 21  Enclosure                 412364 non-null  object        \n 22  Forks                     197715 non-null  object        \n 23  Pad_Type                  81096 non-null   object        \n 24  Ride_Control              152728 non-null  object        \n 25  Stick                     81096 non-null   object        \n 26  Transmission              188007 non-null  object        \n 27  Turbocharged              81096 non-null   object        \n 28  Blade_Extension           25983 non-null   object        \n 29  Blade_Width               25983 non-null   object        \n 30  Enclosure_Type            25983 non-null   object        \n 31  Engine_Horsepower         25983 non-null   object        \n 32  Hydraulics                330133 non-null  object        \n 33  Pushblock                 25983 non-null   object        \n 34  Ripper                    106945 non-null  object        \n 35  Scarifier                 25994 non-null   object        \n 36  Tip_Control               25983 non-null   object        \n 37  Tire_Size                 97638 non-null   object        \n 38  Coupler                   220679 non-null  object        \n 39  Coupler_System            44974 non-null   object        \n 40  Grouser_Tracks            44875 non-null   object        \n 41  Hydraulics_Flow           44875 non-null   object        \n 42  Track_Type                102193 non-null  object        \n 43  Undercarriage_Pad_Width   102916 non-null  object        \n 44  Stick_Length              102261 non-null  object        \n 45  Thumb                     102332 non-null  object        \n 46  Pattern_Changer           102261 non-null  object        \n 47  Grouser_Type              102193 non-null  object        \n 48  Backhoe_Mounting          80712 non-null   object        \n 49  Blade_Type                81875 non-null   object        \n 50  Travel_Controls           81877 non-null   object        \n 51  Differential_Type         71564 non-null   object        \n 52  Steering_Controls         71522 non-null   object        \ndtypes: datetime64[ns](1), float64(3), int64(5), object(44)\nmemory usage: 166.9+ MB\n</pre> <p>Nice!</p> <p>Looks like our <code>saledate</code> column is now of type <code>datetime64[ns]</code>, a NumPy-specific datetime format with high precision.</p> <p>Since pandas works well with NumPy, we can keep it in this format.</p> <p>How about we view a few samples from our <code>SaleDate</code> column again?</p> In\u00a0[19]: Copied! <pre>df[\"saledate\"][:10]\n</pre> df[\"saledate\"][:10] Out[19]: <pre>0   2006-11-16\n1   2004-03-26\n2   2004-02-26\n3   2011-05-19\n4   2009-07-23\n5   2008-12-18\n6   2004-08-26\n7   2005-11-17\n8   2009-08-27\n9   2007-08-09\nName: saledate, dtype: datetime64[ns]</pre> <p>Beautiful! That's looking much better already.</p> <p>We'll see how having our dates in this format is really helpful later on.</p> <p>For now, how about we visualize our <code>saledate</code> column against our <code>SalePrice</code> column again?</p> In\u00a0[20]: Copied! <pre>fig, ax = plt.subplots()\nax.scatter(x=df[\"saledate\"][:1000], # visualize the first 1000 values\n           y=df[\"SalePrice\"][:1000])\nax.set_xlabel(\"Sale Date\")\nax.set_ylabel(\"Sale Price ($)\");\n</pre> fig, ax = plt.subplots() ax.scatter(x=df[\"saledate\"][:1000], # visualize the first 1000 values            y=df[\"SalePrice\"][:1000]) ax.set_xlabel(\"Sale Date\") ax.set_ylabel(\"Sale Price ($)\"); In\u00a0[21]: Copied! <pre># Sort DataFrame in date order\ndf.sort_values(by=[\"saledate\"], inplace=True, ascending=True)\ndf.saledate.head(10), df.saledate.tail(10)\n</pre> # Sort DataFrame in date order df.sort_values(by=[\"saledate\"], inplace=True, ascending=True) df.saledate.head(10), df.saledate.tail(10) Out[21]: <pre>(205615   1989-01-17\n 274835   1989-01-31\n 141296   1989-01-31\n 212552   1989-01-31\n 62755    1989-01-31\n 54653    1989-01-31\n 81383    1989-01-31\n 204924   1989-01-31\n 135376   1989-01-31\n 113390   1989-01-31\n Name: saledate, dtype: datetime64[ns],\n 409202   2012-04-28\n 408976   2012-04-28\n 411695   2012-04-28\n 411319   2012-04-28\n 408889   2012-04-28\n 410879   2012-04-28\n 412476   2012-04-28\n 411927   2012-04-28\n 407124   2012-04-28\n 409203   2012-04-28\n Name: saledate, dtype: datetime64[ns])</pre> <p>Nice!</p> <p>Looks like our older samples are now coming first and the newer samples are towards the end of the DataFrame.</p> In\u00a0[22]: Copied! <pre># Make a copy of the original DataFrame to perform edits on\ndf_tmp = df.copy()\n</pre> # Make a copy of the original DataFrame to perform edits on df_tmp = df.copy() <p>Because we imported the data using <code>read_csv()</code> and we asked pandas to parse the dates using <code>parase_dates=[\"saledate\"]</code>, we can now access the different datetime attributes of the <code>saledate</code> column.</p> <p>Let's use these attributes to add a series of different feature columns to our dataset.</p> <p>After we've added these extra columns, we can remove the original <code>saledate</code> column as its information will be dispersed across these new columns.</p> In\u00a0[23]: Copied! <pre># Add datetime parameters for saledate\ndf_tmp[\"saleYear\"] = df_tmp.saledate.dt.year\ndf_tmp[\"saleMonth\"] = df_tmp.saledate.dt.month\ndf_tmp[\"saleDay\"] = df_tmp.saledate.dt.day\ndf_tmp[\"saleDayofweek\"] = df_tmp.saledate.dt.dayofweek\ndf_tmp[\"saleDayofyear\"] = df_tmp.saledate.dt.dayofyear\n\n# Drop original saledate column\ndf_tmp.drop(\"saledate\", axis=1, inplace=True)\n</pre> # Add datetime parameters for saledate df_tmp[\"saleYear\"] = df_tmp.saledate.dt.year df_tmp[\"saleMonth\"] = df_tmp.saledate.dt.month df_tmp[\"saleDay\"] = df_tmp.saledate.dt.day df_tmp[\"saleDayofweek\"] = df_tmp.saledate.dt.dayofweek df_tmp[\"saleDayofyear\"] = df_tmp.saledate.dt.dayofyear  # Drop original saledate column df_tmp.drop(\"saledate\", axis=1, inplace=True) <p>We could add more of these style of columns, such as, whether it was the start or end of a quarter (the sale being at the end of a quarter may bye influenced by things such as quarterly budgets) but these will do for now.</p> <p>Challenge: See what other datetime attributes you can add to <code>df_tmp</code> using a similar technique to what we've used above. Hint: check the bottom of the <code>pandas.DatetimeIndex</code> docs.</p> <p>How about we view some of our newly created columns?</p> In\u00a0[24]: Copied! <pre># View newly created columns\ndf_tmp[[\"SalePrice\", \"saleYear\", \"saleMonth\", \"saleDay\", \"saleDayofweek\", \"saleDayofyear\"]].head()\n</pre> # View newly created columns df_tmp[[\"SalePrice\", \"saleYear\", \"saleMonth\", \"saleDay\", \"saleDayofweek\", \"saleDayofyear\"]].head() Out[24]: SalePrice saleYear saleMonth saleDay saleDayofweek saleDayofyear 205615 9500.0 1989 1 17 1 17 274835 14000.0 1989 1 31 1 31 141296 50000.0 1989 1 31 1 31 212552 16000.0 1989 1 31 1 31 62755 22000.0 1989 1 31 1 31 <p>Cool!</p> <p>Now we've broken our <code>saledate</code> column into columns/features, we can perform further exploratory analysis such as visualizing the <code>SalePrice</code> against the <code>saleMonth</code>.</p> <p>How about we view the first 10,000 samples (we could also randomly select 10,000 samples too) to see if reveals anything about which month has the highest sales?</p> In\u00a0[25]: Copied! <pre># View 10,000 samples SalePrice against saleMonth\nfig, ax = plt.subplots()\nax.scatter(x=df_tmp[\"saleMonth\"][:10000], # visualize the first 10000 values\n           y=df_tmp[\"SalePrice\"][:10000])\nax.set_xlabel(\"Sale Month\")\nax.set_ylabel(\"Sale Price ($)\");\n</pre> # View 10,000 samples SalePrice against saleMonth fig, ax = plt.subplots() ax.scatter(x=df_tmp[\"saleMonth\"][:10000], # visualize the first 10000 values            y=df_tmp[\"SalePrice\"][:10000]) ax.set_xlabel(\"Sale Month\") ax.set_ylabel(\"Sale Price ($)\"); <p>Hmm... doesn't look like there's too much conclusive evidence here about which month has the highest sales value.</p> <p>How about we plot the median sale price of each month?</p> <p>We can do so by grouping on the <code>saleMonth</code> column with <code>pandas.DataFrame.groupby</code> and then getting the median of the <code>SalePrice</code> column.</p> In\u00a0[26]: Copied! <pre># Group DataFrame by saleMonth and then find the median SalePrice\ndf_tmp.groupby([\"saleMonth\"])[\"SalePrice\"].median().plot()\nplt.xlabel(\"Month\")\nplt.ylabel(\"Median Sale Price ($)\");\n</pre> # Group DataFrame by saleMonth and then find the median SalePrice df_tmp.groupby([\"saleMonth\"])[\"SalePrice\"].median().plot() plt.xlabel(\"Month\") plt.ylabel(\"Median Sale Price ($)\"); <p>Ohhh it looks like the median sale prices of January and February (months 1 and 2) are quite a bit higher than the other months of the year.</p> <p>Could this be because of New Year budget spending?</p> <p>Perhaps... but this would take a bit more investigation.</p> <p>In the meantime, there are many other values we could look further into.</p> In\u00a0[27]: Copied! <pre># Check the different values of different columns\ndf_tmp.state.value_counts()[:10]\n</pre> # Check the different values of different columns df_tmp.state.value_counts()[:10] Out[27]: <pre>state\nFlorida        67320\nTexas          53110\nCalifornia     29761\nWashington     16222\nGeorgia        14633\nMaryland       13322\nMississippi    13240\nOhio           12369\nIllinois       11540\nColorado       11529\nName: count, dtype: int64</pre> <p>Woah! Looks like Flordia sells a fair few bulldozers.</p> <p>How about we go even further and group our samples by <code>state</code> and then find the median <code>SalePrice</code> per state?</p> <p>We also compare this to the median <code>SalePrice</code> for all samples.</p> In\u00a0[28]: Copied! <pre># Group DataFrame by saleMonth and then find the median SalePrice per state as well as across the whole dataset\nmedian_prices_by_state = df_tmp.groupby([\"state\"])[\"SalePrice\"].median() # this will return a pandas Series rather than a DataFrame\nmedian_sale_price = df_tmp[\"SalePrice\"].median()\n\n# Create a plot comparing median sale price per state to median sale price overall\nplt.figure(figsize=(10, 7))\nplt.bar(x=median_prices_by_state.index, # Because we're working with a Series, we can use the index (state names) as the x values\n        height=median_prices_by_state.values)\nplt.xlabel(\"State\")\nplt.ylabel(\"Median Sale Price ($)\")\nplt.xticks(rotation=90, fontsize=7);\nplt.axhline(y=median_sale_price, \n            color=\"red\", \n            linestyle=\"--\", \n            label=f\"Median Sale Price: ${median_sale_price:,.0f}\")\nplt.legend();\n</pre> # Group DataFrame by saleMonth and then find the median SalePrice per state as well as across the whole dataset median_prices_by_state = df_tmp.groupby([\"state\"])[\"SalePrice\"].median() # this will return a pandas Series rather than a DataFrame median_sale_price = df_tmp[\"SalePrice\"].median()  # Create a plot comparing median sale price per state to median sale price overall plt.figure(figsize=(10, 7)) plt.bar(x=median_prices_by_state.index, # Because we're working with a Series, we can use the index (state names) as the x values         height=median_prices_by_state.values) plt.xlabel(\"State\") plt.ylabel(\"Median Sale Price ($)\") plt.xticks(rotation=90, fontsize=7); plt.axhline(y=median_sale_price,              color=\"red\",              linestyle=\"--\",              label=f\"Median Sale Price: ${median_sale_price:,.0f}\") plt.legend(); <p>Now that's a nice looking figure!</p> <p>Interestingly Florida has the most sales and the median sale price is above the overall median of all other states.</p> <p>And if you had a bulldozer and were chasing the highest sale price, the data would reveal that perhaps selling in South Dakota would be your best bet.</p> <p>Perhaps bulldozers are in higher demand in South Dakota because of a building or mining boom?</p> <p>Answering this would require a bit more research.</p> <p>But what we're doing here is slowly building up a mental model of our data.</p> <p>So that if we saw an example in the future, we could compare its values to the ones we've already seen.</p> In\u00a0[29]: Copied! <pre># This won't work since we've got missing numbers and categories\nfrom sklearn.ensemble import RandomForestRegressor\n\nmodel = RandomForestRegressor(n_jobs=-1)\nmodel.fit(X=df_tmp.drop(\"SalePrice\", axis=1), # use all columns except SalePrice as X input\n          y=df_tmp.SalePrice) # use SalePrice column as y input\n</pre> # This won't work since we've got missing numbers and categories from sklearn.ensemble import RandomForestRegressor  model = RandomForestRegressor(n_jobs=-1) model.fit(X=df_tmp.drop(\"SalePrice\", axis=1), # use all columns except SalePrice as X input           y=df_tmp.SalePrice) # use SalePrice column as y input <pre>\n---------------------------------------------------------------------------\nValueError                                Traceback (most recent call last)\n/var/folders/c4/qj4gdk190td18bqvjjh0p3p00000gn/T/ipykernel_20423/2824176890.py in ?()\n      1 # This won't work since we've got missing numbers and categories\n      2 from sklearn.ensemble import RandomForestRegressor\n      3 \n      4 model = RandomForestRegressor(n_jobs=-1)\n----&gt; 5 model.fit(X=df_tmp.drop(\"SalePrice\", axis=1), # use all columns except SalePrice as X input\n      6           y=df_tmp.SalePrice) # use SalePrice column as y input\n\n~/miniforge3/envs/ai/lib/python3.11/site-packages/sklearn/base.py in ?(estimator, *args, **kwargs)\n   1469                 skip_parameter_validation=(\n   1470                     prefer_skip_nested_validation or global_skip_validation\n   1471                 )\n   1472             ):\n-&gt; 1473                 return fit_method(estimator, *args, **kwargs)\n\n~/miniforge3/envs/ai/lib/python3.11/site-packages/sklearn/ensemble/_forest.py in ?(self, X, y, sample_weight)\n    359         # Validate or convert input data\n    360         if issparse(y):\n    361             raise ValueError(\"sparse multilabel-indicator for y is not supported.\")\n    362 \n--&gt; 363         X, y = self._validate_data(\n    364             X,\n    365             y,\n    366             multi_output=True,\n\n~/miniforge3/envs/ai/lib/python3.11/site-packages/sklearn/base.py in ?(self, X, y, reset, validate_separately, cast_to_ndarray, **check_params)\n    646                 if \"estimator\" not in check_y_params:\n    647                     check_y_params = {**default_check_params, **check_y_params}\n    648                 y = check_array(y, input_name=\"y\", **check_y_params)\n    649             else:\n--&gt; 650                 X, y = check_X_y(X, y, **check_params)\n    651             out = X, y\n    652 \n    653         if not no_val_X and check_params.get(\"ensure_2d\", True):\n\n~/miniforge3/envs/ai/lib/python3.11/site-packages/sklearn/utils/validation.py in ?(X, y, accept_sparse, accept_large_sparse, dtype, order, copy, force_writeable, force_all_finite, ensure_2d, allow_nd, multi_output, ensure_min_samples, ensure_min_features, y_numeric, estimator)\n   1297         raise ValueError(\n   1298             f\"{estimator_name} requires y to be passed, but the target y is None\"\n   1299         )\n   1300 \n-&gt; 1301     X = check_array(\n   1302         X,\n   1303         accept_sparse=accept_sparse,\n   1304         accept_large_sparse=accept_large_sparse,\n\n~/miniforge3/envs/ai/lib/python3.11/site-packages/sklearn/utils/validation.py in ?(array, accept_sparse, accept_large_sparse, dtype, order, copy, force_writeable, force_all_finite, ensure_2d, allow_nd, ensure_min_samples, ensure_min_features, estimator, input_name)\n   1009                         )\n   1010                     array = xp.astype(array, dtype, copy=False)\n   1011                 else:\n   1012                     array = _asarray_with_order(array, order=order, dtype=dtype, xp=xp)\n-&gt; 1013             except ComplexWarning as complex_warning:\n   1014                 raise ValueError(\n   1015                     \"Complex data not supported\\n{}\\n\".format(array)\n   1016                 ) from complex_warning\n\n~/miniforge3/envs/ai/lib/python3.11/site-packages/sklearn/utils/_array_api.py in ?(array, dtype, order, copy, xp, device)\n    747         # Use NumPy API to support order\n    748         if copy is True:\n    749             array = numpy.array(array, order=order, dtype=dtype)\n    750         else:\n--&gt; 751             array = numpy.asarray(array, order=order, dtype=dtype)\n    752 \n    753         # At this point array is a NumPy ndarray. We convert it to an array\n    754         # container that is consistent with the input's namespace.\n\n~/miniforge3/envs/ai/lib/python3.11/site-packages/pandas/core/generic.py in ?(self, dtype, copy)\n   2149     def __array__(\n   2150         self, dtype: npt.DTypeLike | None = None, copy: bool_t | None = None\n   2151     ) -&gt; np.ndarray:\n   2152         values = self._values\n-&gt; 2153         arr = np.asarray(values, dtype=dtype)\n   2154         if (\n   2155             astype_is_view(values.dtype, arr.dtype)\n   2156             and using_copy_on_write()\n\nValueError: could not convert string to float: 'Low'</pre> <p>Oh no!</p> <p>When we try to fit our model to the data, we get a value error similar to:</p> <p><code>ValueError: could not convert string to float: 'Low'</code></p> <p>The problem here is that some of the features of our data are in string format and machine learning models love numbers.</p> <p>Not to mention some of our samples have missing values.</p> <p>And typically, machine learning models require all data to be in numerical format as well as all missing values to be filled.</p> <p>Let's start to fix this by inspecting the different datatypes in our DataFrame.</p> <p>We can do so using the <code>pandas.DataFrame.info()</code> method, this will give us the different datatypes as well as how many non-null (a null value is generally a missing value) in our <code>df_tmp</code> DataFrame.</p> <p>Note: There are some ML models such as <code>sklearn.ensemble.HistGradientBoostingRegressor</code>, CatBoost and XGBoost which can handle missing values, however, I'll leave exploring each of these as extra-curriculum/extensions.</p> In\u00a0[30]: Copied! <pre># Check for missing values and different datatypes \ndf_tmp.info();\n</pre> # Check for missing values and different datatypes  df_tmp.info(); <pre>&lt;class 'pandas.core.frame.DataFrame'&gt;\nIndex: 412698 entries, 205615 to 409203\nData columns (total 57 columns):\n #   Column                    Non-Null Count   Dtype  \n---  ------                    --------------   -----  \n 0   SalesID                   412698 non-null  int64  \n 1   SalePrice                 412698 non-null  float64\n 2   MachineID                 412698 non-null  int64  \n 3   ModelID                   412698 non-null  int64  \n 4   datasource                412698 non-null  int64  \n 5   auctioneerID              392562 non-null  float64\n 6   YearMade                  412698 non-null  int64  \n 7   MachineHoursCurrentMeter  147504 non-null  float64\n 8   UsageBand                 73670 non-null   object \n 9   fiModelDesc               412698 non-null  object \n 10  fiBaseModel               412698 non-null  object \n 11  fiSecondaryDesc           271971 non-null  object \n 12  fiModelSeries             58667 non-null   object \n 13  fiModelDescriptor         74816 non-null   object \n 14  ProductSize               196093 non-null  object \n 15  fiProductClassDesc        412698 non-null  object \n 16  state                     412698 non-null  object \n 17  ProductGroup              412698 non-null  object \n 18  ProductGroupDesc          412698 non-null  object \n 19  Drive_System              107087 non-null  object \n 20  Enclosure                 412364 non-null  object \n 21  Forks                     197715 non-null  object \n 22  Pad_Type                  81096 non-null   object \n 23  Ride_Control              152728 non-null  object \n 24  Stick                     81096 non-null   object \n 25  Transmission              188007 non-null  object \n 26  Turbocharged              81096 non-null   object \n 27  Blade_Extension           25983 non-null   object \n 28  Blade_Width               25983 non-null   object \n 29  Enclosure_Type            25983 non-null   object \n 30  Engine_Horsepower         25983 non-null   object \n 31  Hydraulics                330133 non-null  object \n 32  Pushblock                 25983 non-null   object \n 33  Ripper                    106945 non-null  object \n 34  Scarifier                 25994 non-null   object \n 35  Tip_Control               25983 non-null   object \n 36  Tire_Size                 97638 non-null   object \n 37  Coupler                   220679 non-null  object \n 38  Coupler_System            44974 non-null   object \n 39  Grouser_Tracks            44875 non-null   object \n 40  Hydraulics_Flow           44875 non-null   object \n 41  Track_Type                102193 non-null  object \n 42  Undercarriage_Pad_Width   102916 non-null  object \n 43  Stick_Length              102261 non-null  object \n 44  Thumb                     102332 non-null  object \n 45  Pattern_Changer           102261 non-null  object \n 46  Grouser_Type              102193 non-null  object \n 47  Backhoe_Mounting          80712 non-null   object \n 48  Blade_Type                81875 non-null   object \n 49  Travel_Controls           81877 non-null   object \n 50  Differential_Type         71564 non-null   object \n 51  Steering_Controls         71522 non-null   object \n 52  saleYear                  412698 non-null  int32  \n 53  saleMonth                 412698 non-null  int32  \n 54  saleDay                   412698 non-null  int32  \n 55  saleDayofweek             412698 non-null  int32  \n 56  saleDayofyear             412698 non-null  int32  \ndtypes: float64(3), int32(5), int64(5), object(44)\nmemory usage: 174.7+ MB\n</pre> <p>Ok, it seems as though we've got a fair few different datatypes.</p> <p>There are <code>int64</code> types such as <code>MachineID</code>.</p> <p>There are <code>float64</code> types such as <code>SalePrice</code>.</p> <p>And there are <code>object</code> (the <code>object</code> dtype can hold any Python object, including strings) types such as <code>UseageBand</code>.</p> <p>Resource: You can see a list of all the pandas dtypes in the pandas user guide.</p> <p>How about we find out how many missing values are in each column?</p> <p>We can do so using <code>pandas.DataFrame.isna()</code> (<code>isna</code> stands for 'is null or NaN') which will return a boolean <code>True</code>/<code>False</code> if a value is missing (<code>True</code> if missing, <code>False</code> if not).</p> <p>Let's start by checking the missing values in the head of our DataFrame.</p> In\u00a0[31]: Copied! <pre># Find missing values in the head of our DataFrame \ndf_tmp.head().isna()\n</pre> # Find missing values in the head of our DataFrame  df_tmp.head().isna() Out[31]: SalesID SalePrice MachineID ModelID datasource auctioneerID YearMade MachineHoursCurrentMeter UsageBand fiModelDesc ... Backhoe_Mounting Blade_Type Travel_Controls Differential_Type Steering_Controls saleYear saleMonth saleDay saleDayofweek saleDayofyear 205615 False False False False False False False True True False ... False False False True True False False False False False 274835 False False False False False False False True True False ... True True True False False False False False False False 141296 False False False False False False False True True False ... False False False True True False False False False False 212552 False False False False False False False True True False ... True True True False False False False False False False 62755 False False False False False False False True True False ... False False False True True False False False False False <p>5 rows \u00d7 57 columns</p> <p>Alright it seems as though we've got some missing values in the <code>MachineHoursCurrentMeter</code> as well as the <code>UsageBand</code> and a few other columns.</p> <p>But so far we've only viewed the first few rows.</p> <p>It'll be very time consuming to go through each row one by one so how about we get the total missing values per column?</p> <p>We can do so by calling <code>.isna()</code> on the whole DataFrame and then chaining it together with <code>.sum()</code>.</p> <p>Doing so will give us the total <code>True</code>/<code>False</code> values in a given column (when summing, <code>True</code> = 1, <code>False</code> = 0).</p> In\u00a0[32]: Copied! <pre># Check for total missing values per column\ndf_tmp.isna().sum()\n</pre> # Check for total missing values per column df_tmp.isna().sum() Out[32]: <pre>SalesID                          0\nSalePrice                        0\nMachineID                        0\nModelID                          0\ndatasource                       0\nauctioneerID                 20136\nYearMade                         0\nMachineHoursCurrentMeter    265194\nUsageBand                   339028\nfiModelDesc                      0\nfiBaseModel                      0\nfiSecondaryDesc             140727\nfiModelSeries               354031\nfiModelDescriptor           337882\nProductSize                 216605\nfiProductClassDesc               0\nstate                            0\nProductGroup                     0\nProductGroupDesc                 0\nDrive_System                305611\nEnclosure                      334\nForks                       214983\nPad_Type                    331602\nRide_Control                259970\nStick                       331602\nTransmission                224691\nTurbocharged                331602\nBlade_Extension             386715\nBlade_Width                 386715\nEnclosure_Type              386715\nEngine_Horsepower           386715\nHydraulics                   82565\nPushblock                   386715\nRipper                      305753\nScarifier                   386704\nTip_Control                 386715\nTire_Size                   315060\nCoupler                     192019\nCoupler_System              367724\nGrouser_Tracks              367823\nHydraulics_Flow             367823\nTrack_Type                  310505\nUndercarriage_Pad_Width     309782\nStick_Length                310437\nThumb                       310366\nPattern_Changer             310437\nGrouser_Type                310505\nBackhoe_Mounting            331986\nBlade_Type                  330823\nTravel_Controls             330821\nDifferential_Type           341134\nSteering_Controls           341176\nsaleYear                         0\nsaleMonth                        0\nsaleDay                          0\nsaleDayofweek                    0\nsaleDayofyear                    0\ndtype: int64</pre> <p>Woah! It looks like our DataFrame has quite a few missing values.</p> <p>Not to worry, we can work on fixing this later on.</p> <p>How about we start by tring to turn all of our data in numbers?</p> In\u00a0[33]: Copied! <pre># Get the dtype of a given column\ndf_tmp[\"UsageBand\"].dtype, df_tmp[\"UsageBand\"].dtype.name\n</pre> # Get the dtype of a given column df_tmp[\"UsageBand\"].dtype, df_tmp[\"UsageBand\"].dtype.name Out[33]: <pre>(dtype('O'), 'object')</pre> <p>Beautiful!</p> <p>Now we've got a way to check a column's datatype individually.</p> <p>There's also another group of methods to check a column's datatype directly.</p> <p>For example, using <code>pd.api.types.is_object_dtype(arr_or_dtype)</code> we can get a boolean response as to whether the input is an object or not.</p> <p>Note: There are many more of these checks you can perform for other datatypes such as strings under a similar name space <code>pd.api.types.is_XYZ_dtype</code>. See the pandas documentation for more.</p> <p>Let's see how it works on our <code>df_tmp[\"UsageBand\"]</code> column.</p> In\u00a0[34]: Copied! <pre># Check whether a column is an object\npd.api.types.is_object_dtype(df_tmp[\"UsageBand\"])\n</pre> # Check whether a column is an object pd.api.types.is_object_dtype(df_tmp[\"UsageBand\"]) Out[34]: <pre>True</pre> <p>We can also check whether a column is a string with <code>pd.api.types.is_string_dtype(arr_or_dtype)</code>.</p> In\u00a0[35]: Copied! <pre># Check whether a column is a string\npd.api.types.is_string_dtype(df_tmp[\"state\"])\n</pre> # Check whether a column is a string pd.api.types.is_string_dtype(df_tmp[\"state\"]) Out[35]: <pre>True</pre> <p>Nice!</p> <p>We can even loop through the items (columns and their labels) in our DataFrame using <code>pandas.DataFrame.items()</code> (in Python dictionary terms, calling <code>.items()</code> on a DataFrame will treat the column names as the keys and the column values as the values) and print out samples of columns which have the <code>string</code> datatype.</p> <p>As an extra check, passing the sample to <code>pd.api.types.infer_dtype()</code> will return the datatype of the sample.</p> <p>This will be a good way to keep exploring our data.</p> In\u00a0[36]: Copied! <pre># Quick exampke of calling .items() on a dictionary\nrandom_dict = {\"key1\": \"hello\",\n               \"key2\": \"world!\"}\n\nfor key, value in random_dict.items():\n    print(f\"This is a key: {key}\")\n    print(f\"This is a value: {value}\")\n</pre> # Quick exampke of calling .items() on a dictionary random_dict = {\"key1\": \"hello\",                \"key2\": \"world!\"}  for key, value in random_dict.items():     print(f\"This is a key: {key}\")     print(f\"This is a value: {value}\") <pre>This is a key: key1\nThis is a value: hello\nThis is a key: key2\nThis is a value: world!\n</pre> In\u00a0[37]: Copied! <pre># Print column names and example content of columns which contain strings\nfor label, content in df_tmp.items():\n    if pd.api.types.is_string_dtype(content):\n        # Check datatype of target column\n        column_datatype = df_tmp[label].dtype.name\n\n        # Get random sample from column values\n        example_value = content.sample(1).values\n\n        # Infer random sample datatype\n        example_value_dtype = pd.api.types.infer_dtype(example_value)\n        print(f\"Column name: {label} | Column dtype: {column_datatype} | Example value: {example_value} | Example value dtype: {example_value_dtype}\")\n</pre> # Print column names and example content of columns which contain strings for label, content in df_tmp.items():     if pd.api.types.is_string_dtype(content):         # Check datatype of target column         column_datatype = df_tmp[label].dtype.name          # Get random sample from column values         example_value = content.sample(1).values          # Infer random sample datatype         example_value_dtype = pd.api.types.infer_dtype(example_value)         print(f\"Column name: {label} | Column dtype: {column_datatype} | Example value: {example_value} | Example value dtype: {example_value_dtype}\") <pre>Column name: fiModelDesc | Column dtype: object | Example value: ['35ZTS'] | Example value dtype: string\nColumn name: fiBaseModel | Column dtype: object | Example value: ['PC75'] | Example value dtype: string\nColumn name: fiProductClassDesc | Column dtype: object | Example value: ['Backhoe Loader - 14.0 to 15.0 Ft Standard Digging Depth'] | Example value dtype: string\nColumn name: state | Column dtype: object | Example value: ['Florida'] | Example value dtype: string\nColumn name: ProductGroup | Column dtype: object | Example value: ['TTT'] | Example value dtype: string\nColumn name: ProductGroupDesc | Column dtype: object | Example value: ['Track Excavators'] | Example value dtype: string\n</pre> <p>Hmm... it seems that there are many more columns in the <code>df_tmp</code> with the <code>object</code> type that didn't display when checking for the string datatype (we know there are many <code>object</code> datatype columns in our DataFrame from using <code>df_tmp.info()</code>).</p> <p>How about we try the same as above, except this time instead of <code>pd.api.types.is_string_dtype</code>, we use <code>pd.api.types.is_object_dtype</code>?</p> <p>Let's try it.</p> In\u00a0[38]: Copied! <pre># Start a count of how many object type columns there are\nnumber_of_object_type_columns = 0\n\nfor label, content in df_tmp.items():\n    # Check to see if column is of object type (this will include the string columns)\n    if pd.api.types.is_object_dtype(content): \n        # Check datatype of target column\n        column_datatype = df_tmp[label].dtype.name\n\n        # Get random sample from column values\n        example_value = content.sample(1).values\n\n        # Infer random sample datatype\n        example_value_dtype = pd.api.types.infer_dtype(example_value)\n        print(f\"Column name: {label} | Column dtype: {column_datatype} | Example value: {example_value} | Example value dtype: {example_value_dtype}\")\n\n        number_of_object_type_columns += 1\n\nprint(f\"\\n[INFO] Total number of object type columns: {number_of_object_type_columns}\")\n</pre> # Start a count of how many object type columns there are number_of_object_type_columns = 0  for label, content in df_tmp.items():     # Check to see if column is of object type (this will include the string columns)     if pd.api.types.is_object_dtype(content):          # Check datatype of target column         column_datatype = df_tmp[label].dtype.name          # Get random sample from column values         example_value = content.sample(1).values          # Infer random sample datatype         example_value_dtype = pd.api.types.infer_dtype(example_value)         print(f\"Column name: {label} | Column dtype: {column_datatype} | Example value: {example_value} | Example value dtype: {example_value_dtype}\")          number_of_object_type_columns += 1  print(f\"\\n[INFO] Total number of object type columns: {number_of_object_type_columns}\") <pre>Column name: UsageBand | Column dtype: object | Example value: [nan] | Example value dtype: empty\nColumn name: fiModelDesc | Column dtype: object | Example value: ['590SUPER MII'] | Example value dtype: string\nColumn name: fiBaseModel | Column dtype: object | Example value: ['580'] | Example value dtype: string\nColumn name: fiSecondaryDesc | Column dtype: object | Example value: [nan] | Example value dtype: empty\nColumn name: fiModelSeries | Column dtype: object | Example value: [nan] | Example value dtype: empty\nColumn name: fiModelDescriptor | Column dtype: object | Example value: ['H'] | Example value dtype: string\nColumn name: ProductSize | Column dtype: object | Example value: [nan] | Example value dtype: empty\nColumn name: fiProductClassDesc | Column dtype: object | Example value: ['Track Type Tractor, Dozer - 75.0 to 85.0 Horsepower'] | Example value dtype: string\nColumn name: state | Column dtype: object | Example value: ['Florida'] | Example value dtype: string\nColumn name: ProductGroup | Column dtype: object | Example value: ['TEX'] | Example value dtype: string\nColumn name: ProductGroupDesc | Column dtype: object | Example value: ['Skid Steer Loaders'] | Example value dtype: string\nColumn name: Drive_System | Column dtype: object | Example value: [nan] | Example value dtype: empty\nColumn name: Enclosure | Column dtype: object | Example value: ['EROPS'] | Example value dtype: string\nColumn name: Forks | Column dtype: object | Example value: [nan] | Example value dtype: empty\nColumn name: Pad_Type | Column dtype: object | Example value: ['None or Unspecified'] | Example value dtype: string\nColumn name: Ride_Control | Column dtype: object | Example value: [nan] | Example value dtype: empty\nColumn name: Stick | Column dtype: object | Example value: ['Extended'] | Example value dtype: string\nColumn name: Transmission | Column dtype: object | Example value: [nan] | Example value dtype: empty\nColumn name: Turbocharged | Column dtype: object | Example value: ['None or Unspecified'] | Example value dtype: string\nColumn name: Blade_Extension | Column dtype: object | Example value: [nan] | Example value dtype: empty\nColumn name: Blade_Width | Column dtype: object | Example value: [nan] | Example value dtype: empty\nColumn name: Enclosure_Type | Column dtype: object | Example value: [nan] | Example value dtype: empty\nColumn name: Engine_Horsepower | Column dtype: object | Example value: [nan] | Example value dtype: empty\nColumn name: Hydraulics | Column dtype: object | Example value: ['Standard'] | Example value dtype: string\nColumn name: Pushblock | Column dtype: object | Example value: [nan] | Example value dtype: empty\nColumn name: Ripper | Column dtype: object | Example value: [nan] | Example value dtype: empty\nColumn name: Scarifier | Column dtype: object | Example value: [nan] | Example value dtype: empty\nColumn name: Tip_Control | Column dtype: object | Example value: [nan] | Example value dtype: empty\nColumn name: Tire_Size | Column dtype: object | Example value: [nan] | Example value dtype: empty\nColumn name: Coupler | Column dtype: object | Example value: [nan] | Example value dtype: empty\nColumn name: Coupler_System | Column dtype: object | Example value: [nan] | Example value dtype: empty\nColumn name: Grouser_Tracks | Column dtype: object | Example value: ['None or Unspecified'] | Example value dtype: string\nColumn name: Hydraulics_Flow | Column dtype: object | Example value: [nan] | Example value dtype: empty\nColumn name: Track_Type | Column dtype: object | Example value: [nan] | Example value dtype: empty\nColumn name: Undercarriage_Pad_Width | Column dtype: object | Example value: ['20 inch'] | Example value dtype: string\nColumn name: Stick_Length | Column dtype: object | Example value: [nan] | Example value dtype: empty\nColumn name: Thumb | Column dtype: object | Example value: ['None or Unspecified'] | Example value dtype: string\nColumn name: Pattern_Changer | Column dtype: object | Example value: ['None or Unspecified'] | Example value dtype: string\nColumn name: Grouser_Type | Column dtype: object | Example value: [nan] | Example value dtype: empty\nColumn name: Backhoe_Mounting | Column dtype: object | Example value: [nan] | Example value dtype: empty\nColumn name: Blade_Type | Column dtype: object | Example value: ['Straight'] | Example value dtype: string\nColumn name: Travel_Controls | Column dtype: object | Example value: ['None or Unspecified'] | Example value dtype: string\nColumn name: Differential_Type | Column dtype: object | Example value: [nan] | Example value dtype: empty\nColumn name: Steering_Controls | Column dtype: object | Example value: [nan] | Example value dtype: empty\n\n[INFO] Total number of object type columns: 44\n</pre> <p>Wonderful, looks like we've got sample outputs from all of the columns with the <code>object</code> datatype.</p> <p>It also looks like that many of random samples are missing values.</p> In\u00a0[39]: Copied! <pre># This will turn all of the object columns into category values\nfor label, content in df_tmp.items(): \n    if pd.api.types.is_object_dtype(content):\n        df_tmp[label] = df_tmp[label].astype(\"category\")\n</pre> # This will turn all of the object columns into category values for label, content in df_tmp.items():      if pd.api.types.is_object_dtype(content):         df_tmp[label] = df_tmp[label].astype(\"category\") <p>Wonderful!</p> <p>Now let's check if it worked by calling <code>.info()</code> on our DataFrame.</p> In\u00a0[40]: Copied! <pre>df_tmp.info()\n</pre> df_tmp.info() <pre>&lt;class 'pandas.core.frame.DataFrame'&gt;\nIndex: 412698 entries, 205615 to 409203\nData columns (total 57 columns):\n #   Column                    Non-Null Count   Dtype   \n---  ------                    --------------   -----   \n 0   SalesID                   412698 non-null  int64   \n 1   SalePrice                 412698 non-null  float64 \n 2   MachineID                 412698 non-null  int64   \n 3   ModelID                   412698 non-null  int64   \n 4   datasource                412698 non-null  int64   \n 5   auctioneerID              392562 non-null  float64 \n 6   YearMade                  412698 non-null  int64   \n 7   MachineHoursCurrentMeter  147504 non-null  float64 \n 8   UsageBand                 73670 non-null   category\n 9   fiModelDesc               412698 non-null  category\n 10  fiBaseModel               412698 non-null  category\n 11  fiSecondaryDesc           271971 non-null  category\n 12  fiModelSeries             58667 non-null   category\n 13  fiModelDescriptor         74816 non-null   category\n 14  ProductSize               196093 non-null  category\n 15  fiProductClassDesc        412698 non-null  category\n 16  state                     412698 non-null  category\n 17  ProductGroup              412698 non-null  category\n 18  ProductGroupDesc          412698 non-null  category\n 19  Drive_System              107087 non-null  category\n 20  Enclosure                 412364 non-null  category\n 21  Forks                     197715 non-null  category\n 22  Pad_Type                  81096 non-null   category\n 23  Ride_Control              152728 non-null  category\n 24  Stick                     81096 non-null   category\n 25  Transmission              188007 non-null  category\n 26  Turbocharged              81096 non-null   category\n 27  Blade_Extension           25983 non-null   category\n 28  Blade_Width               25983 non-null   category\n 29  Enclosure_Type            25983 non-null   category\n 30  Engine_Horsepower         25983 non-null   category\n 31  Hydraulics                330133 non-null  category\n 32  Pushblock                 25983 non-null   category\n 33  Ripper                    106945 non-null  category\n 34  Scarifier                 25994 non-null   category\n 35  Tip_Control               25983 non-null   category\n 36  Tire_Size                 97638 non-null   category\n 37  Coupler                   220679 non-null  category\n 38  Coupler_System            44974 non-null   category\n 39  Grouser_Tracks            44875 non-null   category\n 40  Hydraulics_Flow           44875 non-null   category\n 41  Track_Type                102193 non-null  category\n 42  Undercarriage_Pad_Width   102916 non-null  category\n 43  Stick_Length              102261 non-null  category\n 44  Thumb                     102332 non-null  category\n 45  Pattern_Changer           102261 non-null  category\n 46  Grouser_Type              102193 non-null  category\n 47  Backhoe_Mounting          80712 non-null   category\n 48  Blade_Type                81875 non-null   category\n 49  Travel_Controls           81877 non-null   category\n 50  Differential_Type         71564 non-null   category\n 51  Steering_Controls         71522 non-null   category\n 52  saleYear                  412698 non-null  int32   \n 53  saleMonth                 412698 non-null  int32   \n 54  saleDay                   412698 non-null  int32   \n 55  saleDayofweek             412698 non-null  int32   \n 56  saleDayofyear             412698 non-null  int32   \ndtypes: category(44), float64(3), int32(5), int64(5)\nmemory usage: 55.4 MB\n</pre> <p>It looks like it worked!</p> <p>All of the object datatype columns now have the category datatype.</p> <p>We can inspect this on a single column using <code>pandas.Series.dtype</code>.</p> In\u00a0[41]: Copied! <pre># Check the datatype of a single column\ndf_tmp.state.dtype\n</pre> # Check the datatype of a single column df_tmp.state.dtype Out[41]: <pre>CategoricalDtype(categories=['Alabama', 'Alaska', 'Arizona', 'Arkansas', 'California',\n                  'Colorado', 'Connecticut', 'Delaware', 'Florida', 'Georgia',\n                  'Hawaii', 'Idaho', 'Illinois', 'Indiana', 'Iowa', 'Kansas',\n                  'Kentucky', 'Louisiana', 'Maine', 'Maryland',\n                  'Massachusetts', 'Michigan', 'Minnesota', 'Mississippi',\n                  'Missouri', 'Montana', 'Nebraska', 'Nevada', 'New Hampshire',\n                  'New Jersey', 'New Mexico', 'New York', 'North Carolina',\n                  'North Dakota', 'Ohio', 'Oklahoma', 'Oregon', 'Pennsylvania',\n                  'Puerto Rico', 'Rhode Island', 'South Carolina',\n                  'South Dakota', 'Tennessee', 'Texas', 'Unspecified', 'Utah',\n                  'Vermont', 'Virginia', 'Washington', 'Washington DC',\n                  'West Virginia', 'Wisconsin', 'Wyoming'],\n, ordered=False, categories_dtype=object)</pre> <p>Excellent, notice how the column is now of type <code>pd.CategoricalDtype</code>.</p> <p>We can also access these categories using <code>pandas.Series.cat.categories</code>.</p> In\u00a0[42]: Copied! <pre># Get the category names of a given column\ndf_tmp.state.cat.categories\n</pre> # Get the category names of a given column df_tmp.state.cat.categories Out[42]: <pre>Index(['Alabama', 'Alaska', 'Arizona', 'Arkansas', 'California', 'Colorado',\n       'Connecticut', 'Delaware', 'Florida', 'Georgia', 'Hawaii', 'Idaho',\n       'Illinois', 'Indiana', 'Iowa', 'Kansas', 'Kentucky', 'Louisiana',\n       'Maine', 'Maryland', 'Massachusetts', 'Michigan', 'Minnesota',\n       'Mississippi', 'Missouri', 'Montana', 'Nebraska', 'Nevada',\n       'New Hampshire', 'New Jersey', 'New Mexico', 'New York',\n       'North Carolina', 'North Dakota', 'Ohio', 'Oklahoma', 'Oregon',\n       'Pennsylvania', 'Puerto Rico', 'Rhode Island', 'South Carolina',\n       'South Dakota', 'Tennessee', 'Texas', 'Unspecified', 'Utah', 'Vermont',\n       'Virginia', 'Washington', 'Washington DC', 'West Virginia', 'Wisconsin',\n       'Wyoming'],\n      dtype='object')</pre> <p>Finally, we can get the category codes (the numeric values representing the category) using <code>pandas.Series.cat.codes</code>.</p> In\u00a0[43]: Copied! <pre># Inspect the category codes\ndf_tmp.state.cat.codes\n</pre> # Inspect the category codes df_tmp.state.cat.codes Out[43]: <pre>205615    43\n274835     8\n141296     8\n212552     8\n62755      8\n          ..\n410879     4\n412476     4\n411927     4\n407124     4\n409203     4\nLength: 412698, dtype: int8</pre> <p>This gives us a numeric representation of our object/string datatype columns.</p> In\u00a0[44]: Copied! <pre># Get example string using category number\ntarget_state_cat_number = 43\ntarget_state_cat_value = df_tmp.state.cat.categories[target_state_cat_number] \nprint(f\"[INFO] Target state category number {target_state_cat_number} maps to: {target_state_cat_value}\")\n</pre> # Get example string using category number target_state_cat_number = 43 target_state_cat_value = df_tmp.state.cat.categories[target_state_cat_number]  print(f\"[INFO] Target state category number {target_state_cat_number} maps to: {target_state_cat_value}\") <pre>[INFO] Target state category number 43 maps to: Texas\n</pre> <p>Epic!</p> <p>All of our data is categorical and thus we can now turn the categories into numbers, however it's still missing values, not to worry though, we'll get to these shortly.</p> In\u00a0[45]: Copied! <pre># Save preprocessed data to file\ndf_tmp.to_csv(\"../data/bluebook-for-bulldozers/TrainAndValid_object_values_as_categories.csv\",\n              index=False)\n</pre> # Save preprocessed data to file df_tmp.to_csv(\"../data/bluebook-for-bulldozers/TrainAndValid_object_values_as_categories.csv\",               index=False) <p>Now we've saved our preprocessed data to file, we can re-import it and make sure it's in the same format.</p> In\u00a0[46]: Copied! <pre># Import preprocessed data to file\ndf_tmp = pd.read_csv(\"../data/bluebook-for-bulldozers/TrainAndValid_object_values_as_categories.csv\",\n                     low_memory=False)\n\ndf_tmp.head()\n</pre> # Import preprocessed data to file df_tmp = pd.read_csv(\"../data/bluebook-for-bulldozers/TrainAndValid_object_values_as_categories.csv\",                      low_memory=False)  df_tmp.head() Out[46]: SalesID SalePrice MachineID ModelID datasource auctioneerID YearMade MachineHoursCurrentMeter UsageBand fiModelDesc ... Backhoe_Mounting Blade_Type Travel_Controls Differential_Type Steering_Controls saleYear saleMonth saleDay saleDayofweek saleDayofyear 0 1646770 9500.0 1126363 8434 132 18.0 1974 NaN NaN TD20 ... None or Unspecified Straight None or Unspecified NaN NaN 1989 1 17 1 17 1 1821514 14000.0 1194089 10150 132 99.0 1980 NaN NaN A66 ... NaN NaN NaN Standard Conventional 1989 1 31 1 31 2 1505138 50000.0 1473654 4139 132 99.0 1978 NaN NaN D7G ... None or Unspecified Straight None or Unspecified NaN NaN 1989 1 31 1 31 3 1671174 16000.0 1327630 8591 132 99.0 1980 NaN NaN A62 ... NaN NaN NaN Standard Conventional 1989 1 31 1 31 4 1329056 22000.0 1336053 4089 132 99.0 1984 NaN NaN D3B ... None or Unspecified PAT Lever NaN NaN 1989 1 31 1 31 <p>5 rows \u00d7 57 columns</p> <p>Excellent, looking at the tale end (the far right side) our processed DataFrame has the columns we added to it (the extra data features) but it's still missing values.</p> <p>But if we check <code>df_tmp.info()</code>...</p> In\u00a0[47]: Copied! <pre>df_tmp.info()\n</pre> df_tmp.info() <pre>&lt;class 'pandas.core.frame.DataFrame'&gt;\nRangeIndex: 412698 entries, 0 to 412697\nData columns (total 57 columns):\n #   Column                    Non-Null Count   Dtype  \n---  ------                    --------------   -----  \n 0   SalesID                   412698 non-null  int64  \n 1   SalePrice                 412698 non-null  float64\n 2   MachineID                 412698 non-null  int64  \n 3   ModelID                   412698 non-null  int64  \n 4   datasource                412698 non-null  int64  \n 5   auctioneerID              392562 non-null  float64\n 6   YearMade                  412698 non-null  int64  \n 7   MachineHoursCurrentMeter  147504 non-null  float64\n 8   UsageBand                 73670 non-null   object \n 9   fiModelDesc               412698 non-null  object \n 10  fiBaseModel               412698 non-null  object \n 11  fiSecondaryDesc           271971 non-null  object \n 12  fiModelSeries             58667 non-null   object \n 13  fiModelDescriptor         74816 non-null   object \n 14  ProductSize               196093 non-null  object \n 15  fiProductClassDesc        412698 non-null  object \n 16  state                     412698 non-null  object \n 17  ProductGroup              412698 non-null  object \n 18  ProductGroupDesc          412698 non-null  object \n 19  Drive_System              107087 non-null  object \n 20  Enclosure                 412364 non-null  object \n 21  Forks                     197715 non-null  object \n 22  Pad_Type                  81096 non-null   object \n 23  Ride_Control              152728 non-null  object \n 24  Stick                     81096 non-null   object \n 25  Transmission              188007 non-null  object \n 26  Turbocharged              81096 non-null   object \n 27  Blade_Extension           25983 non-null   object \n 28  Blade_Width               25983 non-null   object \n 29  Enclosure_Type            25983 non-null   object \n 30  Engine_Horsepower         25983 non-null   object \n 31  Hydraulics                330133 non-null  object \n 32  Pushblock                 25983 non-null   object \n 33  Ripper                    106945 non-null  object \n 34  Scarifier                 25994 non-null   object \n 35  Tip_Control               25983 non-null   object \n 36  Tire_Size                 97638 non-null   object \n 37  Coupler                   220679 non-null  object \n 38  Coupler_System            44974 non-null   object \n 39  Grouser_Tracks            44875 non-null   object \n 40  Hydraulics_Flow           44875 non-null   object \n 41  Track_Type                102193 non-null  object \n 42  Undercarriage_Pad_Width   102916 non-null  object \n 43  Stick_Length              102261 non-null  object \n 44  Thumb                     102332 non-null  object \n 45  Pattern_Changer           102261 non-null  object \n 46  Grouser_Type              102193 non-null  object \n 47  Backhoe_Mounting          80712 non-null   object \n 48  Blade_Type                81875 non-null   object \n 49  Travel_Controls           81877 non-null   object \n 50  Differential_Type         71564 non-null   object \n 51  Steering_Controls         71522 non-null   object \n 52  saleYear                  412698 non-null  int64  \n 53  saleMonth                 412698 non-null  int64  \n 54  saleDay                   412698 non-null  int64  \n 55  saleDayofweek             412698 non-null  int64  \n 56  saleDayofyear             412698 non-null  int64  \ndtypes: float64(3), int64(10), object(44)\nmemory usage: 179.5+ MB\n</pre> <p>Hmm... what happened here?</p> <p>Notice that all of the <code>category</code> datatype columns are back to the <code>object</code> datatype.</p> <p>This is strange since we already converted the <code>object</code> datatype columns to <code>category</code>.</p> <p>Well then why did they change back?</p> <p>This happens because of the limitations of the CSV (<code>.csv</code>) file format, it doesn't preserve data types, rather it stores all the values as strings.</p> <p>So when we read in a CSV, pandas defaults to interpreting strings as <code>object</code> datatypes.</p> <p>Not to worry though, we can easily convert them to the <code>category</code> datatype as we did before.</p> <p>Note: If you'd like to retain the datatypes when saving your data, you can use file formats such as <code>parquet</code> (Apache Parquet) and <code>feather</code>. These filetypes have several advantages over CSV in terms of processing speeds and storage size. However, data stored in these formats is not human-readable so you won't be able to open the files and inspect them without specific tools. For more on different file formats in pandas, see the IO tools documentation page.</p> In\u00a0[48]: Copied! <pre>for label, content in df_tmp.items():\n    if pd.api.types.is_object_dtype(content):\n        # Turn object columns into category datatype\n        df_tmp[label] = df_tmp[label].astype(\"category\")\n</pre> for label, content in df_tmp.items():     if pd.api.types.is_object_dtype(content):         # Turn object columns into category datatype         df_tmp[label] = df_tmp[label].astype(\"category\") <p>Now if we wanted to preserve the datatypes of our data, we can save to <code>parquet</code> or <code>feather</code> format.</p> <p>Let's try using <code>parquet</code> format.</p> <p>To do so, we can use the <code>pandas.DataFrame.to_parquet()</code> method.</p> <p>Files in the <code>parquet</code> format typically have the file extension of <code>.parquet</code>.</p> In\u00a0[49]: Copied! <pre># To save to parquet format requires pyarrow or fastparquet (or both)\n# Can install via `pip install pyarrow fastparquet`\ndf_tmp.to_parquet(path=\"../data/bluebook-for-bulldozers/TrainAndValid_object_values_as_categories.parquet\", \n                  engine=\"auto\") # \"auto\" will automatically use pyarrow or fastparquet, defaulting to pyarrow first\n</pre> # To save to parquet format requires pyarrow or fastparquet (or both) # Can install via `pip install pyarrow fastparquet` df_tmp.to_parquet(path=\"../data/bluebook-for-bulldozers/TrainAndValid_object_values_as_categories.parquet\",                    engine=\"auto\") # \"auto\" will automatically use pyarrow or fastparquet, defaulting to pyarrow first <p>Wonderful! Now let's try importing our DataFrame from the <code>parquet</code> format and check it using <code>df_tmp.info()</code>.</p> In\u00a0[50]: Copied! <pre># Read in df_tmp from parquet format\ndf_tmp = pd.read_parquet(path=\"../data/bluebook-for-bulldozers/TrainAndValid_object_values_as_categories.parquet\",\n                         engine=\"auto\")\n\n# Using parquet format, datatypes are preserved\ndf_tmp.info()\n</pre> # Read in df_tmp from parquet format df_tmp = pd.read_parquet(path=\"../data/bluebook-for-bulldozers/TrainAndValid_object_values_as_categories.parquet\",                          engine=\"auto\")  # Using parquet format, datatypes are preserved df_tmp.info() <pre>&lt;class 'pandas.core.frame.DataFrame'&gt;\nRangeIndex: 412698 entries, 0 to 412697\nData columns (total 57 columns):\n #   Column                    Non-Null Count   Dtype   \n---  ------                    --------------   -----   \n 0   SalesID                   412698 non-null  int64   \n 1   SalePrice                 412698 non-null  float64 \n 2   MachineID                 412698 non-null  int64   \n 3   ModelID                   412698 non-null  int64   \n 4   datasource                412698 non-null  int64   \n 5   auctioneerID              392562 non-null  float64 \n 6   YearMade                  412698 non-null  int64   \n 7   MachineHoursCurrentMeter  147504 non-null  float64 \n 8   UsageBand                 73670 non-null   category\n 9   fiModelDesc               412698 non-null  category\n 10  fiBaseModel               412698 non-null  category\n 11  fiSecondaryDesc           271971 non-null  category\n 12  fiModelSeries             58667 non-null   category\n 13  fiModelDescriptor         74816 non-null   category\n 14  ProductSize               196093 non-null  category\n 15  fiProductClassDesc        412698 non-null  category\n 16  state                     412698 non-null  category\n 17  ProductGroup              412698 non-null  category\n 18  ProductGroupDesc          412698 non-null  category\n 19  Drive_System              107087 non-null  category\n 20  Enclosure                 412364 non-null  category\n 21  Forks                     197715 non-null  category\n 22  Pad_Type                  81096 non-null   category\n 23  Ride_Control              152728 non-null  category\n 24  Stick                     81096 non-null   category\n 25  Transmission              188007 non-null  category\n 26  Turbocharged              81096 non-null   category\n 27  Blade_Extension           25983 non-null   category\n 28  Blade_Width               25983 non-null   category\n 29  Enclosure_Type            25983 non-null   category\n 30  Engine_Horsepower         25983 non-null   category\n 31  Hydraulics                330133 non-null  category\n 32  Pushblock                 25983 non-null   category\n 33  Ripper                    106945 non-null  category\n 34  Scarifier                 25994 non-null   category\n 35  Tip_Control               25983 non-null   category\n 36  Tire_Size                 97638 non-null   category\n 37  Coupler                   220679 non-null  category\n 38  Coupler_System            44974 non-null   category\n 39  Grouser_Tracks            44875 non-null   category\n 40  Hydraulics_Flow           44875 non-null   category\n 41  Track_Type                102193 non-null  category\n 42  Undercarriage_Pad_Width   102916 non-null  category\n 43  Stick_Length              102261 non-null  category\n 44  Thumb                     102332 non-null  category\n 45  Pattern_Changer           102261 non-null  category\n 46  Grouser_Type              102193 non-null  category\n 47  Backhoe_Mounting          80712 non-null   category\n 48  Blade_Type                81875 non-null   category\n 49  Travel_Controls           81877 non-null   category\n 50  Differential_Type         71564 non-null   category\n 51  Steering_Controls         71522 non-null   category\n 52  saleYear                  412698 non-null  int64   \n 53  saleMonth                 412698 non-null  int64   \n 54  saleDay                   412698 non-null  int64   \n 55  saleDayofweek             412698 non-null  int64   \n 56  saleDayofyear             412698 non-null  int64   \ndtypes: category(44), float64(3), int64(10)\nmemory usage: 60.1 MB\n</pre> <p>Nice! Looks like using the <code>parquet</code> format preserved all of our datatypes.</p> <p>For more on the <code>parquet</code> and <code>feather</code> formats, be sure to check out the pandas IO (input/output) documentation.</p> In\u00a0[51]: Copied! <pre># Check missing values\ndf_tmp.isna().sum().sort_values(ascending=False)[:20]\n</pre> # Check missing values df_tmp.isna().sum().sort_values(ascending=False)[:20] Out[51]: <pre>Blade_Width          386715\nEngine_Horsepower    386715\nTip_Control          386715\nPushblock            386715\nBlade_Extension      386715\nEnclosure_Type       386715\nScarifier            386704\nHydraulics_Flow      367823\nGrouser_Tracks       367823\nCoupler_System       367724\nfiModelSeries        354031\nSteering_Controls    341176\nDifferential_Type    341134\nUsageBand            339028\nfiModelDescriptor    337882\nBackhoe_Mounting     331986\nStick                331602\nTurbocharged         331602\nPad_Type             331602\nBlade_Type           330823\ndtype: int64</pre> <p>Ok, it seems like there are a fair few columns with missing values and there are several datatypes across these columns (numerical, categorical).</p> <p>How about we break the problem down and work on filling each datatype separately?</p> In\u00a0[52]: Copied! <pre># Find numeric columns \nfor label, content in df_tmp.items():\n    if pd.api.types.is_numeric_dtype(content):\n        # Check datatype of target column\n        column_datatype = df_tmp[label].dtype.name\n\n        # Get random sample from column values\n        example_value = content.sample(1).values\n\n        # Infer random sample datatype\n        example_value_dtype = pd.api.types.infer_dtype(example_value)\n        print(f\"Column name: {label} | Column dtype: {column_datatype} | Example value: {example_value} | Example value dtype: {example_value_dtype}\")\n</pre> # Find numeric columns  for label, content in df_tmp.items():     if pd.api.types.is_numeric_dtype(content):         # Check datatype of target column         column_datatype = df_tmp[label].dtype.name          # Get random sample from column values         example_value = content.sample(1).values          # Infer random sample datatype         example_value_dtype = pd.api.types.infer_dtype(example_value)         print(f\"Column name: {label} | Column dtype: {column_datatype} | Example value: {example_value} | Example value dtype: {example_value_dtype}\") <pre>Column name: SalesID | Column dtype: int64 | Example value: [1748586] | Example value dtype: integer\nColumn name: SalePrice | Column dtype: float64 | Example value: [13000.] | Example value dtype: floating\nColumn name: MachineID | Column dtype: int64 | Example value: [1441940] | Example value dtype: integer\nColumn name: ModelID | Column dtype: int64 | Example value: [1333] | Example value dtype: integer\nColumn name: datasource | Column dtype: int64 | Example value: [132] | Example value dtype: integer\nColumn name: auctioneerID | Column dtype: float64 | Example value: [2.] | Example value dtype: floating\nColumn name: YearMade | Column dtype: int64 | Example value: [1000] | Example value dtype: integer\nColumn name: MachineHoursCurrentMeter | Column dtype: float64 | Example value: [nan] | Example value dtype: floating\nColumn name: saleYear | Column dtype: int64 | Example value: [2010] | Example value dtype: integer\nColumn name: saleMonth | Column dtype: int64 | Example value: [6] | Example value dtype: integer\nColumn name: saleDay | Column dtype: int64 | Example value: [16] | Example value dtype: integer\nColumn name: saleDayofweek | Column dtype: int64 | Example value: [3] | Example value dtype: integer\nColumn name: saleDayofyear | Column dtype: int64 | Example value: [285] | Example value dtype: integer\n</pre> <p>Beautiful! Looks like we've got a mixture of <code>int64</code> and <code>float64</code> numerical datatypes.</p> <p>Now how about we find out which numeric columns are missing values?</p> <p>We can do so by using <code>pandas.isnull(obj).sum()</code> to detect and sum the missing values in a given array-like object (in our case, the data in a target column).</p> <p>Let's loop through our DataFrame columns, find the numeric datatypes and check if they have any missing values.</p> In\u00a0[53]: Copied! <pre># Check for which numeric columns have null values\nfor label, content in df_tmp.items():\n    if pd.api.types.is_numeric_dtype(content):\n        if pd.isnull(content).sum():\n            print(f\"Column name: {label} | Has missing values: {True}\")\n        else:\n            print(f\"Column name: {label} | Has missing values: {False}\")\n</pre> # Check for which numeric columns have null values for label, content in df_tmp.items():     if pd.api.types.is_numeric_dtype(content):         if pd.isnull(content).sum():             print(f\"Column name: {label} | Has missing values: {True}\")         else:             print(f\"Column name: {label} | Has missing values: {False}\") <pre>Column name: SalesID | Has missing values: False\nColumn name: SalePrice | Has missing values: False\nColumn name: MachineID | Has missing values: False\nColumn name: ModelID | Has missing values: False\nColumn name: datasource | Has missing values: False\nColumn name: auctioneerID | Has missing values: True\nColumn name: YearMade | Has missing values: False\nColumn name: MachineHoursCurrentMeter | Has missing values: True\nColumn name: saleYear | Has missing values: False\nColumn name: saleMonth | Has missing values: False\nColumn name: saleDay | Has missing values: False\nColumn name: saleDayofweek | Has missing values: False\nColumn name: saleDayofyear | Has missing values: False\n</pre> <p>Okay, it looks like our <code>auctioneerID</code> and <code>MachineHoursCurrentMeter</code> columns have missing numeric values.</p> <p>Let's have a look at how we might handle these.</p> In\u00a0[54]: Copied! <pre># Fill missing numeric values with the median of the target column\nfor label, content in df_tmp.items():\n    if pd.api.types.is_numeric_dtype(content):\n        if pd.isnull(content).sum():\n            \n            # Add a binary column which tells if the data was missing our not\n            df_tmp[label+\"_is_missing\"] = pd.isnull(content).astype(int) # this will add a 0 or 1 value to rows with missing values (e.g. 0 = not missing, 1 = missing)\n\n            # Fill missing numeric values with median since it's more robust than the mean\n            df_tmp[label] = content.fillna(content.median())\n</pre> # Fill missing numeric values with the median of the target column for label, content in df_tmp.items():     if pd.api.types.is_numeric_dtype(content):         if pd.isnull(content).sum():                          # Add a binary column which tells if the data was missing our not             df_tmp[label+\"_is_missing\"] = pd.isnull(content).astype(int) # this will add a 0 or 1 value to rows with missing values (e.g. 0 = not missing, 1 = missing)              # Fill missing numeric values with median since it's more robust than the mean             df_tmp[label] = content.fillna(content.median()) <p>Why add a binary column indicating whether the data was missing or not?</p> <p>We can easily fill all of the missing numeric values in our dataset with the median.</p> <p>However, a numeric value may be missing for a reason.</p> <p>Adding a binary column which indicates whether the value was missing or not helps to retain this information. It also means we can inspect these rows later on.</p> In\u00a0[55]: Copied! <pre># Show rows where MachineHoursCurrentMeter_is_missing == 1\ndf_tmp[df_tmp[\"MachineHoursCurrentMeter_is_missing\"] == 1].sample(5)\n</pre> # Show rows where MachineHoursCurrentMeter_is_missing == 1 df_tmp[df_tmp[\"MachineHoursCurrentMeter_is_missing\"] == 1].sample(5) Out[55]: SalesID SalePrice MachineID ModelID datasource auctioneerID YearMade MachineHoursCurrentMeter UsageBand fiModelDesc ... Travel_Controls Differential_Type Steering_Controls saleYear saleMonth saleDay saleDayofweek saleDayofyear auctioneerID_is_missing MachineHoursCurrentMeter_is_missing 150110 1631531 35000.0 1267456 4794 132 2.0 1998 0.0 NaN 710D ... NaN NaN NaN 2003 9 11 3 254 0 1 111297 1327658 15000.0 1185021 4112 132 99.0 1980 0.0 NaN D5B ... None or Unspecified NaN NaN 2001 5 8 1 128 0 1 177121 1432179 52000.0 788654 1263 132 1.0 1997 0.0 NaN 330BL ... NaN NaN NaN 2005 2 15 1 46 0 1 138512 1440179 27000.0 790577 3547 132 7.0 1999 0.0 NaN 426C ... NaN NaN NaN 2002 12 6 4 340 0 1 69375 1473901 67500.0 196530 3823 132 6.0 1991 0.0 NaN 950F ... NaN Standard Conventional 1998 8 27 3 239 0 1 <p>5 rows \u00d7 59 columns</p> <p>Missing numeric values filled!</p> <p>How about we check again whether or not the numeric columns have missing values?</p> In\u00a0[56]: Copied! <pre># Check for which numeric columns have null values\nfor label, content in df_tmp.items():\n    if pd.api.types.is_numeric_dtype(content):\n        if pd.isnull(content).sum():\n            print(f\"Column name: {label} | Has missing values: {True}\")\n        else:\n            print(f\"Column name: {label} | Has missing values: {False}\")\n</pre> # Check for which numeric columns have null values for label, content in df_tmp.items():     if pd.api.types.is_numeric_dtype(content):         if pd.isnull(content).sum():             print(f\"Column name: {label} | Has missing values: {True}\")         else:             print(f\"Column name: {label} | Has missing values: {False}\") <pre>Column name: SalesID | Has missing values: False\nColumn name: SalePrice | Has missing values: False\nColumn name: MachineID | Has missing values: False\nColumn name: ModelID | Has missing values: False\nColumn name: datasource | Has missing values: False\nColumn name: auctioneerID | Has missing values: False\nColumn name: YearMade | Has missing values: False\nColumn name: MachineHoursCurrentMeter | Has missing values: False\nColumn name: saleYear | Has missing values: False\nColumn name: saleMonth | Has missing values: False\nColumn name: saleDay | Has missing values: False\nColumn name: saleDayofweek | Has missing values: False\nColumn name: saleDayofyear | Has missing values: False\nColumn name: auctioneerID_is_missing | Has missing values: False\nColumn name: MachineHoursCurrentMeter_is_missing | Has missing values: False\n</pre> <p>Woohoo! Numeric missing values filled!</p> <p>And thanks to our binary <code>_is_missing</code> columns, we can even check how many were missing.</p> In\u00a0[57]: Copied! <pre># Check to see how many examples in the auctioneerID were missing\ndf_tmp.auctioneerID_is_missing.value_counts()\n</pre> # Check to see how many examples in the auctioneerID were missing df_tmp.auctioneerID_is_missing.value_counts() Out[57]: <pre>auctioneerID_is_missing\n0    392562\n1     20136\nName: count, dtype: int64</pre> In\u00a0[58]: Copied! <pre># Check columns which aren't numeric\nprint(f\"[INFO] Columns which are not numeric:\")\nfor label, content in df_tmp.items():\n    if not pd.api.types.is_numeric_dtype(content):\n        print(f\"Column name: {label} | Column dtype: {df_tmp[label].dtype.name}\")\n</pre> # Check columns which aren't numeric print(f\"[INFO] Columns which are not numeric:\") for label, content in df_tmp.items():     if not pd.api.types.is_numeric_dtype(content):         print(f\"Column name: {label} | Column dtype: {df_tmp[label].dtype.name}\") <pre>[INFO] Columns which are not numeric:\nColumn name: UsageBand | Column dtype: category\nColumn name: fiModelDesc | Column dtype: category\nColumn name: fiBaseModel | Column dtype: category\nColumn name: fiSecondaryDesc | Column dtype: category\nColumn name: fiModelSeries | Column dtype: category\nColumn name: fiModelDescriptor | Column dtype: category\nColumn name: ProductSize | Column dtype: category\nColumn name: fiProductClassDesc | Column dtype: category\nColumn name: state | Column dtype: category\nColumn name: ProductGroup | Column dtype: category\nColumn name: ProductGroupDesc | Column dtype: category\nColumn name: Drive_System | Column dtype: category\nColumn name: Enclosure | Column dtype: category\nColumn name: Forks | Column dtype: category\nColumn name: Pad_Type | Column dtype: category\nColumn name: Ride_Control | Column dtype: category\nColumn name: Stick | Column dtype: category\nColumn name: Transmission | Column dtype: category\nColumn name: Turbocharged | Column dtype: category\nColumn name: Blade_Extension | Column dtype: category\nColumn name: Blade_Width | Column dtype: category\nColumn name: Enclosure_Type | Column dtype: category\nColumn name: Engine_Horsepower | Column dtype: category\nColumn name: Hydraulics | Column dtype: category\nColumn name: Pushblock | Column dtype: category\nColumn name: Ripper | Column dtype: category\nColumn name: Scarifier | Column dtype: category\nColumn name: Tip_Control | Column dtype: category\nColumn name: Tire_Size | Column dtype: category\nColumn name: Coupler | Column dtype: category\nColumn name: Coupler_System | Column dtype: category\nColumn name: Grouser_Tracks | Column dtype: category\nColumn name: Hydraulics_Flow | Column dtype: category\nColumn name: Track_Type | Column dtype: category\nColumn name: Undercarriage_Pad_Width | Column dtype: category\nColumn name: Stick_Length | Column dtype: category\nColumn name: Thumb | Column dtype: category\nColumn name: Pattern_Changer | Column dtype: category\nColumn name: Grouser_Type | Column dtype: category\nColumn name: Backhoe_Mounting | Column dtype: category\nColumn name: Blade_Type | Column dtype: category\nColumn name: Travel_Controls | Column dtype: category\nColumn name: Differential_Type | Column dtype: category\nColumn name: Steering_Controls | Column dtype: category\n</pre> <p>Okay, we've got plenty of category type columns.</p> <p>Let's now write some code to fill the missing categorical values as well as ensure they are numerical (non-string).</p> <p>To do so, we'll:</p> <ol> <li>Create a blank column to category dictionary, we'll use this to store categorical value names (e.g. their string name) as well as their categorical code. We'll end with a dictionary of dictionaries in the form <code>{\"column_name\": {category_code: \"category_value\"...}...}</code>.</li> <li>Loop through the items in the DataFrame.</li> <li>Check if the column is numeric or not.</li> <li>Add a binary column in the form <code>ORIGINAL_COLUMN_NAME_is_missing</code> with a <code>0</code> or <code>1</code> value for if the row had a missing value.</li> <li>Ensure the column values are in the <code>pd.Categorical</code> datatype and get their category codes with <code>pd.Series.cat.codes</code> (we'll add <code>1</code> to these values since pandas defaults to assigning <code>-1</code> to <code>NaN</code> values, we'll use <code>0</code> instead).</li> <li>Turn the column categories and column category codes from 5 into a dictionary with Python's <code>dict(zip(category_names, category_codes))</code> and save this to the blank dictionary from 1 with the target column name as key.</li> <li>Set the target column value to the numerical category values from 5.</li> </ol> <p>Phew!</p> <p>That's a fair few steps but nothing we can't handle.</p> <p>Let's do it!</p> In\u00a0[59]: Copied! <pre># 1. Create a dictionary to store column to category values (e.g. we turn our category types into numbers but we keep a record so we can go back)\ncolumn_to_category_dict = {} \n\n# 2. Turn categorical variables into numbers\nfor label, content in df_tmp.items():\n\n    # 3. Check columns which *aren't* numeric\n    if not pd.api.types.is_numeric_dtype(content):\n\n        # 4. Add binary column to inidicate whether sample had missing value\n        df_tmp[label+\"_is_missing\"] = pd.isnull(content).astype(int)\n\n        # 5. Ensure content is categorical and get its category codes\n        content_categories = pd.Categorical(content)\n        content_category_codes = content_categories.codes + 1 # prevents -1 (the default for NaN values) from being used for missing values (we'll treat missing values as 0)\n\n        # 6. Add column key to dictionary with code: category mapping per column\n        column_to_category_dict[label] = dict(zip(content_category_codes, content_categories))\n        \n        # 7. Set the column to the numerical values (the category code value) \n        df_tmp[label] = content_category_codes\n</pre> # 1. Create a dictionary to store column to category values (e.g. we turn our category types into numbers but we keep a record so we can go back) column_to_category_dict = {}   # 2. Turn categorical variables into numbers for label, content in df_tmp.items():      # 3. Check columns which *aren't* numeric     if not pd.api.types.is_numeric_dtype(content):          # 4. Add binary column to inidicate whether sample had missing value         df_tmp[label+\"_is_missing\"] = pd.isnull(content).astype(int)          # 5. Ensure content is categorical and get its category codes         content_categories = pd.Categorical(content)         content_category_codes = content_categories.codes + 1 # prevents -1 (the default for NaN values) from being used for missing values (we'll treat missing values as 0)          # 6. Add column key to dictionary with code: category mapping per column         column_to_category_dict[label] = dict(zip(content_category_codes, content_categories))                  # 7. Set the column to the numerical values (the category code value)          df_tmp[label] = content_category_codes       <p>Ho ho! No errors!</p> <p>Let's check out a few random samples of our DataFrame.</p> In\u00a0[60]: Copied! <pre>df_tmp.sample(5)\n</pre> df_tmp.sample(5) Out[60]: SalesID SalePrice MachineID ModelID datasource auctioneerID YearMade MachineHoursCurrentMeter UsageBand fiModelDesc ... Undercarriage_Pad_Width_is_missing Stick_Length_is_missing Thumb_is_missing Pattern_Changer_is_missing Grouser_Type_is_missing Backhoe_Mounting_is_missing Blade_Type_is_missing Travel_Controls_is_missing Differential_Type_is_missing Steering_Controls_is_missing 232167 2412660 53000.0 1144729 607 136 1.0 2000 0.0 0 4823 ... 1 1 1 1 1 1 1 1 0 0 398100 1221746 18500.0 1047245 2759 121 3.0 1000 319.0 2 2224 ... 1 1 1 1 1 0 0 0 1 1 363820 2502559 31000.0 1333542 3172 149 1.0 2007 1149.0 3 1081 ... 1 1 1 1 1 1 1 1 1 1 322230 2432752 7500.0 1537457 36033 136 1.0 2003 0.0 0 4259 ... 1 1 1 1 1 1 1 1 1 1 10401 1356581 26000.0 1394933 4090 132 1.0 1988 0.0 0 2121 ... 1 1 1 1 1 0 0 0 1 1 <p>5 rows \u00d7 103 columns</p> <p>Beautiful! Looks like our data is all in numerical form.</p> <p>How about we investigate an item from our <code>column_to_category_dict</code>?</p> <p>This will show the mapping from numerical value to category (most likely a string) value.</p> In\u00a0[61]: Copied! <pre># Check the UsageBand (measure of bulldozer usage)\nfor key, value in sorted(column_to_category_dict[\"UsageBand\"].items()): # note: calling sorted() on dictionary.items() sorts the dictionary by keys \n    print(f\"{key} -&gt; {value}\")\n</pre> # Check the UsageBand (measure of bulldozer usage) for key, value in sorted(column_to_category_dict[\"UsageBand\"].items()): # note: calling sorted() on dictionary.items() sorts the dictionary by keys      print(f\"{key} -&gt; {value}\") <pre>0 -&gt; nan\n1 -&gt; High\n2 -&gt; Low\n3 -&gt; Medium\n</pre> <p>Note: Categorical values do not necessarily have order. They are strictly a mapping from number to value. In this case, our categorical values are mapped in numerical order. If you feel that the order of a value may influence a model in a negative way (e.g. <code>1 -&gt; High</code> is lower than <code>3 -&gt; Medium</code> but should be higher), you may want to look into ordering the values in a particular way or using a different numerical encoding technique such as one-hot encoding.</p> <p>And we can do the same for the <code>state</code> column values.</p> In\u00a0[62]: Copied! <pre># Check the first 10 state column values\nfor key, value in sorted(column_to_category_dict[\"state\"].items())[:10]:\n    print(f\"{key} -&gt; {value}\")\n</pre> # Check the first 10 state column values for key, value in sorted(column_to_category_dict[\"state\"].items())[:10]:     print(f\"{key} -&gt; {value}\") <pre>1 -&gt; Alabama\n2 -&gt; Alaska\n3 -&gt; Arizona\n4 -&gt; Arkansas\n5 -&gt; California\n6 -&gt; Colorado\n7 -&gt; Connecticut\n8 -&gt; Delaware\n9 -&gt; Florida\n10 -&gt; Georgia\n</pre> <p>Beautiful!</p> <p>How about we check to see all of the missing values have been filled?</p> In\u00a0[63]: Copied! <pre># Check total number of missing values\ntotal_missing_values = df_tmp.isna().sum().sum()\n\nif total_missing_values == 0:\n    print(f\"[INFO] Total missing values: {total_missing_values} - Woohoo! Let's build a model!\")\nelse:\n    print(f\"[INFO] Uh ohh... total missing values: {total_missing_values} - Perhaps we might have to retrace our steps to fill the values?\")\n</pre> # Check total number of missing values total_missing_values = df_tmp.isna().sum().sum()  if total_missing_values == 0:     print(f\"[INFO] Total missing values: {total_missing_values} - Woohoo! Let's build a model!\") else:     print(f\"[INFO] Uh ohh... total missing values: {total_missing_values} - Perhaps we might have to retrace our steps to fill the values?\") <pre>[INFO] Total missing values: 0 - Woohoo! Let's build a model!\n</pre> In\u00a0[64]: Copied! <pre># Save preprocessed data with object values as categories as well as missing values filled\ndf_tmp.to_parquet(path=\"../data/bluebook-for-bulldozers/TrainAndValid_object_values_as_categories_and_missing_values_filled.parquet\",\n                  engine=\"auto\")\n</pre> # Save preprocessed data with object values as categories as well as missing values filled df_tmp.to_parquet(path=\"../data/bluebook-for-bulldozers/TrainAndValid_object_values_as_categories_and_missing_values_filled.parquet\",                   engine=\"auto\") <p>And to make sure it worked, we can re-import it.</p> In\u00a0[65]: Copied! <pre># Read in preprocessed dataset\ndf_tmp = pd.read_parquet(path=\"../data/bluebook-for-bulldozers/TrainAndValid_object_values_as_categories_and_missing_values_filled.parquet\",\n                         engine=\"auto\")\n</pre> # Read in preprocessed dataset df_tmp = pd.read_parquet(path=\"../data/bluebook-for-bulldozers/TrainAndValid_object_values_as_categories_and_missing_values_filled.parquet\",                          engine=\"auto\") <p>Does it have any missing values?</p> In\u00a0[66]: Copied! <pre># Check total number of missing values\ntotal_missing_values = df_tmp.isna().sum().sum()\n\nif total_missing_values == 0:\n    print(f\"[INFO] Total missing values: {total_missing_values} - Woohoo! Let's build a model!\")\nelse:\n    print(f\"[INFO] Uh ohh... total missing values: {total_missing_values} - Perhaps we might have to retrace our steps to fill the values?\")\n</pre> # Check total number of missing values total_missing_values = df_tmp.isna().sum().sum()  if total_missing_values == 0:     print(f\"[INFO] Total missing values: {total_missing_values} - Woohoo! Let's build a model!\") else:     print(f\"[INFO] Uh ohh... total missing values: {total_missing_values} - Perhaps we might have to retrace our steps to fill the values?\") <pre>[INFO] Total missing values: 0 - Woohoo! Let's build a model!\n</pre> <p>Checkpoint reached!</p> <p>We've turned all of our data into numbers as well as filled the missing values, time to try fitting a model to it again.</p> In\u00a0[67]: Copied! <pre>%%time\n\n# Sample 1000 samples with random state 42 for reproducibility\ndf_tmp_sample_1k = df_tmp.sample(n=1000, random_state=42)\n\n# Instantiate a model\nmodel = RandomForestRegressor(n_jobs=-1) # use -1 to utilise all available processors\n\n# Create features and labels\nX_sample_1k = df_tmp_sample_1k.drop(\"SalePrice\", axis=1) # use all columns except SalePrice as X values\ny_sample_1k = df_tmp_sample_1k[\"SalePrice\"] # use SalePrice as y values (target variable)\n\n# Fit the model to the sample data\nmodel.fit(X=X_sample_1k, \n          y=y_sample_1k)\n</pre> %%time  # Sample 1000 samples with random state 42 for reproducibility df_tmp_sample_1k = df_tmp.sample(n=1000, random_state=42)  # Instantiate a model model = RandomForestRegressor(n_jobs=-1) # use -1 to utilise all available processors  # Create features and labels X_sample_1k = df_tmp_sample_1k.drop(\"SalePrice\", axis=1) # use all columns except SalePrice as X values y_sample_1k = df_tmp_sample_1k[\"SalePrice\"] # use SalePrice as y values (target variable)  # Fit the model to the sample data model.fit(X=X_sample_1k,            y=y_sample_1k)  <pre>CPU times: user 1.06 s, sys: 2.37 s, total: 3.43 s\nWall time: 976 ms\n</pre> Out[67]: <pre>RandomForestRegressor(n_jobs=-1)</pre>In a Jupyter environment, please rerun this cell to show the HTML representation or trust the notebook. On GitHub, the HTML representation is unable to render, please try loading this page with nbviewer.org.\u00a0\u00a0RandomForestRegressor?Documentation for RandomForestRegressoriFitted<pre>RandomForestRegressor(n_jobs=-1)</pre> <p>Woah! It looks like things worked!</p> <p>And quite quick too (since we're only using a relatively small number of rows).</p> <p>How about we score our model?</p> <p>We can do so using the built-in method <code>score()</code>.</p> <p>By default, <code>sklearn.ensemble.RandomForestRegressor</code> uses coefficient of determination ($R^2$ or R-squared) as the evaluation metric (higher is better, with a score of 1.0 being perfect).</p> In\u00a0[68]: Copied! <pre># Evaluate the model\nmodel_sample_1k_score = model.score(X=X_sample_1k,\n                                    y=y_sample_1k)\n\nprint(f\"[INFO] Model score on {len(df_tmp_sample_1k)} samples: {model_sample_1k_score}\")\n</pre> # Evaluate the model model_sample_1k_score = model.score(X=X_sample_1k,                                     y=y_sample_1k)  print(f\"[INFO] Model score on {len(df_tmp_sample_1k)} samples: {model_sample_1k_score}\") <pre>[INFO] Model score on 1000 samples: 0.9563062437082765\n</pre> <p>Wow, it looks like our model got a pretty good score on only 1000 samples (the best possible score it could achieve would've been 1.0).</p> <p>How about we try our model on the whole dataset?</p> In\u00a0[69]: Copied! <pre>%%time\n\n# Instantiate model\nmodel = RandomForestRegressor(n_jobs=-1) # note: this could take quite a while depending on your machine (it took ~1.5 minutes on my MacBook Pro M1 Pro with 10 cores)\n\n# Create features and labels with entire dataset\nX_all = df_tmp.drop(\"SalePrice\", axis=1)\ny_all = df_tmp[\"SalePrice\"]\n\n# Fit the model\nmodel.fit(X=X_all, \n          y=y_all)\n</pre> %%time  # Instantiate model model = RandomForestRegressor(n_jobs=-1) # note: this could take quite a while depending on your machine (it took ~1.5 minutes on my MacBook Pro M1 Pro with 10 cores)  # Create features and labels with entire dataset X_all = df_tmp.drop(\"SalePrice\", axis=1) y_all = df_tmp[\"SalePrice\"]  # Fit the model model.fit(X=X_all,            y=y_all) <pre>CPU times: user 10min 21s, sys: 8min 31s, total: 18min 53s\nWall time: 3min 24s\n</pre> Out[69]: <pre>RandomForestRegressor(n_jobs=-1)</pre>In a Jupyter environment, please rerun this cell to show the HTML representation or trust the notebook. On GitHub, the HTML representation is unable to render, please try loading this page with nbviewer.org.\u00a0\u00a0RandomForestRegressor?Documentation for RandomForestRegressoriFitted<pre>RandomForestRegressor(n_jobs=-1)</pre> <p>Ok, that took a little bit longer than fitting on 1000 samples (but that's too be expected, as many more calculations had to be made).</p> <p>There's a reason we used <code>n_jobs=-1</code> too.</p> <p>If we stuck with the default of <code>n_jobs=None</code> (the same as <code>n_jobs=1</code>), it would've taken much longer.</p> Configuration (MacBook Pro M1 Pro, 10 Cores) CPU Times (User) CPU Times (Sys) CPU Times (Total) Wall Time <code>n_jobs=-1</code> (all cores) 9min 14s 3.85s 9min 18s 1min 15s <code>n_jobs=None</code> (default) 7min 14s 1.75s 7min 16s 7min 25s <p>And as we've discussed many times, one of the main goals when starting a machine learning project is to reduce your time between experiments.</p> <p>How about we score the model trained on all of the data?</p> In\u00a0[70]: Copied! <pre># Evaluate the model\nmodel_sample_all_score = model.score(X=X_all,\n                                     y=y_all)\n\nprint(f\"[INFO] Model score on {len(df_tmp)} samples: {model_sample_all_score}\")\n</pre> # Evaluate the model model_sample_all_score = model.score(X=X_all,                                      y=y_all)  print(f\"[INFO] Model score on {len(df_tmp)} samples: {model_sample_all_score}\") <pre>[INFO] Model score on 412698 samples: 0.9875710658782831\n</pre> <p>An even better score!</p> <p>Oh wait...</p> <p>Oh no...</p> <p>I think we've got an error... (you might've noticed it already)</p> <p>Why might this metric be unreliable?</p> <p>Hint: Compare the data we trained on versus the data we evaluated on.</p> In\u00a0[71]: Copied! <pre># Import train samples (making sure to parse dates and then sort by them)\ntrain_df = pd.read_csv(filepath_or_buffer=\"../data/bluebook-for-bulldozers/Train.csv\",\n                       parse_dates=[\"saledate\"],\n                       low_memory=False).sort_values(by=\"saledate\", ascending=True)\n\n# Import validation samples (making sure to parse dates and then sort by them)\nvalid_df = pd.read_csv(filepath_or_buffer=\"../data/bluebook-for-bulldozers/Valid.csv\",\n                       parse_dates=[\"saledate\"])\n\n# The ValidSolution.csv contains the SalePrice values for the samples in Valid.csv\nvalid_solution = pd.read_csv(filepath_or_buffer=\"../data/bluebook-for-bulldozers/ValidSolution.csv\")\n\n# Map valid_solution to valid_df\nvalid_df[\"SalePrice\"] = valid_df[\"SalesID\"].map(valid_solution.set_index(\"SalesID\")[\"SalePrice\"])\n\n# Make sure valid_df is sorted by saledate still\nvalid_df = valid_df.sort_values(\"saledate\", ascending=True).reset_index(drop=True)\n\n# How many samples are in each DataFrame?\nprint(f\"[INFO] Number of samples in training DataFrame: {len(train_df)}\")\nprint(f\"[INFO] Number of samples in validation DataFrame: {len(valid_df)}\")\n</pre> # Import train samples (making sure to parse dates and then sort by them) train_df = pd.read_csv(filepath_or_buffer=\"../data/bluebook-for-bulldozers/Train.csv\",                        parse_dates=[\"saledate\"],                        low_memory=False).sort_values(by=\"saledate\", ascending=True)  # Import validation samples (making sure to parse dates and then sort by them) valid_df = pd.read_csv(filepath_or_buffer=\"../data/bluebook-for-bulldozers/Valid.csv\",                        parse_dates=[\"saledate\"])  # The ValidSolution.csv contains the SalePrice values for the samples in Valid.csv valid_solution = pd.read_csv(filepath_or_buffer=\"../data/bluebook-for-bulldozers/ValidSolution.csv\")  # Map valid_solution to valid_df valid_df[\"SalePrice\"] = valid_df[\"SalesID\"].map(valid_solution.set_index(\"SalesID\")[\"SalePrice\"])  # Make sure valid_df is sorted by saledate still valid_df = valid_df.sort_values(\"saledate\", ascending=True).reset_index(drop=True)  # How many samples are in each DataFrame? print(f\"[INFO] Number of samples in training DataFrame: {len(train_df)}\") print(f\"[INFO] Number of samples in validation DataFrame: {len(valid_df)}\") <pre>[INFO] Number of samples in training DataFrame: 401125\n[INFO] Number of samples in validation DataFrame: 11573\n</pre> In\u00a0[72]: Copied! <pre># Let's check out the training DataFrame\ntrain_df.sample(5)\n</pre> # Let's check out the training DataFrame train_df.sample(5) Out[72]: SalesID SalePrice MachineID ModelID datasource auctioneerID YearMade MachineHoursCurrentMeter UsageBand saledate ... Undercarriage_Pad_Width Stick_Length Thumb Pattern_Changer Grouser_Type Backhoe_Mounting Blade_Type Travel_Controls Differential_Type Steering_Controls 118276 1457333 58000 1434146 4147 132 1.0 1980 NaN NaN 1990-05-03 ... NaN NaN NaN NaN NaN None or Unspecified Straight None or Unspecified NaN NaN 149220 1522457 37000 1473616 4199 132 2.0 1992 NaN NaN 1996-11-16 ... None or Unspecified None or Unspecified None or Unspecified None or Unspecified Double NaN NaN NaN NaN NaN 118159 1457054 19250 1503681 4147 132 99.0 1979 NaN NaN 2009-10-01 ... NaN NaN NaN NaN NaN None or Unspecified Semi U None or Unspecified NaN NaN 28240 1258591 8250 1459934 6788 132 6.0 1971 NaN NaN 1990-04-18 ... NaN NaN NaN NaN NaN NaN NaN NaN NaN NaN 396348 6282780 41600 1916198 14272 149 99.0 2003 NaN NaN 2011-11-09 ... None or Unspecified None or Unspecified None or Unspecified None or Unspecified Double NaN NaN NaN NaN NaN <p>5 rows \u00d7 53 columns</p> In\u00a0[73]: Copied! <pre># And how about the validation DataFrame?\nvalid_df.sample(5)\n</pre> # And how about the validation DataFrame? valid_df.sample(5) Out[73]: SalesID MachineID ModelID datasource auctioneerID YearMade MachineHoursCurrentMeter UsageBand saledate fiModelDesc ... Stick_Length Thumb Pattern_Changer Grouser_Type Backhoe_Mounting Blade_Type Travel_Controls Differential_Type Steering_Controls SalePrice 7504 4325208 2306826 4840 172 1 1987 9540.0 Low 2012-03-22 850B ... NaN NaN NaN NaN None or Unspecified Straight None or Unspecified NaN NaN 10000.0 4853 6282223 1482307 28842 149 0 2004 NaN NaN 2012-02-23 80C ... None or Unspecified None or Unspecified None or Unspecified Double NaN NaN NaN NaN NaN 27000.0 28 6269818 1791122 7257 149 99 1978 48.0 Low 2012-01-11 910 ... NaN NaN NaN NaN NaN NaN NaN Standard Conventional 10600.0 7451 1226478 205898 1269 121 3 2004 9333.0 Medium 2012-03-22 330CL ... None or Unspecified Hydraulic Yes Double NaN NaN NaN NaN NaN 90000.0 693 1223479 143807 3538 121 3 1997 2154.0 Low 2012-01-27 416C ... NaN NaN NaN NaN NaN NaN NaN NaN NaN 19500.0 <p>5 rows \u00d7 53 columns</p> <p>Nice!</p> <p>We've now got separate training and validation datasets imported.</p> <p>In a previous section, we created a function to decompose the <code>saledate</code> column into multiple features such as <code>saleYear</code>, <code>saleMonth</code>, <code>saleDay</code> and more.</p> <p>Let's now replicate that function here and apply it to our <code>train_df</code> and <code>valid_df</code>.</p> In\u00a0[74]: Copied! <pre># Make a function to add date columns\ndef add_datetime_features_to_df(df, date_column=\"saledate\"):\n    # Add datetime parameters for saledate\n    df[\"saleYear\"] = df[date_column].dt.year\n    df[\"saleMonth\"] = df[date_column].dt.month\n    df[\"saleDay\"] = df[date_column].dt.day\n    df[\"saleDayofweek\"] = df[date_column].dt.dayofweek\n    df[\"saleDayofyear\"] = df[date_column].dt.dayofyear\n\n    # Drop original saledate column\n    df.drop(\"saledate\", axis=1, inplace=True)\n\n    return df\n\ntrain_df = add_datetime_features_to_df(df=train_df)\nvalid_df = add_datetime_features_to_df(df=valid_df)\n</pre> # Make a function to add date columns def add_datetime_features_to_df(df, date_column=\"saledate\"):     # Add datetime parameters for saledate     df[\"saleYear\"] = df[date_column].dt.year     df[\"saleMonth\"] = df[date_column].dt.month     df[\"saleDay\"] = df[date_column].dt.day     df[\"saleDayofweek\"] = df[date_column].dt.dayofweek     df[\"saleDayofyear\"] = df[date_column].dt.dayofyear      # Drop original saledate column     df.drop(\"saledate\", axis=1, inplace=True)      return df  train_df = add_datetime_features_to_df(df=train_df) valid_df = add_datetime_features_to_df(df=valid_df) <p>Wonderful, now let's make sure it worked by inspecting the last 5 columns of <code>train_df</code>.</p> In\u00a0[75]: Copied! <pre># Display the last 5 columns (the recently added datetime breakdowns)\ntrain_df.iloc[:, -5:].sample(5)\n</pre> # Display the last 5 columns (the recently added datetime breakdowns) train_df.iloc[:, -5:].sample(5) Out[75]: saleYear saleMonth saleDay saleDayofweek saleDayofyear 319998 2010 4 22 3 112 133509 2003 2 20 3 51 291200 2008 5 23 4 144 280146 2006 3 18 5 77 335509 2008 4 29 1 120 <p>Perfect! How about we try and fit a model?</p> In\u00a0[76]: Copied! <pre># Split training data into features and labels\nX_train = train_df.drop(\"SalePrice\", axis=1)\ny_train = train_df[\"SalePrice\"]\n\n# Split validation data into features and labels\nX_valid = valid_df.drop(\"SalePrice\", axis=1)\ny_valid = valid_df[\"SalePrice\"]\n\n# Create a model\nmodel = RandomForestRegressor(n_jobs=-1)\n\n# Fit a model to the training data only\nmodel.fit(X=X_train,\n          y=y_train)\n</pre> # Split training data into features and labels X_train = train_df.drop(\"SalePrice\", axis=1) y_train = train_df[\"SalePrice\"]  # Split validation data into features and labels X_valid = valid_df.drop(\"SalePrice\", axis=1) y_valid = valid_df[\"SalePrice\"]  # Create a model model = RandomForestRegressor(n_jobs=-1)  # Fit a model to the training data only model.fit(X=X_train,           y=y_train) <pre>\n---------------------------------------------------------------------------\nValueError                                Traceback (most recent call last)\n/var/folders/c4/qj4gdk190td18bqvjjh0p3p00000gn/T/ipykernel_20423/150598518.py in ?()\n      9 # Create a model\n     10 model = RandomForestRegressor(n_jobs=-1)\n     11 \n     12 # Fit a model to the training data only\n---&gt; 13 model.fit(X=X_train,\n     14           y=y_train)\n\n~/miniforge3/envs/ai/lib/python3.11/site-packages/sklearn/base.py in ?(estimator, *args, **kwargs)\n   1469                 skip_parameter_validation=(\n   1470                     prefer_skip_nested_validation or global_skip_validation\n   1471                 )\n   1472             ):\n-&gt; 1473                 return fit_method(estimator, *args, **kwargs)\n\n~/miniforge3/envs/ai/lib/python3.11/site-packages/sklearn/ensemble/_forest.py in ?(self, X, y, sample_weight)\n    359         # Validate or convert input data\n    360         if issparse(y):\n    361             raise ValueError(\"sparse multilabel-indicator for y is not supported.\")\n    362 \n--&gt; 363         X, y = self._validate_data(\n    364             X,\n    365             y,\n    366             multi_output=True,\n\n~/miniforge3/envs/ai/lib/python3.11/site-packages/sklearn/base.py in ?(self, X, y, reset, validate_separately, cast_to_ndarray, **check_params)\n    646                 if \"estimator\" not in check_y_params:\n    647                     check_y_params = {**default_check_params, **check_y_params}\n    648                 y = check_array(y, input_name=\"y\", **check_y_params)\n    649             else:\n--&gt; 650                 X, y = check_X_y(X, y, **check_params)\n    651             out = X, y\n    652 \n    653         if not no_val_X and check_params.get(\"ensure_2d\", True):\n\n~/miniforge3/envs/ai/lib/python3.11/site-packages/sklearn/utils/validation.py in ?(X, y, accept_sparse, accept_large_sparse, dtype, order, copy, force_writeable, force_all_finite, ensure_2d, allow_nd, multi_output, ensure_min_samples, ensure_min_features, y_numeric, estimator)\n   1297         raise ValueError(\n   1298             f\"{estimator_name} requires y to be passed, but the target y is None\"\n   1299         )\n   1300 \n-&gt; 1301     X = check_array(\n   1302         X,\n   1303         accept_sparse=accept_sparse,\n   1304         accept_large_sparse=accept_large_sparse,\n\n~/miniforge3/envs/ai/lib/python3.11/site-packages/sklearn/utils/validation.py in ?(array, accept_sparse, accept_large_sparse, dtype, order, copy, force_writeable, force_all_finite, ensure_2d, allow_nd, ensure_min_samples, ensure_min_features, estimator, input_name)\n   1009                         )\n   1010                     array = xp.astype(array, dtype, copy=False)\n   1011                 else:\n   1012                     array = _asarray_with_order(array, order=order, dtype=dtype, xp=xp)\n-&gt; 1013             except ComplexWarning as complex_warning:\n   1014                 raise ValueError(\n   1015                     \"Complex data not supported\\n{}\\n\".format(array)\n   1016                 ) from complex_warning\n\n~/miniforge3/envs/ai/lib/python3.11/site-packages/sklearn/utils/_array_api.py in ?(array, dtype, order, copy, xp, device)\n    747         # Use NumPy API to support order\n    748         if copy is True:\n    749             array = numpy.array(array, order=order, dtype=dtype)\n    750         else:\n--&gt; 751             array = numpy.asarray(array, order=order, dtype=dtype)\n    752 \n    753         # At this point array is a NumPy ndarray. We convert it to an array\n    754         # container that is consistent with the input's namespace.\n\n~/miniforge3/envs/ai/lib/python3.11/site-packages/pandas/core/generic.py in ?(self, dtype, copy)\n   2149     def __array__(\n   2150         self, dtype: npt.DTypeLike | None = None, copy: bool_t | None = None\n   2151     ) -&gt; np.ndarray:\n   2152         values = self._values\n-&gt; 2153         arr = np.asarray(values, dtype=dtype)\n   2154         if (\n   2155             astype_is_view(values.dtype, arr.dtype)\n   2156             and using_copy_on_write()\n\nValueError: could not convert string to float: 'Medium'</pre> <p>Oh no!</p> <p>We run into the error:</p> <p>ValueError: could not convert string to float: 'Medium'</p> <p>Hmm...</p> <p>Where have we seen this error before?</p> <p>It looks like since we re-imported our training dataset (from <code>Train.csv</code>) its no longer all numerical (hence the <code>ValueError</code> above).</p> <p>Not to worry, we can fix this!</p> In\u00a0[77]: Copied! <pre># Define numerical and categorical features\nnumerical_features = [label for label, content in X_train.items() if pd.api.types.is_numeric_dtype(content)]\ncategorical_features = [label for label, content in X_train.items() if not pd.api.types.is_numeric_dtype(content)]\n\nprint(f\"[INFO] Numeric features: {numerical_features}\")\nprint(f\"[INFO] Categorical features: {categorical_features[:10]}...\")\n</pre> # Define numerical and categorical features numerical_features = [label for label, content in X_train.items() if pd.api.types.is_numeric_dtype(content)] categorical_features = [label for label, content in X_train.items() if not pd.api.types.is_numeric_dtype(content)]  print(f\"[INFO] Numeric features: {numerical_features}\") print(f\"[INFO] Categorical features: {categorical_features[:10]}...\") <pre>[INFO] Numeric features: ['SalesID', 'MachineID', 'ModelID', 'datasource', 'auctioneerID', 'YearMade', 'MachineHoursCurrentMeter', 'saleYear', 'saleMonth', 'saleDay', 'saleDayofweek', 'saleDayofyear']\n[INFO] Categorical features: ['UsageBand', 'fiModelDesc', 'fiBaseModel', 'fiSecondaryDesc', 'fiModelSeries', 'fiModelDescriptor', 'ProductSize', 'fiProductClassDesc', 'state', 'ProductGroup']...\n</pre> <p>Nice!</p> <p>We define our different feature types so we can use different preprocessing methods on each type.</p> <p>Scikit-Learn has many built-in methods for preprocessing data under the <code>sklearn.preprocessing</code> module.</p> <p>And I'd encourage you to spend some time reading the preprocessing data section of the Scikit-Learn user guide for more details.</p> <p>For now, let's focus on turning our categorical features into numbers (from object/string datatype to numeric datatype).</p> <p>The practice of turning non-numerical features into numerical features is often referred to as encoding.</p> <p>There are several encoders available for different use cases.</p> Encoder Description Use case For use on <code>LabelEncoder</code> Encode target labels with values between 0 and n_classes-1. Useful for turning classification target values into numeric representations. Target labels. <code>OneHotEncoder</code> Encode categorical features as a one-hot numeric array. Turns every positive class of a unique category into a 1 and every negative class into a 0. Categorical variables/features. <code>OrdinalEncoder</code> Encode categorical features as an integer array. Turn unique categorical values into a range of integers, for example, 0 maps to 'cat', 1 maps to 'dog', etc. Categorical variables/features. <code>TargetEncoder</code> Encode regression and classification targets into a shrunk estimate of the average target values for observations of the category. Useful for converting targets into a certain range of values. Target variables. <p>For our case, we're going to start with <code>OrdinalEncoder</code>.</p> <p>When transforming/encoding values with Scikit-Learn, the steps as follows:</p> <ol> <li>Instantiate an encoder, for example, <code>sklearn.preprocessing.OrdinalEncoder</code>.</li> <li>Use the <code>sklearn.preprocessing.OrdinalEncoder.fit</code> method on the training data (this helps the encoder learn a mapping of categorical to numeric values).</li> <li>Use the <code>sklearn.preprocessing.OrdinalEncoder.transform</code> method on the training data to apply the learned mapping from categorical to numeric values.<ul> <li>Note: The <code>sklearn.preprocessing.OrdinalEncoder.fit_transform</code> method combines steps 1 &amp; 2 into a single method.</li> </ul> </li> <li>Apply the learned mapping to subsequent datasets such as validation and test splits using <code>sklearn.preprocessing.OrdinalEncoder.transform</code> only.</li> </ol> <p>Notice how the <code>fit</code> and <code>fit_transform</code> methods were reserved for the training dataset only.</p> <p>This is because in practice the validation and testing datasets are meant to be unseen, meaning only information from the training dataset should be used to preprocess the validation/test datasets.</p> <p>In short:</p> <ol> <li>Instantiate an encoder such as <code>sklearn.preprocessing.OrdinalEncoder</code>.</li> <li>Fit the encoder to and transform the training dataset categorical variables/features with <code>sklearn.preprocessing.OrdinalEncoder.fit_transform</code>.</li> <li>Transform categorical variables/features from subsequent datasets such as the validation and test datasets with the learned encoding from step 2 using <code>sklearn.preprocessing.OridinalEncoder.transform</code>.<ul> <li>Note: Notice the use of the <code>transform</code> method on validation/test datasets rather than <code>fit_transform</code>.</li> </ul> </li> </ol> <p>Let's do it!</p> <p>We'll use the <code>OrdinalEncoder</code> class to fill any missing values with <code>np.nan</code> (<code>NaN</code>).</p> <p>We'll also make sure to only use the <code>OrdinalEncoder</code> on the categorical features of our DataFrame.</p> <p>Finally, the <code>OrdinalEncoder</code> expects all input variables to be of the same type (e.g. either numeric only or string only) so we'll make sure all the input variables are strings only using <code>pandas.DataFrame.astype(str)</code>.</p> In\u00a0[78]: Copied! <pre>from sklearn.preprocessing import OrdinalEncoder\n\n# 1. Create an ordinal encoder (turns category items into numeric representation)\nordinal_encoder = OrdinalEncoder(categories=\"auto\",\n                                 handle_unknown=\"use_encoded_value\",\n                                 unknown_value=np.nan,\n                                 encoded_missing_value=np.nan) # treat unknown categories as np.nan (or None)\n\n# 2. Fit and transform the categorical columns of X_train\nX_train_preprocessed = X_train.copy() # make copies of the oringal DataFrames so we can keep the original values in tact and view them later\nX_train_preprocessed[categorical_features] = ordinal_encoder.fit_transform(X_train_preprocessed[categorical_features].astype(str)) # OrdinalEncoder expects all values as the same type (e.g. string or numeric only)\n\n# 3. Transform the categorical columns of X_valid \nX_valid_preprocessed = X_valid.copy()\nX_valid_preprocessed[categorical_features] = ordinal_encoder.transform(X_valid_preprocessed[categorical_features].astype(str)) # only use `transform` on the validation data\n</pre> from sklearn.preprocessing import OrdinalEncoder  # 1. Create an ordinal encoder (turns category items into numeric representation) ordinal_encoder = OrdinalEncoder(categories=\"auto\",                                  handle_unknown=\"use_encoded_value\",                                  unknown_value=np.nan,                                  encoded_missing_value=np.nan) # treat unknown categories as np.nan (or None)  # 2. Fit and transform the categorical columns of X_train X_train_preprocessed = X_train.copy() # make copies of the oringal DataFrames so we can keep the original values in tact and view them later X_train_preprocessed[categorical_features] = ordinal_encoder.fit_transform(X_train_preprocessed[categorical_features].astype(str)) # OrdinalEncoder expects all values as the same type (e.g. string or numeric only)  # 3. Transform the categorical columns of X_valid  X_valid_preprocessed = X_valid.copy() X_valid_preprocessed[categorical_features] = ordinal_encoder.transform(X_valid_preprocessed[categorical_features].astype(str)) # only use `transform` on the validation data <p>Wonderful!</p> <p>Let's see if it worked.</p> <p>First, we'll check out the original <code>X_train</code> DataFrame.</p> In\u00a0[79]: Copied! <pre>X_train.head()\n</pre> X_train.head() Out[79]: SalesID MachineID ModelID datasource auctioneerID YearMade MachineHoursCurrentMeter UsageBand fiModelDesc fiBaseModel ... Backhoe_Mounting Blade_Type Travel_Controls Differential_Type Steering_Controls saleYear saleMonth saleDay saleDayofweek saleDayofyear 205615 1646770 1126363 8434 132 18.0 1974 NaN NaN TD20 TD20 ... None or Unspecified Straight None or Unspecified NaN NaN 1989 1 17 1 17 92803 1404019 1169900 7110 132 99.0 1986 NaN NaN 416 416 ... NaN NaN NaN NaN NaN 1989 1 31 1 31 98346 1415646 1262088 3357 132 99.0 1975 NaN NaN 12G 12 ... NaN NaN NaN NaN NaN 1989 1 31 1 31 169297 1596358 1433229 8247 132 99.0 1978 NaN NaN 644 644 ... NaN NaN NaN Standard Conventional 1989 1 31 1 31 274835 1821514 1194089 10150 132 99.0 1980 NaN NaN A66 A66 ... NaN NaN NaN Standard Conventional 1989 1 31 1 31 <p>5 rows \u00d7 56 columns</p> <p>And how about <code>X_train_preprocessed</code>?</p> In\u00a0[80]: Copied! <pre>X_train_preprocessed.head()\n</pre> X_train_preprocessed.head() Out[80]: SalesID MachineID ModelID datasource auctioneerID YearMade MachineHoursCurrentMeter UsageBand fiModelDesc fiBaseModel ... Backhoe_Mounting Blade_Type Travel_Controls Differential_Type Steering_Controls saleYear saleMonth saleDay saleDayofweek saleDayofyear 205615 1646770 1126363 8434 132 18.0 1974 NaN 3.0 4536.0 1734.0 ... 0.0 7.0 5.0 4.0 5.0 1989 1 17 1 17 92803 1404019 1169900 7110 132 99.0 1986 NaN 3.0 734.0 242.0 ... 2.0 10.0 7.0 4.0 5.0 1989 1 31 1 31 98346 1415646 1262088 3357 132 99.0 1975 NaN 3.0 81.0 18.0 ... 2.0 10.0 7.0 4.0 5.0 1989 1 31 1 31 169297 1596358 1433229 8247 132 99.0 1978 NaN 3.0 1157.0 348.0 ... 2.0 10.0 7.0 3.0 1.0 1989 1 31 1 31 274835 1821514 1194089 10150 132 99.0 1980 NaN 3.0 1799.0 556.0 ... 2.0 10.0 7.0 3.0 1.0 1989 1 31 1 31 <p>5 rows \u00d7 56 columns</p> <p>Beautiful!</p> <p>Notice all of the non-numerical values in <code>X_train</code> have been converted to numerical values in <code>X_train_preprocessed</code>.</p> <p>Now how about missing values?</p> <p>Let's see the top 10 columns with the highest number of missing values from <code>X_train</code>.</p> In\u00a0[81]: Copied! <pre>X_train[categorical_features].isna().sum().sort_values(ascending=False)[:10]\n</pre> X_train[categorical_features].isna().sum().sort_values(ascending=False)[:10] Out[81]: <pre>Engine_Horsepower    375906\nBlade_Extension      375906\nTip_Control          375906\nPushblock            375906\nEnclosure_Type       375906\nBlade_Width          375906\nScarifier            375895\nHydraulics_Flow      357763\nGrouser_Tracks       357763\nCoupler_System       357667\ndtype: int64</pre> <p>Ok, plenty of missing values.</p> <p>How about <code>X_train_preprocessed</code>?</p> In\u00a0[82]: Copied! <pre>X_train_preprocessed[categorical_features].isna().sum().sort_values(ascending=False)[:10]\n</pre> X_train_preprocessed[categorical_features].isna().sum().sort_values(ascending=False)[:10] Out[82]: <pre>UsageBand         0\nfiModelDesc       0\nPushblock         0\nRipper            0\nScarifier         0\nTip_Control       0\nTire_Size         0\nCoupler           0\nCoupler_System    0\nGrouser_Tracks    0\ndtype: int64</pre> <p>Perfect! No missing values as well!</p> <p>Now, what if we wanted to retrieve the original categorical values?</p> <p>We can do using the <code>OrdinalEncoder.categories_</code> attribute.</p> <p>This will return the categories of each feature found during <code>fit</code> (or during <code>fit_transform</code>), the categories will be in the order of the features seen (same order as the columns of the DataFrame).</p> In\u00a0[83]: Copied! <pre># Let's inspect the first three categories\nordinal_encoder.categories_[:3]\n</pre> # Let's inspect the first three categories ordinal_encoder.categories_[:3] Out[83]: <pre>[array(['High', 'Low', 'Medium', 'nan'], dtype=object),\n array(['100C', '104', '1066', ..., 'ZX800LC', 'ZX80LCK', 'ZX850H'],\n       dtype=object),\n array(['10', '100', '104', ..., 'ZX80', 'ZX800', 'ZX850'], dtype=object)]</pre> <p>Since these come in the order of the features seen, we can create a mapping of these using the categorical column names of our DataFrame.</p> In\u00a0[84]: Copied! <pre># Create a dictionary of dictionaries mapping column names and their variables to their numerical encoding\ncolumn_to_category_mapping = {}\n\nfor column_name, category_values in zip(categorical_features, ordinal_encoder.categories_):\n    int_to_category = {i: category for i, category in enumerate(category_values)}\n    column_to_category_mapping[column_name] = int_to_category\n\n# Inspect an example column name to category mapping\ncolumn_to_category_mapping[\"UsageBand\"]\n</pre> # Create a dictionary of dictionaries mapping column names and their variables to their numerical encoding column_to_category_mapping = {}  for column_name, category_values in zip(categorical_features, ordinal_encoder.categories_):     int_to_category = {i: category for i, category in enumerate(category_values)}     column_to_category_mapping[column_name] = int_to_category  # Inspect an example column name to category mapping column_to_category_mapping[\"UsageBand\"] Out[84]: <pre>{0: 'High', 1: 'Low', 2: 'Medium', 3: 'nan'}</pre> <p>We can also reverse our <code>OrdinalEncoder</code> values with the <code>inverse_transform()</code> method.</p> <p>This is helpful for reversing a preprocessing step or viewing the original data again if necessary.</p> In\u00a0[85]: Copied! <pre># Create a copy of the preprocessed DataFrame\nX_train_unprocessed = X_train_preprocessed[categorical_features].copy()\n\n# This will return an array of the original untransformed data\nX_train_unprocessed = ordinal_encoder.inverse_transform(X_train_unprocessed)\n\n# Turn back into a DataFrame for viewing pleasure\nX_train_unprocessed_df = pd.DataFrame(X_train_unprocessed, columns=categorical_features)\n\n# Check out a sample\nX_train_unprocessed_df.sample(5)\n</pre> # Create a copy of the preprocessed DataFrame X_train_unprocessed = X_train_preprocessed[categorical_features].copy()  # This will return an array of the original untransformed data X_train_unprocessed = ordinal_encoder.inverse_transform(X_train_unprocessed)  # Turn back into a DataFrame for viewing pleasure X_train_unprocessed_df = pd.DataFrame(X_train_unprocessed, columns=categorical_features)  # Check out a sample X_train_unprocessed_df.sample(5) Out[85]: UsageBand fiModelDesc fiBaseModel fiSecondaryDesc fiModelSeries fiModelDescriptor ProductSize fiProductClassDesc state ProductGroup ... Undercarriage_Pad_Width Stick_Length Thumb Pattern_Changer Grouser_Type Backhoe_Mounting Blade_Type Travel_Controls Differential_Type Steering_Controls 214315 nan 160CLC 160 C nan LC Small Hydraulic Excavator, Track - 14.0 to 16.0 Metr... Alabama TEX ... 28 inch None or Unspecified None or Unspecified None or Unspecified Triple nan nan nan nan nan 96782 nan D4H D4 H nan nan nan Track Type Tractor, Dozer - 85.0 to 105.0 Hors... California TTT ... nan nan nan nan nan None or Unspecified PAT None or Unspecified nan nan 224604 nan 140G 140 G nan nan nan Motorgrader - 145.0 to 170.0 Horsepower Missouri MG ... nan nan nan nan nan nan nan nan nan nan 310524 High 966E 966 E nan nan Medium Wheel Loader - 200.0 to 225.0 Horsepower Michigan WL ... nan nan nan nan nan nan nan nan Standard Conventional 156716 nan 650H 650 H nan nan nan Track Type Tractor, Dozer - 85.0 to 105.0 Hors... Florida TTT ... nan nan nan nan nan None or Unspecified PAT None or Unspecified nan nan <p>5 rows \u00d7 44 columns</p> <p>Nice!</p> <p>Now how about we try fitting a model again?</p> In\u00a0[86]: Copied! <pre>%%time\n\n# Instantiate a Random Forest Regression model\nmodel = RandomForestRegressor(n_jobs=-1)\n\n# Fit the model to the preprocessed training data\nmodel.fit(X=X_train_preprocessed,\n          y=y_train)\n</pre> %%time  # Instantiate a Random Forest Regression model model = RandomForestRegressor(n_jobs=-1)  # Fit the model to the preprocessed training data model.fit(X=X_train_preprocessed,           y=y_train) <pre>CPU times: user 8min 54s, sys: 6min 26s, total: 15min 20s\nWall time: 2min 40s\n</pre> Out[86]: <pre>RandomForestRegressor(n_jobs=-1)</pre>In a Jupyter environment, please rerun this cell to show the HTML representation or trust the notebook. On GitHub, the HTML representation is unable to render, please try loading this page with nbviewer.org.\u00a0\u00a0RandomForestRegressor?Documentation for RandomForestRegressoriFitted<pre>RandomForestRegressor(n_jobs=-1)</pre> <p>It worked!</p> <p>Now you might be thinking, \"well if we could fit a model on a dataset with missing values, why did we bother filling them before?\"</p> <p>And that's a great question.</p> <p>The main reason is to practice, practice, practice.</p> <p>While there are some models which can handle missing values, others can't.</p> <p>So it's good to have experience with both of these scenarios.</p> <p>Let's see how our model scores on the validation set, data our model has never seen.</p> In\u00a0[88]: Copied! <pre>%%time\n\n# Check model performance on the validation set\nmodel.score(X=X_valid,\n            y=y_valid)\n</pre> %%time  # Check model performance on the validation set model.score(X=X_valid,             y=y_valid) <pre>\n---------------------------------------------------------------------------\nValueError                                Traceback (most recent call last)\n&lt;timed eval&gt; in ?()\n      1 'Could not get source, probably due dynamically evaluated source code.'\n\n~/miniforge3/envs/ai/lib/python3.11/site-packages/sklearn/base.py in ?(self, X, y, sample_weight)\n    844         \"\"\"\n    845 \n    846         from .metrics import r2_score\n    847 \n--&gt; 848         y_pred = self.predict(X)\n    849         return r2_score(y, y_pred, sample_weight=sample_weight)\n\n~/miniforge3/envs/ai/lib/python3.11/site-packages/sklearn/ensemble/_forest.py in ?(self, X)\n   1059             The predicted values.\n   1060         \"\"\"\n   1061         check_is_fitted(self)\n   1062         # Check data\n-&gt; 1063         X = self._validate_X_predict(X)\n   1064 \n   1065         # Assign chunk of trees to jobs\n   1066         n_jobs, _, _ = _partition_estimators(self.n_estimators, self.n_jobs)\n\n~/miniforge3/envs/ai/lib/python3.11/site-packages/sklearn/ensemble/_forest.py in ?(self, X)\n    637             force_all_finite = \"allow-nan\"\n    638         else:\n    639             force_all_finite = True\n    640 \n--&gt; 641         X = self._validate_data(\n    642             X,\n    643             dtype=DTYPE,\n    644             accept_sparse=\"csr\",\n\n~/miniforge3/envs/ai/lib/python3.11/site-packages/sklearn/base.py in ?(self, X, y, reset, validate_separately, cast_to_ndarray, **check_params)\n    629                 out = y\n    630             else:\n    631                 out = X, y\n    632         elif not no_val_X and no_val_y:\n--&gt; 633             out = check_array(X, input_name=\"X\", **check_params)\n    634         elif no_val_X and not no_val_y:\n    635             out = _check_y(y, **check_params)\n    636         else:\n\n~/miniforge3/envs/ai/lib/python3.11/site-packages/sklearn/utils/validation.py in ?(array, accept_sparse, accept_large_sparse, dtype, order, copy, force_writeable, force_all_finite, ensure_2d, allow_nd, ensure_min_samples, ensure_min_features, estimator, input_name)\n   1009                         )\n   1010                     array = xp.astype(array, dtype, copy=False)\n   1011                 else:\n   1012                     array = _asarray_with_order(array, order=order, dtype=dtype, xp=xp)\n-&gt; 1013             except ComplexWarning as complex_warning:\n   1014                 raise ValueError(\n   1015                     \"Complex data not supported\\n{}\\n\".format(array)\n   1016                 ) from complex_warning\n\n~/miniforge3/envs/ai/lib/python3.11/site-packages/sklearn/utils/_array_api.py in ?(array, dtype, order, copy, xp, device)\n    747         # Use NumPy API to support order\n    748         if copy is True:\n    749             array = numpy.array(array, order=order, dtype=dtype)\n    750         else:\n--&gt; 751             array = numpy.asarray(array, order=order, dtype=dtype)\n    752 \n    753         # At this point array is a NumPy ndarray. We convert it to an array\n    754         # container that is consistent with the input's namespace.\n\n~/miniforge3/envs/ai/lib/python3.11/site-packages/pandas/core/generic.py in ?(self, dtype, copy)\n   2149     def __array__(\n   2150         self, dtype: npt.DTypeLike | None = None, copy: bool_t | None = None\n   2151     ) -&gt; np.ndarray:\n   2152         values = self._values\n-&gt; 2153         arr = np.asarray(values, dtype=dtype)\n   2154         if (\n   2155             astype_is_view(values.dtype, arr.dtype)\n   2156             and using_copy_on_write()\n\nValueError: could not convert string to float: 'Low'</pre> <p>Oops!</p> <p>Looks like we get an error:</p> <p><code>ValueError: could not convert string to float: 'Low'</code></p> <p>This is because we tried to evaluate our model on the original <code>X_valid</code> dataset which still contains strings rather than <code>X_valid_preprocessed</code> which contains all numerical values.</p> <p>As we've discussed before, in machine learning problems, it's important to evaluate your models on data in the same format as they were trained on.</p> <p>Knowing this, let's evaluate our model on our preprocessed validation dataset.</p> In\u00a0[89]: Copied! <pre>%%time\n\n# Check model performance on the validation set\nmodel.score(X=X_valid_preprocessed,\n            y=y_valid)\n</pre> %%time  # Check model performance on the validation set model.score(X=X_valid_preprocessed,             y=y_valid) <pre>CPU times: user 766 ms, sys: 3.54 s, total: 4.3 s\nWall time: 1.27 s\n</pre> Out[89]: <pre>0.8700295442271035</pre> <p>Excellent!</p> <p>Now you might be wondering why this score ($R^2$ or R-squared by default) is lower than the previous score of ~0.9875.</p> <p>That's because this score is based on a model that has only seen the training data and is being evaluated on an unseen dataset (training on <code>Train.csv</code>, evaluating on <code>Valid.csv</code>).</p> <p>Our previous score was from a model that had all of the evaluation samples in the training data (training and evaluating on <code>TrainAndValid.csv</code>).</p> <p>So in practice, we would consider the most recent score as a much more reliable metric of how well our model might perform on future unseen data.</p> <p>Just for fun, let's see how our model scores on the training dataset.</p> In\u00a0[90]: Copied! <pre>%%time\n\n# Check model performance on the training set\nmodel.score(X=X_train_preprocessed,\n            y=y_train)\n</pre> %%time  # Check model performance on the training set model.score(X=X_train_preprocessed,             y=y_train) <pre>CPU times: user 17.6 s, sys: 19.2 s, total: 36.8 s\nWall time: 7.42 s\n</pre> Out[90]: <pre>0.9872786621410867</pre> <p>As expected our model performs better on the training set than the validation set.</p> <p>It also scores much closer to the previous score of ~0.9875 we obtained when training and scoring on <code>TrainAndValid.csv</code> combined.</p> <p>Note: It is common to see a model perform slightly worse on a validation/testing dataset than on a training set. This is because the model has seen all of the examples in the training set, where as, if done correctly, the validation and test sets are keep separate during training. So you would expect a model to do better on problems that it has seen before versus problems it hasn't. If you find your model scoring much higher on unseen data versus seen data (e.g. higher scores on the test set compared to the training set), you might want to inspect your data to make sure there isn't any leakage from the validation/test set into the training set.</p> In\u00a0[93]: Copied! <pre># Create evaluation function (the competition uses Root Mean Square Log Error)\nfrom sklearn.metrics import mean_absolute_error, root_mean_squared_log_error\n\n# Create function to evaluate our model\ndef show_scores(model, \n                train_features=X_train_preprocessed,\n                train_labels=y_train,\n                valid_features=X_valid_preprocessed,\n                valid_labels=y_valid):\n    \n    # Make predictions on train and validation features\n    train_preds = model.predict(X=train_features)\n    val_preds = model.predict(X=valid_features)\n\n    # Create a scores dictionary of different evaluation metrics\n    scores = {\"Training MAE\": mean_absolute_error(y_true=train_labels, \n                                                  y_pred=train_preds),\n              \"Valid MAE\": mean_absolute_error(y_true=valid_labels, \n                                               y_pred=val_preds),\n              \"Training RMSLE\": root_mean_squared_log_error(y_true=train_labels, \n                                                            y_pred=train_preds),\n              \"Valid RMSLE\": root_mean_squared_log_error(y_true=valid_labels, \n                                                         y_pred=val_preds),\n              \"Training R^2\": model.score(X=train_features, \n                                          y=train_labels),\n              \"Valid R^2\": model.score(X=valid_features, \n                                       y=valid_labels)}\n    return scores\n</pre> # Create evaluation function (the competition uses Root Mean Square Log Error) from sklearn.metrics import mean_absolute_error, root_mean_squared_log_error  # Create function to evaluate our model def show_scores(model,                  train_features=X_train_preprocessed,                 train_labels=y_train,                 valid_features=X_valid_preprocessed,                 valid_labels=y_valid):          # Make predictions on train and validation features     train_preds = model.predict(X=train_features)     val_preds = model.predict(X=valid_features)      # Create a scores dictionary of different evaluation metrics     scores = {\"Training MAE\": mean_absolute_error(y_true=train_labels,                                                    y_pred=train_preds),               \"Valid MAE\": mean_absolute_error(y_true=valid_labels,                                                 y_pred=val_preds),               \"Training RMSLE\": root_mean_squared_log_error(y_true=train_labels,                                                              y_pred=train_preds),               \"Valid RMSLE\": root_mean_squared_log_error(y_true=valid_labels,                                                           y_pred=val_preds),               \"Training R^2\": model.score(X=train_features,                                            y=train_labels),               \"Valid R^2\": model.score(X=valid_features,                                         y=valid_labels)}     return scores <p>Now that's a nice looking function!</p> <p>How about we test it out?</p> In\u00a0[94]: Copied! <pre># Try our model scoring function out\nmodel_scores = show_scores(model=model)\nmodel_scores\n</pre> # Try our model scoring function out model_scores = show_scores(model=model) model_scores Out[94]: <pre>{'Training MAE': np.float64(1596.4113176025767),\n 'Valid MAE': np.float64(6172.124644142976),\n 'Training RMSLE': np.float64(0.08546822305943352),\n 'Valid RMSLE': np.float64(0.2576977236694938),\n 'Training R^2': 0.9872786621410867,\n 'Valid R^2': 0.8700295442271035}</pre> <p>Beautiful!</p> <p>Now we can reuse this in the future for evaluating other models.</p> In\u00a0[95]: Copied! <pre>%%time\n\n# Change max samples in RandomForestRegressor\nmodel = RandomForestRegressor(n_estimators=100, # this is the default\n                              n_jobs=-1,\n                              max_samples=10000) # each estimator sees max_samples (the default is to see all available samples)\n\n# Cutting down the max number of samples each tree can see improves training time\nmodel.fit(X_train_preprocessed, \n          y_train)\n</pre> %%time  # Change max samples in RandomForestRegressor model = RandomForestRegressor(n_estimators=100, # this is the default                               n_jobs=-1,                               max_samples=10000) # each estimator sees max_samples (the default is to see all available samples)  # Cutting down the max number of samples each tree can see improves training time model.fit(X_train_preprocessed,            y_train) <pre>CPU times: user 19.2 s, sys: 18.5 s, total: 37.6 s\nWall time: 7.53 s\n</pre> Out[95]: <pre>RandomForestRegressor(max_samples=10000, n_jobs=-1)</pre>In a Jupyter environment, please rerun this cell to show the HTML representation or trust the notebook. On GitHub, the HTML representation is unable to render, please try loading this page with nbviewer.org.\u00a0\u00a0RandomForestRegressor?Documentation for RandomForestRegressoriFitted<pre>RandomForestRegressor(max_samples=10000, n_jobs=-1)</pre> <p>Nice! That worked much faster than training on the whole dataset.</p> <p>Let's evaluate our model with our <code>show_scores</code> function.</p> In\u00a0[96]: Copied! <pre># Get evaluation metrics from reduced sample model\nbase_model_scores = show_scores(model=model)\nbase_model_scores\n</pre> # Get evaluation metrics from reduced sample model base_model_scores = show_scores(model=model) base_model_scores Out[96]: <pre>{'Training MAE': np.float64(5605.344206319725),\n 'Valid MAE': np.float64(7176.1651147786515),\n 'Training RMSLE': np.float64(0.26030112528907273),\n 'Valid RMSLE': np.float64(0.2935839690284876),\n 'Training R^2': 0.858111849057448,\n 'Valid R^2': 0.828549722372896}</pre> <p>Excellent! Even though our new model saw far less data than the previous model, it still looks to be performing quite well.</p> <p>With this faster model, we can start to run a series of different hyperparameter experiments.</p> In\u00a0[97]: Copied! <pre>%%time\n\nfrom sklearn.model_selection import RandomizedSearchCV\n\n# 1. Define a dictionary with different values for RandomForestRegressor hyperparameters\n# See documatation for potential different values - https://scikit-learn.org/stable/modules/generated/sklearn.ensemble.RandomForestRegressor.html \nrf_grid = {\"n_estimators\": np.arange(10, 200, 10),\n           \"max_depth\": [None, 10, 20],\n           \"min_samples_split\": np.arange(2, 10, 1), # min_samples_split must be an int in the range [2, inf) or a float in the range (0.0, 1.0]\n           \"min_samples_leaf\": np.arange(1, 10, 1),\n           \"max_features\": [0.5, 1.0, \"sqrt\"], # Note: \"max_features='auto'\" is equivalent to \"max_features=1.0\", as of Scikit-Learn version 1.1\n           \"max_samples\": [10000]}\n\n# 2. Setup instance of RandomizedSearchCV to explore different parameters \nrs_model = RandomizedSearchCV(estimator=RandomForestRegressor(), # can pass new model instance directly, all settings will be taken from the rf_grid\n                              param_distributions=rf_grid,\n                              n_iter=20,\n                            #   scoring=\"neg_root_mean_squared_log_error\", # want to optimize for RMSLE, though sometimes optimizing for the default metric (R^2) can lead to just as good results all round\n                              cv=3,\n                              verbose=3) # control how much output gets produced, higher number = more output\n\n# 3. Fit the model using a series of different hyperparameter values\nrs_model.fit(X=X_train_preprocessed, \n             y=y_train)\n</pre> %%time  from sklearn.model_selection import RandomizedSearchCV  # 1. Define a dictionary with different values for RandomForestRegressor hyperparameters # See documatation for potential different values - https://scikit-learn.org/stable/modules/generated/sklearn.ensemble.RandomForestRegressor.html  rf_grid = {\"n_estimators\": np.arange(10, 200, 10),            \"max_depth\": [None, 10, 20],            \"min_samples_split\": np.arange(2, 10, 1), # min_samples_split must be an int in the range [2, inf) or a float in the range (0.0, 1.0]            \"min_samples_leaf\": np.arange(1, 10, 1),            \"max_features\": [0.5, 1.0, \"sqrt\"], # Note: \"max_features='auto'\" is equivalent to \"max_features=1.0\", as of Scikit-Learn version 1.1            \"max_samples\": [10000]}  # 2. Setup instance of RandomizedSearchCV to explore different parameters  rs_model = RandomizedSearchCV(estimator=RandomForestRegressor(), # can pass new model instance directly, all settings will be taken from the rf_grid                               param_distributions=rf_grid,                               n_iter=20,                             #   scoring=\"neg_root_mean_squared_log_error\", # want to optimize for RMSLE, though sometimes optimizing for the default metric (R^2) can lead to just as good results all round                               cv=3,                               verbose=3) # control how much output gets produced, higher number = more output  # 3. Fit the model using a series of different hyperparameter values rs_model.fit(X=X_train_preprocessed,               y=y_train) <pre>Fitting 3 folds for each of 20 candidates, totalling 60 fits\n[CV 1/3] END max_depth=10, max_features=1.0, max_samples=10000, min_samples_leaf=1, min_samples_split=3, n_estimators=160;, score=0.539 total time=  21.6s\n[CV 2/3] END max_depth=10, max_features=1.0, max_samples=10000, min_samples_leaf=1, min_samples_split=3, n_estimators=160;, score=0.720 total time=  23.0s\n[CV 3/3] END max_depth=10, max_features=1.0, max_samples=10000, min_samples_leaf=1, min_samples_split=3, n_estimators=160;, score=0.596 total time=  22.2s\n[CV 1/3] END max_depth=10, max_features=sqrt, max_samples=10000, min_samples_leaf=9, min_samples_split=5, n_estimators=60;, score=0.491 total time=   3.3s\n[CV 2/3] END max_depth=10, max_features=sqrt, max_samples=10000, min_samples_leaf=9, min_samples_split=5, n_estimators=60;, score=0.655 total time=   3.4s\n[CV 3/3] END max_depth=10, max_features=sqrt, max_samples=10000, min_samples_leaf=9, min_samples_split=5, n_estimators=60;, score=0.614 total time=   3.3s\n[CV 1/3] END max_depth=None, max_features=sqrt, max_samples=10000, min_samples_leaf=9, min_samples_split=8, n_estimators=130;, score=0.520 total time=   6.7s\n[CV 2/3] END max_depth=None, max_features=sqrt, max_samples=10000, min_samples_leaf=9, min_samples_split=8, n_estimators=130;, score=0.702 total time=   6.6s\n[CV 3/3] END max_depth=None, max_features=sqrt, max_samples=10000, min_samples_leaf=9, min_samples_split=8, n_estimators=130;, score=0.636 total time=   6.6s\n[CV 1/3] END max_depth=20, max_features=sqrt, max_samples=10000, min_samples_leaf=8, min_samples_split=9, n_estimators=30;, score=0.512 total time=   3.0s\n[CV 2/3] END max_depth=20, max_features=sqrt, max_samples=10000, min_samples_leaf=8, min_samples_split=9, n_estimators=30;, score=0.703 total time=   2.7s\n[CV 3/3] END max_depth=20, max_features=sqrt, max_samples=10000, min_samples_leaf=8, min_samples_split=9, n_estimators=30;, score=0.636 total time=   2.7s\n[CV 1/3] END max_depth=None, max_features=0.5, max_samples=10000, min_samples_leaf=9, min_samples_split=3, n_estimators=100;, score=0.541 total time=   9.9s\n[CV 2/3] END max_depth=None, max_features=0.5, max_samples=10000, min_samples_leaf=9, min_samples_split=3, n_estimators=100;, score=0.745 total time=  11.1s\n[CV 3/3] END max_depth=None, max_features=0.5, max_samples=10000, min_samples_leaf=9, min_samples_split=3, n_estimators=100;, score=0.632 total time=  10.2s\n[CV 1/3] END max_depth=10, max_features=0.5, max_samples=10000, min_samples_leaf=3, min_samples_split=8, n_estimators=50;, score=0.529 total time=   6.1s\n[CV 2/3] END max_depth=10, max_features=0.5, max_samples=10000, min_samples_leaf=3, min_samples_split=8, n_estimators=50;, score=0.713 total time=   5.5s\n[CV 3/3] END max_depth=10, max_features=0.5, max_samples=10000, min_samples_leaf=3, min_samples_split=8, n_estimators=50;, score=0.625 total time=   5.2s\n[CV 1/3] END max_depth=10, max_features=0.5, max_samples=10000, min_samples_leaf=4, min_samples_split=6, n_estimators=170;, score=0.532 total time=  13.9s\n[CV 2/3] END max_depth=10, max_features=0.5, max_samples=10000, min_samples_leaf=4, min_samples_split=6, n_estimators=170;, score=0.712 total time=  14.6s\n[CV 3/3] END max_depth=10, max_features=0.5, max_samples=10000, min_samples_leaf=4, min_samples_split=6, n_estimators=170;, score=0.631 total time=  14.2s\n[CV 1/3] END max_depth=20, max_features=0.5, max_samples=10000, min_samples_leaf=1, min_samples_split=5, n_estimators=40;, score=0.545 total time=   6.6s\n[CV 2/3] END max_depth=20, max_features=0.5, max_samples=10000, min_samples_leaf=1, min_samples_split=5, n_estimators=40;, score=0.767 total time=   6.5s\n[CV 3/3] END max_depth=20, max_features=0.5, max_samples=10000, min_samples_leaf=1, min_samples_split=5, n_estimators=40;, score=0.619 total time=   6.2s\n[CV 1/3] END max_depth=None, max_features=sqrt, max_samples=10000, min_samples_leaf=9, min_samples_split=5, n_estimators=120;, score=0.518 total time=   6.0s\n[CV 2/3] END max_depth=None, max_features=sqrt, max_samples=10000, min_samples_leaf=9, min_samples_split=5, n_estimators=120;, score=0.703 total time=   6.4s\n[CV 3/3] END max_depth=None, max_features=sqrt, max_samples=10000, min_samples_leaf=9, min_samples_split=5, n_estimators=120;, score=0.637 total time=   6.2s\n[CV 1/3] END max_depth=10, max_features=0.5, max_samples=10000, min_samples_leaf=9, min_samples_split=9, n_estimators=120;, score=0.533 total time=  10.7s\n[CV 2/3] END max_depth=10, max_features=0.5, max_samples=10000, min_samples_leaf=9, min_samples_split=9, n_estimators=120;, score=0.708 total time=  13.7s\n[CV 3/3] END max_depth=10, max_features=0.5, max_samples=10000, min_samples_leaf=9, min_samples_split=9, n_estimators=120;, score=0.628 total time=  10.5s\n[CV 1/3] END max_depth=20, max_features=1.0, max_samples=10000, min_samples_leaf=2, min_samples_split=7, n_estimators=90;, score=0.542 total time=  20.0s\n[CV 2/3] END max_depth=20, max_features=1.0, max_samples=10000, min_samples_leaf=2, min_samples_split=7, n_estimators=90;, score=0.756 total time=  19.9s\n[CV 3/3] END max_depth=20, max_features=1.0, max_samples=10000, min_samples_leaf=2, min_samples_split=7, n_estimators=90;, score=0.611 total time=  17.1s\n[CV 1/3] END max_depth=None, max_features=sqrt, max_samples=10000, min_samples_leaf=8, min_samples_split=8, n_estimators=190;, score=0.524 total time=   9.1s\n[CV 2/3] END max_depth=None, max_features=sqrt, max_samples=10000, min_samples_leaf=8, min_samples_split=8, n_estimators=190;, score=0.706 total time=   8.7s\n[CV 3/3] END max_depth=None, max_features=sqrt, max_samples=10000, min_samples_leaf=8, min_samples_split=8, n_estimators=190;, score=0.637 total time=   8.6s\n[CV 1/3] END max_depth=None, max_features=1.0, max_samples=10000, min_samples_leaf=5, min_samples_split=8, n_estimators=70;, score=0.539 total time=  16.0s\n[CV 2/3] END max_depth=None, max_features=1.0, max_samples=10000, min_samples_leaf=5, min_samples_split=8, n_estimators=70;, score=0.754 total time=  14.8s\n[CV 3/3] END max_depth=None, max_features=1.0, max_samples=10000, min_samples_leaf=5, min_samples_split=8, n_estimators=70;, score=0.615 total time=  14.2s\n[CV 1/3] END max_depth=None, max_features=0.5, max_samples=10000, min_samples_leaf=1, min_samples_split=9, n_estimators=60;, score=0.548 total time=   9.3s\n[CV 2/3] END max_depth=None, max_features=0.5, max_samples=10000, min_samples_leaf=1, min_samples_split=9, n_estimators=60;, score=0.766 total time=   8.6s\n[CV 3/3] END max_depth=None, max_features=0.5, max_samples=10000, min_samples_leaf=1, min_samples_split=9, n_estimators=60;, score=0.623 total time=   9.0s\n[CV 1/3] END max_depth=10, max_features=1.0, max_samples=10000, min_samples_leaf=9, min_samples_split=5, n_estimators=170;, score=0.535 total time=  23.8s\n[CV 2/3] END max_depth=10, max_features=1.0, max_samples=10000, min_samples_leaf=9, min_samples_split=5, n_estimators=170;, score=0.715 total time=  25.5s\n[CV 3/3] END max_depth=10, max_features=1.0, max_samples=10000, min_samples_leaf=9, min_samples_split=5, n_estimators=170;, score=0.595 total time=  27.2s\n[CV 1/3] END max_depth=20, max_features=0.5, max_samples=10000, min_samples_leaf=2, min_samples_split=3, n_estimators=80;, score=0.544 total time=  12.0s\n[CV 2/3] END max_depth=20, max_features=0.5, max_samples=10000, min_samples_leaf=2, min_samples_split=3, n_estimators=80;, score=0.764 total time=  11.5s\n[CV 3/3] END max_depth=20, max_features=0.5, max_samples=10000, min_samples_leaf=2, min_samples_split=3, n_estimators=80;, score=0.642 total time=  10.4s\n[CV 1/3] END max_depth=None, max_features=0.5, max_samples=10000, min_samples_leaf=6, min_samples_split=7, n_estimators=70;, score=0.538 total time=   8.2s\n[CV 2/3] END max_depth=None, max_features=0.5, max_samples=10000, min_samples_leaf=6, min_samples_split=7, n_estimators=70;, score=0.752 total time=   8.4s\n[CV 3/3] END max_depth=None, max_features=0.5, max_samples=10000, min_samples_leaf=6, min_samples_split=7, n_estimators=70;, score=0.640 total time=   8.5s\n[CV 1/3] END max_depth=None, max_features=0.5, max_samples=10000, min_samples_leaf=9, min_samples_split=5, n_estimators=90;, score=0.537 total time=   9.8s\n[CV 2/3] END max_depth=None, max_features=0.5, max_samples=10000, min_samples_leaf=9, min_samples_split=5, n_estimators=90;, score=0.747 total time=   9.5s\n[CV 3/3] END max_depth=None, max_features=0.5, max_samples=10000, min_samples_leaf=9, min_samples_split=5, n_estimators=90;, score=0.630 total time=   9.7s\n[CV 1/3] END max_depth=10, max_features=1.0, max_samples=10000, min_samples_leaf=2, min_samples_split=8, n_estimators=180;, score=0.536 total time=  28.3s\n[CV 2/3] END max_depth=10, max_features=1.0, max_samples=10000, min_samples_leaf=2, min_samples_split=8, n_estimators=180;, score=0.721 total time=  28.6s\n[CV 3/3] END max_depth=10, max_features=1.0, max_samples=10000, min_samples_leaf=2, min_samples_split=8, n_estimators=180;, score=0.597 total time=  28.1s\n[CV 1/3] END max_depth=None, max_features=sqrt, max_samples=10000, min_samples_leaf=2, min_samples_split=3, n_estimators=150;, score=0.539 total time=   9.0s\n[CV 2/3] END max_depth=None, max_features=sqrt, max_samples=10000, min_samples_leaf=2, min_samples_split=3, n_estimators=150;, score=0.733 total time=  10.7s\n[CV 3/3] END max_depth=None, max_features=sqrt, max_samples=10000, min_samples_leaf=2, min_samples_split=3, n_estimators=150;, score=0.643 total time=   8.9s\nCPU times: user 8min 6s, sys: 25min 58s, total: 34min 4s\nWall time: 11min 54s\n</pre> Out[97]: <pre>RandomizedSearchCV(cv=3, estimator=RandomForestRegressor(), n_iter=20,\n                   param_distributions={'max_depth': [None, 10, 20],\n                                        'max_features': [0.5, 1.0, 'sqrt'],\n                                        'max_samples': [10000],\n                                        'min_samples_leaf': array([1, 2, 3, 4, 5, 6, 7, 8, 9]),\n                                        'min_samples_split': array([2, 3, 4, 5, 6, 7, 8, 9]),\n                                        'n_estimators': array([ 10,  20,  30,  40,  50,  60,  70,  80,  90, 100, 110, 120, 130,\n       140, 150, 160, 170, 180, 190])},\n                   verbose=3)</pre>In a Jupyter environment, please rerun this cell to show the HTML representation or trust the notebook. On GitHub, the HTML representation is unable to render, please try loading this page with nbviewer.org.\u00a0\u00a0RandomizedSearchCV?Documentation for RandomizedSearchCViFitted<pre>RandomizedSearchCV(cv=3, estimator=RandomForestRegressor(), n_iter=20,\n                   param_distributions={'max_depth': [None, 10, 20],\n                                        'max_features': [0.5, 1.0, 'sqrt'],\n                                        'max_samples': [10000],\n                                        'min_samples_leaf': array([1, 2, 3, 4, 5, 6, 7, 8, 9]),\n                                        'min_samples_split': array([2, 3, 4, 5, 6, 7, 8, 9]),\n                                        'n_estimators': array([ 10,  20,  30,  40,  50,  60,  70,  80,  90, 100, 110, 120, 130,\n       140, 150, 160, 170, 180, 190])},\n                   verbose=3)</pre> best_estimator_: RandomForestRegressor<pre>RandomForestRegressor(max_depth=20, max_features=0.5, max_samples=10000,\n                      min_samples_leaf=np.int64(2),\n                      min_samples_split=np.int64(3), n_estimators=np.int64(80))</pre> \u00a0RandomForestRegressor?Documentation for RandomForestRegressor<pre>RandomForestRegressor(max_depth=20, max_features=0.5, max_samples=10000,\n                      min_samples_leaf=np.int64(2),\n                      min_samples_split=np.int64(3), n_estimators=np.int64(80))</pre> <p>Phew! That's quite a bit of testing!</p> <p>Good news for us is that we can check the best hyperparameters with the <code>best_params_</code> attribute.</p> In\u00a0[113]: Copied! <pre># Find the best parameters from RandomizedSearchCV\nrs_model.best_params_\n</pre> # Find the best parameters from RandomizedSearchCV rs_model.best_params_ Out[113]: <pre>{'n_estimators': np.int64(80),\n 'min_samples_split': np.int64(3),\n 'min_samples_leaf': np.int64(2),\n 'max_samples': 10000,\n 'max_features': 0.5,\n 'max_depth': 20}</pre> <p>And we can evaluate this model with our <code>show_scores</code> function.</p> In\u00a0[114]: Copied! <pre># Evaluate the RandomizedSearch model\nrs_model_scores = show_scores(rs_model)\nrs_model_scores\n</pre> # Evaluate the RandomizedSearch model rs_model_scores = show_scores(rs_model) rs_model_scores Out[114]: <pre>{'Training MAE': np.float64(5804.886346446167),\n 'Valid MAE': np.float64(7271.010705137403),\n 'Training RMSLE': np.float64(0.2668477962708691),\n 'Valid RMSLE': np.float64(0.2985683128197976),\n 'Training R^2': 0.8494436266937344,\n 'Valid R^2': 0.8280568050158131}</pre> In\u00a0[115]: Copied! <pre>%%time\n\n# Create a model with best found hyperparameters \n# Note: There may be better values out there with longer searches but these are \n# the best I found with a ~2 hour search. A good challenge would be to see if you \n# can find better values.\nideal_model = RandomForestRegressor(n_estimators=90,\n                                    max_depth=None,\n                                    min_samples_leaf=1,\n                                    min_samples_split=5,\n                                    max_features=0.5,\n                                    n_jobs=-1,\n                                    max_samples=None)\n\n# Fit a model to the preprocessed data\nideal_model.fit(X=X_train_preprocessed, \n                y=y_train)\n</pre> %%time  # Create a model with best found hyperparameters  # Note: There may be better values out there with longer searches but these are  # the best I found with a ~2 hour search. A good challenge would be to see if you  # can find better values. ideal_model = RandomForestRegressor(n_estimators=90,                                     max_depth=None,                                     min_samples_leaf=1,                                     min_samples_split=5,                                     max_features=0.5,                                     n_jobs=-1,                                     max_samples=None)  # Fit a model to the preprocessed data ideal_model.fit(X=X_train_preprocessed,                  y=y_train) <pre>CPU times: user 4min 6s, sys: 4min 34s, total: 8min 40s\nWall time: 2min\n</pre> Out[115]: <pre>RandomForestRegressor(max_features=0.5, min_samples_split=5, n_estimators=90,\n                      n_jobs=-1)</pre>In a Jupyter environment, please rerun this cell to show the HTML representation or trust the notebook. On GitHub, the HTML representation is unable to render, please try loading this page with nbviewer.org.\u00a0\u00a0RandomForestRegressor?Documentation for RandomForestRegressoriFitted<pre>RandomForestRegressor(max_features=0.5, min_samples_split=5, n_estimators=90,\n                      n_jobs=-1)</pre> <p>And of course, we can evaluate our <code>ideal_model</code> with our <code>show_scores</code> function.</p> In\u00a0[116]: Copied! <pre>%%time\n\n# Evaluate ideal model\nideal_model_scores = show_scores(model=ideal_model)\nideal_model_scores\n</pre> %%time  # Evaluate ideal model ideal_model_scores = show_scores(model=ideal_model) ideal_model_scores <pre>CPU times: user 28.8 s, sys: 37.4 s, total: 1min 6s\nWall time: 14.5 s\n</pre> Out[116]: <pre>{'Training MAE': np.float64(1955.980118634043),\n 'Valid MAE': np.float64(5979.47564414195),\n 'Training RMSLE': np.float64(0.10224456852444506),\n 'Valid RMSLE': np.float64(0.24733387014318542),\n 'Training R^2': 0.9809704227866279,\n 'Valid R^2': 0.8810497144604977}</pre> <p>Woohoo!</p> <p>With these new hyperparameters as well as using all the samples, we can see an improvement to our models performance.</p> <p>One thing to keep in mind is that a larger model isn't always the best for a given problem even if it performs better.</p> <p>For example, you may require a model that performs inference (makes predictions) very fast with a slight tradeoff to performance.</p> <p>One way to a faster model is by altering some of the hyperparameters to create a smaller overall model.</p> <p>Particularly by lowering <code>n_estimators</code> since each increase in <code>n_estimators</code> is basically building another small model.</p> <p>Let's half our <code>n_estimators</code> value and see how it goes.</p> In\u00a0[117]: Copied! <pre>%%time\n\n# Halve the number of estimators\nfast_model = RandomForestRegressor(n_estimators=45,\n                                   max_depth=None,\n                                   min_samples_leaf=1,\n                                   min_samples_split=5,\n                                   max_features=0.5,\n                                   n_jobs=-1,\n                                   max_samples=None)\n\n# Fit the faster model to the data\nfast_model.fit(X=X_train_preprocessed, \n               y=y_train)\n</pre> %%time  # Halve the number of estimators fast_model = RandomForestRegressor(n_estimators=45,                                    max_depth=None,                                    min_samples_leaf=1,                                    min_samples_split=5,                                    max_features=0.5,                                    n_jobs=-1,                                    max_samples=None)  # Fit the faster model to the data fast_model.fit(X=X_train_preprocessed,                 y=y_train) <pre>CPU times: user 2min, sys: 1min 58s, total: 3min 58s\nWall time: 44.9 s\n</pre> Out[117]: <pre>RandomForestRegressor(max_features=0.5, min_samples_split=5, n_estimators=45,\n                      n_jobs=-1)</pre>In a Jupyter environment, please rerun this cell to show the HTML representation or trust the notebook. On GitHub, the HTML representation is unable to render, please try loading this page with nbviewer.org.\u00a0\u00a0RandomForestRegressor?Documentation for RandomForestRegressoriFitted<pre>RandomForestRegressor(max_features=0.5, min_samples_split=5, n_estimators=45,\n                      n_jobs=-1)</pre> <p>Nice! The faster model fits to the training data in about half the time of the full model.</p> <p>Now how does it go on performance?</p> In\u00a0[118]: Copied! <pre>%%time\n\n# Get results from the fast model\nfast_model_scores = show_scores(model=fast_model)\nfast_model_scores\n</pre> %%time  # Get results from the fast model fast_model_scores = show_scores(model=fast_model) fast_model_scores <pre>CPU times: user 14.6 s, sys: 23.7 s, total: 38.3 s\nWall time: 9.59 s\n</pre> Out[118]: <pre>{'Training MAE': np.float64(1989.0544948757317),\n 'Valid MAE': np.float64(6029.137329100962),\n 'Training RMSLE': np.float64(0.10373049008046713),\n 'Valid RMSLE': np.float64(0.24897544966690316),\n 'Training R^2': 0.9802744452357592,\n 'Valid R^2': 0.8788749110488039}</pre> <p>Woah! Looks like our faster model evaluates (performs inference/makes predictions) in about half the time too.</p> <p>And only for a small tradeoff in validation RMSLE performance.</p> In\u00a0[119]: Copied! <pre># Add names of models to dictionaries\nbase_model_scores[\"model_name\"] = \"default_model\"\nrs_model_scores[\"model_name\"] = \"random_search_model\"\nideal_model_scores[\"model_name\"] = \"ideal_model\" \nfast_model_scores[\"model_name\"] = \"fast_model\" \n\n# Turn all model score dictionaries into a list\nall_model_scores = [base_model_scores, \n                    rs_model_scores, \n                    ideal_model_scores,\n                    fast_model_scores]\n\n# Create DataFrame and sort model scores by validation RMSLE\nmodel_comparison_df = pd.DataFrame(all_model_scores).sort_values(by=\"Valid RMSLE\", ascending=False)\nmodel_comparison_df.head()\n</pre> # Add names of models to dictionaries base_model_scores[\"model_name\"] = \"default_model\" rs_model_scores[\"model_name\"] = \"random_search_model\" ideal_model_scores[\"model_name\"] = \"ideal_model\"  fast_model_scores[\"model_name\"] = \"fast_model\"   # Turn all model score dictionaries into a list all_model_scores = [base_model_scores,                      rs_model_scores,                      ideal_model_scores,                     fast_model_scores]  # Create DataFrame and sort model scores by validation RMSLE model_comparison_df = pd.DataFrame(all_model_scores).sort_values(by=\"Valid RMSLE\", ascending=False) model_comparison_df.head() Out[119]: Training MAE Valid MAE Training RMSLE Valid RMSLE Training R^2 Valid R^2 model_name 1 5804.886346 7271.010705 0.266848 0.298568 0.849444 0.828057 random_search_model 0 5605.344206 7176.165115 0.260301 0.293584 0.858112 0.828550 default_model 3 1989.054495 6029.137329 0.103730 0.248975 0.980274 0.878875 fast_model 2 1955.980119 5979.475644 0.102245 0.247334 0.980970 0.881050 ideal_model <p>Now we've got our model result data in a DataFrame, let's turn it into a bar plot comparing the validation RMSLE of each model.</p> In\u00a0[120]: Copied! <pre># Get mean RSMLE score of all models\nmean_rsmle_score = model_comparison_df[\"Valid RMSLE\"].mean()\n\n# Plot validation RMSLE against each other \nplt.figure(figsize=(10, 5))\nplt.bar(x=model_comparison_df[\"model_name\"],\n        height=model_comparison_df[\"Valid RMSLE\"].values)\nplt.xlabel(\"Model\")\nplt.ylabel(\"Validation RMSLE (lower is better)\")\nplt.xticks(rotation=0, fontsize=10);\nplt.axhline(y=mean_rsmle_score, \n            color=\"red\", \n            linestyle=\"--\", \n            label=f\"Mean RMSLE: {mean_rsmle_score:.4f}\")\nplt.legend();\n</pre> # Get mean RSMLE score of all models mean_rsmle_score = model_comparison_df[\"Valid RMSLE\"].mean()  # Plot validation RMSLE against each other  plt.figure(figsize=(10, 5)) plt.bar(x=model_comparison_df[\"model_name\"],         height=model_comparison_df[\"Valid RMSLE\"].values) plt.xlabel(\"Model\") plt.ylabel(\"Validation RMSLE (lower is better)\") plt.xticks(rotation=0, fontsize=10); plt.axhline(y=mean_rsmle_score,              color=\"red\",              linestyle=\"--\",              label=f\"Mean RMSLE: {mean_rsmle_score:.4f}\") plt.legend(); <p>By the looks of the plot, our <code>ideal_model</code> is indeed the ideal model, slightly edging out <code>fast_model</code> in terms of validation RMSLE.</p> In\u00a0[121]: Copied! <pre>import joblib\n\nbulldozer_price_prediction_model_name = \"randomforest_regressor_best_RMSLE.pkl\"\n\n# Save model to file\njoblib.dump(value=ideal_model, \n            filename=bulldozer_price_prediction_model_name)\n</pre> import joblib  bulldozer_price_prediction_model_name = \"randomforest_regressor_best_RMSLE.pkl\"  # Save model to file joblib.dump(value=ideal_model,              filename=bulldozer_price_prediction_model_name) Out[121]: <pre>['randomforest_regressor_best_RMSLE.pkl']</pre> <p>And to load our model we can use the <code>joblib.load</code> method.</p> In\u00a0[122]: Copied! <pre># Load the best model\nbest_model = joblib.load(filename=bulldozer_price_prediction_model_name)\nbest_model\n</pre> # Load the best model best_model = joblib.load(filename=bulldozer_price_prediction_model_name) best_model Out[122]: <pre>RandomForestRegressor(max_features=0.5, min_samples_split=5, n_estimators=90,\n                      n_jobs=-1)</pre>In a Jupyter environment, please rerun this cell to show the HTML representation or trust the notebook. On GitHub, the HTML representation is unable to render, please try loading this page with nbviewer.org.\u00a0\u00a0RandomForestRegressor?Documentation for RandomForestRegressoriFitted<pre>RandomForestRegressor(max_features=0.5, min_samples_split=5, n_estimators=90,\n                      n_jobs=-1)</pre> <p>We can make sure our model saving and loading worked by evaluating our <code>best_model</code> with <code>show_scores</code>.</p> In\u00a0[123]: Copied! <pre># Confirm that the model works\nbest_model_scores = show_scores(model=best_model)\nbest_model_scores\n</pre> # Confirm that the model works best_model_scores = show_scores(model=best_model) best_model_scores Out[123]: <pre>{'Training MAE': np.float64(1955.9801186340424),\n 'Valid MAE': np.float64(5979.47564414195),\n 'Training RMSLE': np.float64(0.10224456852444506),\n 'Valid RMSLE': np.float64(0.24733387014318542),\n 'Training R^2': 0.9809704227866279,\n 'Valid R^2': 0.8810497144604977}</pre> <p>And to confirm our <code>ideal_model</code> and <code>best_model</code> results are very close (if not the exact same), we can compare them with:</p> <ul> <li>The equality operator <code>==</code>.</li> <li><code>np.iclose</code> and setting the absolute tolerance (<code>atol</code>) to <code>1e-4</code>.</li> </ul> In\u00a0[124]: Copied! <pre># See if loaded model and pre-saved model results are the same\n# Note: these values may be very slightly different depending on how precise your computer stores values.\nbest_model_scores[\"Valid RMSLE\"] == ideal_model_scores[\"Valid RMSLE\"]\n</pre> # See if loaded model and pre-saved model results are the same # Note: these values may be very slightly different depending on how precise your computer stores values. best_model_scores[\"Valid RMSLE\"] == ideal_model_scores[\"Valid RMSLE\"] Out[124]: <pre>np.True_</pre> In\u00a0[125]: Copied! <pre># Is the loaded model as good as the non-loaded model?\nif np.isclose(a=best_model_scores[\"Valid RMSLE\"], \n              b=ideal_model_scores[\"Valid RMSLE\"],\n              atol=1e-4): # Make sure values are within 0.0001 of each other\n    print(f\"[INFO] Model results are close!\")\nelse:\n    print(f\"[INFO] Model results aren't close, did something go wrong?\")\n</pre> # Is the loaded model as good as the non-loaded model? if np.isclose(a=best_model_scores[\"Valid RMSLE\"],                b=ideal_model_scores[\"Valid RMSLE\"],               atol=1e-4): # Make sure values are within 0.0001 of each other     print(f\"[INFO] Model results are close!\") else:     print(f\"[INFO] Model results aren't close, did something go wrong?\") <pre>[INFO] Model results are close!\n</pre> <p>Note: When saving and loading a model, it is often the case to have very slightly different values at the extremes. For example, the pre-saved model may have an RMSLE of <code>0.24654150224930685</code> where as the loaded model may have an RMSLE of <code>0.24654150224930684</code> where in this case the values are off by <code>0.00000000000000001</code> (a very small number). This is due to the precision of computing) and the way computers store values, where numbers are exact but can be represented up to a certain amount of precision. This is why we generally compare results with many decimals using <code>np.isclose</code> rather than the <code>==</code> operator.</p> In\u00a0[126]: Copied! <pre># Load the test data\ntest_df = pd.read_csv(filepath_or_buffer=\"../data/bluebook-for-bulldozers/Test.csv\",\n                      parse_dates=[\"saledate\"])\ntest_df.head()\n</pre> # Load the test data test_df = pd.read_csv(filepath_or_buffer=\"../data/bluebook-for-bulldozers/Test.csv\",                       parse_dates=[\"saledate\"]) test_df.head() Out[126]: SalesID MachineID ModelID datasource auctioneerID YearMade MachineHoursCurrentMeter UsageBand saledate fiModelDesc ... Undercarriage_Pad_Width Stick_Length Thumb Pattern_Changer Grouser_Type Backhoe_Mounting Blade_Type Travel_Controls Differential_Type Steering_Controls 0 1227829 1006309 3168 121 3 1999 3688.0 Low 2012-05-03 580G ... NaN NaN NaN NaN NaN NaN NaN NaN NaN NaN 1 1227844 1022817 7271 121 3 1000 28555.0 High 2012-05-10 936 ... NaN NaN NaN NaN NaN NaN NaN NaN Standard Conventional 2 1227847 1031560 22805 121 3 2004 6038.0 Medium 2012-05-10 EC210BLC ... None or Unspecified 9' 6\" Manual None or Unspecified Double NaN NaN NaN NaN NaN 3 1227848 56204 1269 121 3 2006 8940.0 High 2012-05-10 330CL ... None or Unspecified None or Unspecified Manual Yes Triple NaN NaN NaN NaN NaN 4 1227863 1053887 22312 121 3 2005 2286.0 Low 2012-05-10 650K ... NaN NaN NaN NaN NaN None or Unspecified PAT None or Unspecified NaN NaN <p>5 rows \u00d7 52 columns</p> <p>You might notice that the <code>test_df</code> is missing the <code>SalePrice</code> column.</p> <p>That's because that's the variable we're trying to predict based on all of the other variables.</p> <p>We can make predictions with our <code>best_model</code> using the <code>predict</code> method.</p> In\u00a0[127]: Copied! <pre># Let's see how the model goes predicting on the test data\ntest_preds = best_model.predict(X=test_df)\n</pre> # Let's see how the model goes predicting on the test data test_preds = best_model.predict(X=test_df) <pre>\n---------------------------------------------------------------------------\nValueError                                Traceback (most recent call last)\nCell In[127], line 2\n      1 # Let's see how the model goes predicting on the test data\n----&gt; 2 test_preds = best_model.predict(X=test_df)\n\nFile ~/miniforge3/envs/ai/lib/python3.11/site-packages/sklearn/ensemble/_forest.py:1063, in ForestRegressor.predict(self, X)\n   1061 check_is_fitted(self)\n   1062 # Check data\n-&gt; 1063 X = self._validate_X_predict(X)\n   1065 # Assign chunk of trees to jobs\n   1066 n_jobs, _, _ = _partition_estimators(self.n_estimators, self.n_jobs)\n\nFile ~/miniforge3/envs/ai/lib/python3.11/site-packages/sklearn/ensemble/_forest.py:641, in BaseForest._validate_X_predict(self, X)\n    638 else:\n    639     force_all_finite = True\n--&gt; 641 X = self._validate_data(\n    642     X,\n    643     dtype=DTYPE,\n    644     accept_sparse=\"csr\",\n    645     reset=False,\n    646     force_all_finite=force_all_finite,\n    647 )\n    648 if issparse(X) and (X.indices.dtype != np.intc or X.indptr.dtype != np.intc):\n    649     raise ValueError(\"No support for np.int64 index based sparse matrices\")\n\nFile ~/miniforge3/envs/ai/lib/python3.11/site-packages/sklearn/base.py:608, in BaseEstimator._validate_data(self, X, y, reset, validate_separately, cast_to_ndarray, **check_params)\n    537 def _validate_data(\n    538     self,\n    539     X=\"no_validation\",\n   (...)\n    544     **check_params,\n    545 ):\n    546     \"\"\"Validate input data and set or check the `n_features_in_` attribute.\n    547 \n    548     Parameters\n   (...)\n    606         validated.\n    607     \"\"\"\n--&gt; 608     self._check_feature_names(X, reset=reset)\n    610     if y is None and self._get_tags()[\"requires_y\"]:\n    611         raise ValueError(\n    612             f\"This {self.__class__.__name__} estimator \"\n    613             \"requires y to be passed, but the target y is None.\"\n    614         )\n\nFile ~/miniforge3/envs/ai/lib/python3.11/site-packages/sklearn/base.py:535, in BaseEstimator._check_feature_names(self, X, reset)\n    530 if not missing_names and not unexpected_names:\n    531     message += (\n    532         \"Feature names must be in the same order as they were in fit.\\n\"\n    533     )\n--&gt; 535 raise ValueError(message)\n\nValueError: The feature names should match those that were passed during fit.\nFeature names unseen at fit time:\n- saledate\nFeature names seen at fit time, yet now missing:\n- saleDay\n- saleDayofweek\n- saleDayofyear\n- saleMonth\n- saleYear\n</pre> <p>Oh no!</p> <p>We get an error:</p> <p>ValueError: The feature names should match those that were passed during fit. Feature names unseen at fit time:</p> <ul> <li>saledate Feature names seen at fit time, yet now missing:</li> <li>saleDay</li> <li>saleDayofweek</li> <li>saleDayofyear</li> <li>saleMonth</li> <li>saleYear</li> </ul> <p>Ahhh... the test data isn't in the same format of our other data, so we have to fix it.</p> In\u00a0[128]: Copied! <pre># Make a function to add date columns\ndef add_datetime_features_to_df(df, date_column=\"saledate\"):\n    # Add datetime parameters for saledate\n    df[\"saleYear\"] = df[date_column].dt.year\n    df[\"saleMonth\"] = df[date_column].dt.month\n    df[\"saleDay\"] = df[date_column].dt.day\n    df[\"saleDayofweek\"] = df[date_column].dt.dayofweek\n    df[\"saleDayofyear\"] = df[date_column].dt.dayofyear\n\n    # Drop original saledate column\n    df.drop(\"saledate\", axis=1, inplace=True)\n\n    return df\n\n# Preprocess test_df to have same columns as train_df (add the datetime features)\ntest_df = add_datetime_features_to_df(df=test_df)\ntest_df.head()\n</pre> # Make a function to add date columns def add_datetime_features_to_df(df, date_column=\"saledate\"):     # Add datetime parameters for saledate     df[\"saleYear\"] = df[date_column].dt.year     df[\"saleMonth\"] = df[date_column].dt.month     df[\"saleDay\"] = df[date_column].dt.day     df[\"saleDayofweek\"] = df[date_column].dt.dayofweek     df[\"saleDayofyear\"] = df[date_column].dt.dayofyear      # Drop original saledate column     df.drop(\"saledate\", axis=1, inplace=True)      return df  # Preprocess test_df to have same columns as train_df (add the datetime features) test_df = add_datetime_features_to_df(df=test_df) test_df.head() Out[128]: SalesID MachineID ModelID datasource auctioneerID YearMade MachineHoursCurrentMeter UsageBand fiModelDesc fiBaseModel ... Backhoe_Mounting Blade_Type Travel_Controls Differential_Type Steering_Controls saleYear saleMonth saleDay saleDayofweek saleDayofyear 0 1227829 1006309 3168 121 3 1999 3688.0 Low 580G 580 ... NaN NaN NaN NaN NaN 2012 5 3 3 124 1 1227844 1022817 7271 121 3 1000 28555.0 High 936 936 ... NaN NaN NaN Standard Conventional 2012 5 10 3 131 2 1227847 1031560 22805 121 3 2004 6038.0 Medium EC210BLC EC210 ... NaN NaN NaN NaN NaN 2012 5 10 3 131 3 1227848 56204 1269 121 3 2006 8940.0 High 330CL 330 ... NaN NaN NaN NaN NaN 2012 5 10 3 131 4 1227863 1053887 22312 121 3 2005 2286.0 Low 650K 650 ... None or Unspecified PAT None or Unspecified NaN NaN 2012 5 10 3 131 <p>5 rows \u00d7 56 columns</p> <p>Date features added!</p> <p>Now can we make predictions with our model on the test data?</p> In\u00a0[129]: Copied! <pre># Try to predict with model\ntest_preds = best_model.predict(test_df)\n</pre> # Try to predict with model test_preds = best_model.predict(test_df) <pre>\n---------------------------------------------------------------------------\nValueError                                Traceback (most recent call last)\n/var/folders/c4/qj4gdk190td18bqvjjh0p3p00000gn/T/ipykernel_20423/2042912174.py in ?()\n      1 # Try to predict with model\n----&gt; 2 test_preds = best_model.predict(test_df)\n\n~/miniforge3/envs/ai/lib/python3.11/site-packages/sklearn/ensemble/_forest.py in ?(self, X)\n   1059             The predicted values.\n   1060         \"\"\"\n   1061         check_is_fitted(self)\n   1062         # Check data\n-&gt; 1063         X = self._validate_X_predict(X)\n   1064 \n   1065         # Assign chunk of trees to jobs\n   1066         n_jobs, _, _ = _partition_estimators(self.n_estimators, self.n_jobs)\n\n~/miniforge3/envs/ai/lib/python3.11/site-packages/sklearn/ensemble/_forest.py in ?(self, X)\n    637             force_all_finite = \"allow-nan\"\n    638         else:\n    639             force_all_finite = True\n    640 \n--&gt; 641         X = self._validate_data(\n    642             X,\n    643             dtype=DTYPE,\n    644             accept_sparse=\"csr\",\n\n~/miniforge3/envs/ai/lib/python3.11/site-packages/sklearn/base.py in ?(self, X, y, reset, validate_separately, cast_to_ndarray, **check_params)\n    629                 out = y\n    630             else:\n    631                 out = X, y\n    632         elif not no_val_X and no_val_y:\n--&gt; 633             out = check_array(X, input_name=\"X\", **check_params)\n    634         elif no_val_X and not no_val_y:\n    635             out = _check_y(y, **check_params)\n    636         else:\n\n~/miniforge3/envs/ai/lib/python3.11/site-packages/sklearn/utils/validation.py in ?(array, accept_sparse, accept_large_sparse, dtype, order, copy, force_writeable, force_all_finite, ensure_2d, allow_nd, ensure_min_samples, ensure_min_features, estimator, input_name)\n   1009                         )\n   1010                     array = xp.astype(array, dtype, copy=False)\n   1011                 else:\n   1012                     array = _asarray_with_order(array, order=order, dtype=dtype, xp=xp)\n-&gt; 1013             except ComplexWarning as complex_warning:\n   1014                 raise ValueError(\n   1015                     \"Complex data not supported\\n{}\\n\".format(array)\n   1016                 ) from complex_warning\n\n~/miniforge3/envs/ai/lib/python3.11/site-packages/sklearn/utils/_array_api.py in ?(array, dtype, order, copy, xp, device)\n    747         # Use NumPy API to support order\n    748         if copy is True:\n    749             array = numpy.array(array, order=order, dtype=dtype)\n    750         else:\n--&gt; 751             array = numpy.asarray(array, order=order, dtype=dtype)\n    752 \n    753         # At this point array is a NumPy ndarray. We convert it to an array\n    754         # container that is consistent with the input's namespace.\n\n~/miniforge3/envs/ai/lib/python3.11/site-packages/pandas/core/generic.py in ?(self, dtype, copy)\n   2149     def __array__(\n   2150         self, dtype: npt.DTypeLike | None = None, copy: bool_t | None = None\n   2151     ) -&gt; np.ndarray:\n   2152         values = self._values\n-&gt; 2153         arr = np.asarray(values, dtype=dtype)\n   2154         if (\n   2155             astype_is_view(values.dtype, arr.dtype)\n   2156             and using_copy_on_write()\n\nValueError: could not convert string to float: 'Low'</pre> <p>Another error...</p> <p>ValueError: could not convert string to float: 'Low'</p> <p>We can fix this by running our <code>ordinal_encoder</code> (that we used to preprocess the training data) on the categorical features in our test DataFrame.</p> In\u00a0[130]: Copied! <pre># Create a copy of the test DataFrame to keep the original intact\ntest_df_preprocessed = test_df.copy()\n\n# Transform the categorical features of the test DataFrame into numbers\ntest_df_preprocessed[categorical_features] = ordinal_encoder.transform(test_df_preprocessed[categorical_features].astype(str))\ntest_df_preprocessed.info()\n</pre> # Create a copy of the test DataFrame to keep the original intact test_df_preprocessed = test_df.copy()  # Transform the categorical features of the test DataFrame into numbers test_df_preprocessed[categorical_features] = ordinal_encoder.transform(test_df_preprocessed[categorical_features].astype(str)) test_df_preprocessed.info() <pre>&lt;class 'pandas.core.frame.DataFrame'&gt;\nRangeIndex: 12457 entries, 0 to 12456\nData columns (total 56 columns):\n #   Column                    Non-Null Count  Dtype  \n---  ------                    --------------  -----  \n 0   SalesID                   12457 non-null  int64  \n 1   MachineID                 12457 non-null  int64  \n 2   ModelID                   12457 non-null  int64  \n 3   datasource                12457 non-null  int64  \n 4   auctioneerID              12457 non-null  int64  \n 5   YearMade                  12457 non-null  int64  \n 6   MachineHoursCurrentMeter  2129 non-null   float64\n 7   UsageBand                 12457 non-null  float64\n 8   fiModelDesc               12349 non-null  float64\n 9   fiBaseModel               12431 non-null  float64\n 10  fiSecondaryDesc           12449 non-null  float64\n 11  fiModelSeries             12456 non-null  float64\n 12  fiModelDescriptor         12452 non-null  float64\n 13  ProductSize               12457 non-null  float64\n 14  fiProductClassDesc        12457 non-null  float64\n 15  state                     12457 non-null  float64\n 16  ProductGroup              12457 non-null  float64\n 17  ProductGroupDesc          12457 non-null  float64\n 18  Drive_System              12457 non-null  float64\n 19  Enclosure                 12457 non-null  float64\n 20  Forks                     12457 non-null  float64\n 21  Pad_Type                  12457 non-null  float64\n 22  Ride_Control              12457 non-null  float64\n 23  Stick                     12457 non-null  float64\n 24  Transmission              12457 non-null  float64\n 25  Turbocharged              12457 non-null  float64\n 26  Blade_Extension           12457 non-null  float64\n 27  Blade_Width               12457 non-null  float64\n 28  Enclosure_Type            12457 non-null  float64\n 29  Engine_Horsepower         12457 non-null  float64\n 30  Hydraulics                12457 non-null  float64\n 31  Pushblock                 12457 non-null  float64\n 32  Ripper                    12457 non-null  float64\n 33  Scarifier                 12457 non-null  float64\n 34  Tip_Control               12457 non-null  float64\n 35  Tire_Size                 12457 non-null  float64\n 36  Coupler                   12457 non-null  float64\n 37  Coupler_System            12457 non-null  float64\n 38  Grouser_Tracks            12457 non-null  float64\n 39  Hydraulics_Flow           12457 non-null  float64\n 40  Track_Type                12457 non-null  float64\n 41  Undercarriage_Pad_Width   12457 non-null  float64\n 42  Stick_Length              12457 non-null  float64\n 43  Thumb                     12457 non-null  float64\n 44  Pattern_Changer           12457 non-null  float64\n 45  Grouser_Type              12457 non-null  float64\n 46  Backhoe_Mounting          12457 non-null  float64\n 47  Blade_Type                12457 non-null  float64\n 48  Travel_Controls           12457 non-null  float64\n 49  Differential_Type         12457 non-null  float64\n 50  Steering_Controls         12457 non-null  float64\n 51  saleYear                  12457 non-null  int32  \n 52  saleMonth                 12457 non-null  int32  \n 53  saleDay                   12457 non-null  int32  \n 54  saleDayofweek             12457 non-null  int32  \n 55  saleDayofyear             12457 non-null  int32  \ndtypes: float64(45), int32(5), int64(6)\nmemory usage: 5.1 MB\n</pre> <p>Ok, date features created and categorical features turned into numbers, can we make predictions on the test data now?</p> In\u00a0[131]: Copied! <pre># Make predictions on the preprocessed test data\ntest_preds = best_model.predict(test_df_preprocessed)\n</pre> # Make predictions on the preprocessed test data test_preds = best_model.predict(test_df_preprocessed) <p>Holy smokes! It worked!</p> <p>Let's check out our <code>test_preds</code>.</p> In\u00a0[132]: Copied! <pre># Check the first 10 test predictions\ntest_preds[:10]\n</pre> # Check the first 10 test predictions test_preds[:10] Out[132]: <pre>array([14384.79497354, 31377.65862841, 48589.23540965, 95857.57194966,\n       26910.53992304, 29401.41534392, 27061.53819945, 20377.23364598,\n       17325.67857143, 33646.67768959])</pre> <p>Wonderful, looks like we're getting the price predictions of a given bulldozer.</p> <p>How many predictions are there?</p> In\u00a0[133]: Copied! <pre># Check number of test predictions\ntest_preds.shape, test_df.shape\n</pre> # Check number of test predictions test_preds.shape, test_df.shape Out[133]: <pre>((12457,), (12457, 56))</pre> <p>Perfect, looks like theres one prediction per sample in the test DataFrame.</p> <p>Now how would we submit our predictions to Kaggle?</p> <p>Well, when looking at the Kaggle submission requirements, we see that if we wanted to make a submission, the data is required to be in a certain format.</p> <p>Namely, a DataFrame containing the <code>SalesID</code> and the predicted <code>SalePrice</code> of the bulldozer.</p> <p>Let's make it.</p> In\u00a0[134]: Copied! <pre># Create DataFrame compatible with Kaggle submission requirements\npred_df = pd.DataFrame()\npred_df[\"SalesID\"] = test_df[\"SalesID\"]\npred_df[\"SalePrice\"] = test_preds\npred_df.sample(5)\n</pre> # Create DataFrame compatible with Kaggle submission requirements pred_df = pd.DataFrame() pred_df[\"SalesID\"] = test_df[\"SalesID\"] pred_df[\"SalePrice\"] = test_preds pred_df.sample(5) Out[134]: SalesID SalePrice 6517 6304619 78522.550705 922 1231204 13500.628307 6859 6311050 10891.180556 6634 6307731 28503.776455 8882 6447290 50641.411817 <p>Excellent! We've got a <code>SalePrice</code> prediction for every <code>SalesID</code> in the test DataFrame.</p> <p>Let's save this to CSV so we could upload it or share it with someone else if we had to.</p> In\u00a0[135]: Copied! <pre># Export test dataset predictions to CSV\npred_df.to_csv(\"../data/bluebook-for-bulldozers/predictions.csv\",\n               index=False)\n</pre> # Export test dataset predictions to CSV pred_df.to_csv(\"../data/bluebook-for-bulldozers/predictions.csv\",                index=False) In\u00a0[136]: Copied! <pre># Get example from test_df\ntest_df_preprocessed_sample = test_df_preprocessed.sample(n=1, random_state=42)\n\n# Turn back into original format\ntest_df_unpreprocessed_sample = test_df_preprocessed_sample.copy() \ntest_df_unpreprocessed_sample[categorical_features] = ordinal_encoder.inverse_transform(test_df_unpreprocessed_sample[categorical_features])\ntest_df_unpreprocessed_sample.to_dict(orient=\"records\")\n</pre> # Get example from test_df test_df_preprocessed_sample = test_df_preprocessed.sample(n=1, random_state=42)  # Turn back into original format test_df_unpreprocessed_sample = test_df_preprocessed_sample.copy()  test_df_unpreprocessed_sample[categorical_features] = ordinal_encoder.inverse_transform(test_df_unpreprocessed_sample[categorical_features]) test_df_unpreprocessed_sample.to_dict(orient=\"records\") Out[136]: <pre>[{'SalesID': 1229148,\n  'MachineID': 1042578,\n  'ModelID': 9579,\n  'datasource': 121,\n  'auctioneerID': 3,\n  'YearMade': 2004,\n  'MachineHoursCurrentMeter': 3290.0,\n  'UsageBand': 'Medium',\n  'fiModelDesc': 'S250',\n  'fiBaseModel': 'S250',\n  'fiSecondaryDesc': 'nan',\n  'fiModelSeries': 'nan',\n  'fiModelDescriptor': 'nan',\n  'ProductSize': 'nan',\n  'fiProductClassDesc': 'Skid Steer Loader - 2201.0 to 2701.0 Lb Operating Capacity',\n  'state': 'Missouri',\n  'ProductGroup': 'SSL',\n  'ProductGroupDesc': 'Skid Steer Loaders',\n  'Drive_System': 'nan',\n  'Enclosure': 'EROPS',\n  'Forks': 'None or Unspecified',\n  'Pad_Type': 'nan',\n  'Ride_Control': 'nan',\n  'Stick': 'nan',\n  'Transmission': 'nan',\n  'Turbocharged': 'nan',\n  'Blade_Extension': 'nan',\n  'Blade_Width': 'nan',\n  'Enclosure_Type': 'nan',\n  'Engine_Horsepower': 'nan',\n  'Hydraulics': 'Auxiliary',\n  'Pushblock': 'nan',\n  'Ripper': 'nan',\n  'Scarifier': 'nan',\n  'Tip_Control': 'nan',\n  'Tire_Size': 'nan',\n  'Coupler': 'Hydraulic',\n  'Coupler_System': 'Yes',\n  'Grouser_Tracks': 'None or Unspecified',\n  'Hydraulics_Flow': 'Standard',\n  'Track_Type': 'nan',\n  'Undercarriage_Pad_Width': 'nan',\n  'Stick_Length': 'nan',\n  'Thumb': 'nan',\n  'Pattern_Changer': 'nan',\n  'Grouser_Type': 'nan',\n  'Backhoe_Mounting': 'nan',\n  'Blade_Type': 'nan',\n  'Travel_Controls': 'nan',\n  'Differential_Type': 'nan',\n  'Steering_Controls': 'nan',\n  'saleYear': 2012,\n  'saleMonth': 6,\n  'saleDay': 15,\n  'saleDayofweek': 4,\n  'saleDayofyear': 167}]</pre> <p>Wonderful, so if we're going to make a prediction on a custom sample, we'll need to fill out these details as much as we can.</p> <p>Let's try and make a prediction on the example test sample.</p> In\u00a0[137]: Copied! <pre># Make a prediction on the preprocessed test sample\nbest_model.predict(test_df_preprocessed_sample)\n</pre> # Make a prediction on the preprocessed test sample best_model.predict(test_df_preprocessed_sample) Out[137]: <pre>array([13519.31657848])</pre> <p>Nice!</p> <p>We get an output array containing a predicted <code>SalePrice</code>.</p> <p>Let's now try it on a custom sample.</p> <p>Again, like all good machine learning cooking shows, I've searched the internet for \"bulldozer sales in America\" and found a sale from 6th July 2024 (I'm writing these materials in mid 2024 so if it's many years in the future and the link doesn't work, check out the screenshot below).</p> Screenshot of a bulldozer sale advertisement. I took information from this advertisement to create our own custom sample for testing our machine learning model on data from the wild. Source. <p>I went through the advertisement online and collected as much detail as I could and formatted the dictionary below with all of the related fields.</p> <p>It may not be perfect but data in the real world is rarely perfect.</p> <p>For values I couldn't find or were inconspicuous, I filled them with <code>np.nan</code> (or <code>NaN</code>).</p> <p>Some values such as <code>SalesID</code> were unobtainable because they were part of the original collected dataset, for these I've also used <code>np.nan</code>.</p> <p>Also notice how I've already created the extra date features <code>saleYear</code>, <code>saleMonth</code>, <code>saleDay</code> and more by manually breaking down the listed sale date of 6 July 2024.</p> In\u00a0[138]: Copied! <pre># Create a dictionary of features and values from an internet-based bulldozer advertisement\n# See link: https://www.purplewave.com/auction/240606/item/EK8504/2004-Caterpillar-D6R_XL-Crawlers-Crawler_Dozer-Missouri (note: this link is/was valid as of October 2024 but may be invalid in the future)\ncustom_sample = {\n  \"SalesID\": np.nan,\n  \"MachineID\": 8504,\n  \"ModelID\": np.nan,\n  \"datasource\": np.nan,\n  \"auctioneerID\": np.nan,\n  \"YearMade\": 2004,\n  \"MachineHoursCurrentMeter\": 11770.0,\n  \"UsageBand\": \"High\",\n  \"fiModelDesc\": \"D6RXL\",\n  \"fiBaseModel\": \"D6\",\n  \"fiSecondaryDesc\": \"XL\",\n  \"fiModelSeries\": np.nan,\n  \"fiModelDescriptor\": np.nan,\n  \"ProductSize\": \"Medium\",\n  \"fiProductClassDesc\": \"Track Type Tractor, Dozer - 130.0 to 160.0 Horsepower\",\n  \"state\": \"Missouri\",\n  \"ProductGroup\": \"TTT\",\n  \"ProductGroupDesc\": \"Track Type Tractors\",\n  \"Drive_System\": \"No\",\n  \"Enclosure\": \"EROPS\",\n  \"Forks\": \"None or Unspecified\",\n  \"Pad_Type\": \"Grouser\",\n  \"Ride_Control\": \"None or Unspecified\",\n  \"Stick\": \"nan\",\n  \"Transmission\": \"Powershift\",\n  \"Turbocharged\": \"None or Unspecified\",\n  \"Blade_Extension\": \"None or Unspecified\",\n  \"Blade_Width\": np.nan,\n  \"Enclosure_Type\": np.nan,\n  \"Engine_Horsepower\": np.nan,\n  \"Hydraulics\": np.nan,\n  \"Pushblock\": \"None or Unspecified\",\n  \"Ripper\": \"None or Unspecified\",\n  \"Scarifier\": \"None or Unspecified\",\n  \"Tip_Control\": \"Tip\",\n  \"Tire_Size\": np.nan,\n  \"Coupler\": np.nan,\n  \"Coupler_System\": np.nan,\n  \"Grouser_Tracks\": \"Yes\",\n  \"Hydraulics_Flow\": np.nan,\n  \"Track_Type\": \"Steel\",\n  \"Undercarriage_Pad_Width\": \"22 inch\",\n  \"Stick_Length\": np.nan,\n  \"Thumb\": np.nan,\n  \"Pattern_Changer\": np.nan,\n  \"Grouser_Type\": \"Single\",\n  \"Backhoe_Mounting\": \"None or Unspecified\",\n  \"Blade_Type\": \"Semi U\",\n  \"Travel_Controls\": np.nan,\n  \"Differential_Type\": np.nan,\n  \"Steering_Controls\": \"Command Control\",\n  \"saleYear\": 2024,\n  \"saleMonth\": 6,\n  \"saleDay\": 7,\n  \"saleDayofweek\": 5,\n  \"saleDayofyear\": 159\n}\n</pre> # Create a dictionary of features and values from an internet-based bulldozer advertisement # See link: https://www.purplewave.com/auction/240606/item/EK8504/2004-Caterpillar-D6R_XL-Crawlers-Crawler_Dozer-Missouri (note: this link is/was valid as of October 2024 but may be invalid in the future) custom_sample = {   \"SalesID\": np.nan,   \"MachineID\": 8504,   \"ModelID\": np.nan,   \"datasource\": np.nan,   \"auctioneerID\": np.nan,   \"YearMade\": 2004,   \"MachineHoursCurrentMeter\": 11770.0,   \"UsageBand\": \"High\",   \"fiModelDesc\": \"D6RXL\",   \"fiBaseModel\": \"D6\",   \"fiSecondaryDesc\": \"XL\",   \"fiModelSeries\": np.nan,   \"fiModelDescriptor\": np.nan,   \"ProductSize\": \"Medium\",   \"fiProductClassDesc\": \"Track Type Tractor, Dozer - 130.0 to 160.0 Horsepower\",   \"state\": \"Missouri\",   \"ProductGroup\": \"TTT\",   \"ProductGroupDesc\": \"Track Type Tractors\",   \"Drive_System\": \"No\",   \"Enclosure\": \"EROPS\",   \"Forks\": \"None or Unspecified\",   \"Pad_Type\": \"Grouser\",   \"Ride_Control\": \"None or Unspecified\",   \"Stick\": \"nan\",   \"Transmission\": \"Powershift\",   \"Turbocharged\": \"None or Unspecified\",   \"Blade_Extension\": \"None or Unspecified\",   \"Blade_Width\": np.nan,   \"Enclosure_Type\": np.nan,   \"Engine_Horsepower\": np.nan,   \"Hydraulics\": np.nan,   \"Pushblock\": \"None or Unspecified\",   \"Ripper\": \"None or Unspecified\",   \"Scarifier\": \"None or Unspecified\",   \"Tip_Control\": \"Tip\",   \"Tire_Size\": np.nan,   \"Coupler\": np.nan,   \"Coupler_System\": np.nan,   \"Grouser_Tracks\": \"Yes\",   \"Hydraulics_Flow\": np.nan,   \"Track_Type\": \"Steel\",   \"Undercarriage_Pad_Width\": \"22 inch\",   \"Stick_Length\": np.nan,   \"Thumb\": np.nan,   \"Pattern_Changer\": np.nan,   \"Grouser_Type\": \"Single\",   \"Backhoe_Mounting\": \"None or Unspecified\",   \"Blade_Type\": \"Semi U\",   \"Travel_Controls\": np.nan,   \"Differential_Type\": np.nan,   \"Steering_Controls\": \"Command Control\",   \"saleYear\": 2024,   \"saleMonth\": 6,   \"saleDay\": 7,   \"saleDayofweek\": 5,   \"saleDayofyear\": 159 } <p>Now we've got a single custom sample in the form of a dictionary, we can turn it into a DataFrame.</p> In\u00a0[139]: Copied! <pre># Turn single sample in a DataFrame\ncustom_sample_df = pd.DataFrame(custom_sample, index=[0])\ncustom_sample_df.head()\n</pre> # Turn single sample in a DataFrame custom_sample_df = pd.DataFrame(custom_sample, index=[0]) custom_sample_df.head() Out[139]: SalesID MachineID ModelID datasource auctioneerID YearMade MachineHoursCurrentMeter UsageBand fiModelDesc fiBaseModel ... Backhoe_Mounting Blade_Type Travel_Controls Differential_Type Steering_Controls saleYear saleMonth saleDay saleDayofweek saleDayofyear 0 NaN 8504 NaN NaN NaN 2004 11770.0 High D6RXL D6 ... None or Unspecified Semi U NaN NaN Command Control 2024 6 7 5 159 <p>1 rows \u00d7 56 columns</p> <p>And of course, we can preprocess the categoricial features using our <code>ordinal_encoder</code> (we use the same instance of <code>OrdinalEncoder</code> as we trained on the training dataset).</p> In\u00a0[140]: Copied! <pre># Transform the categorical features of the custom sample\ncustom_sample_df[categorical_features] = ordinal_encoder.transform(custom_sample_df[categorical_features].astype(str))\ncustom_sample_df\n</pre> # Transform the categorical features of the custom sample custom_sample_df[categorical_features] = ordinal_encoder.transform(custom_sample_df[categorical_features].astype(str)) custom_sample_df Out[140]: SalesID MachineID ModelID datasource auctioneerID YearMade MachineHoursCurrentMeter UsageBand fiModelDesc fiBaseModel ... Backhoe_Mounting Blade_Type Travel_Controls Differential_Type Steering_Controls saleYear saleMonth saleDay saleDayofweek saleDayofyear 0 NaN 8504 NaN NaN NaN 2004 11770.0 0.0 2308.0 703.0 ... 0.0 6.0 7.0 4.0 0.0 2024 6 7 5 159 <p>1 rows \u00d7 56 columns</p> <p>Custom sample preprocessed, let's make a prediction!</p> In\u00a0[141]: Copied! <pre># Make a prediction on the preprocessed custom sample\ncustom_sample_pred = best_model.predict(custom_sample_df)\nprint(f\"[INFO] Predicted sale price of custom sample: ${round(custom_sample_pred[0], 2)}\")\n</pre> # Make a prediction on the preprocessed custom sample custom_sample_pred = best_model.predict(custom_sample_df) print(f\"[INFO] Predicted sale price of custom sample: ${round(custom_sample_pred[0], 2)}\") <pre>[INFO] Predicted sale price of custom sample: $51474.96\n</pre> <p>Now how close was this to the actual sale price (listed on the advertisement) of $72,600?</p> In\u00a0[142]: Copied! <pre>from sklearn.metrics import mean_absolute_error, root_mean_squared_log_error\n\n# Evaluate our model versus the actual sale price\ncustom_sample_actual_sale_price = [72600] # this is the sale price listed on the advertisement\n\nprint(f\"[INFO] Model MAE on custom sample: {mean_absolute_error(y_pred=custom_sample_pred, y_true=custom_sample_actual_sale_price)}\")\nprint(f\"[INFO] Model RMSLE on custom sample: {root_mean_squared_log_error(y_pred=custom_sample_pred, y_true=custom_sample_actual_sale_price)}\")\n</pre> from sklearn.metrics import mean_absolute_error, root_mean_squared_log_error  # Evaluate our model versus the actual sale price custom_sample_actual_sale_price = [72600] # this is the sale price listed on the advertisement  print(f\"[INFO] Model MAE on custom sample: {mean_absolute_error(y_pred=custom_sample_pred, y_true=custom_sample_actual_sale_price)}\") print(f\"[INFO] Model RMSLE on custom sample: {root_mean_squared_log_error(y_pred=custom_sample_pred, y_true=custom_sample_actual_sale_price)}\") <pre>[INFO] Model MAE on custom sample: 21125.040564373892\n[INFO] Model RMSLE on custom sample: 0.3438638042344433\n</pre> <p>Woah!</p> <p>We get a quite high MAE value, however, it looks like our model's RMSLE performance on the custom sample was even better than the <code>best_model</code> on the validation dataset.</p> <p>Not too bad for a model trained on sales data over 12 years older than our custom sample's sale date.</p> <p>Note: In practice, to make this process easier, rather than manually typing out all of the feature values by hand, you might want to create an application capable of ingesting these values in a nice user interface. To create such machine learning applications, I'd practice by checking out Streamlit or Gradio.</p> In\u00a0[143]: Copied! <pre># Find feature importance of our best model\nbest_model_feature_importances = best_model.feature_importances_\nbest_model_feature_importances\n</pre> # Find feature importance of our best model best_model_feature_importances = best_model.feature_importances_ best_model_feature_importances Out[143]: <pre>array([3.78948522e-02, 2.70954102e-02, 5.85804002e-02, 1.79438322e-03,\n       5.25621132e-03, 1.92040831e-01, 6.71461619e-03, 1.42137572e-03,\n       4.79324438e-02, 4.73967258e-02, 4.12235661e-02, 4.75379381e-03,\n       2.55283197e-02, 1.60578799e-01, 5.08919397e-02, 8.34245434e-03,\n       3.43077232e-03, 4.16871935e-03, 1.45645185e-03, 6.32089976e-02,\n       1.93106853e-03, 7.91189110e-04, 2.16468186e-03, 2.42755109e-04,\n       1.44729959e-03, 1.10292279e-04, 4.69525167e-03, 4.70046399e-03,\n       2.18877572e-03, 4.03668217e-03, 4.46781002e-03, 2.86947732e-03,\n       5.20668987e-03, 3.50894384e-03, 1.75215277e-03, 1.16769900e-02,\n       1.84682779e-03, 2.08450645e-02, 1.17370327e-02, 5.26785421e-03,\n       2.07101299e-03, 1.36424627e-03, 1.60680297e-03, 9.71604299e-04,\n       7.85735364e-04, 7.29302663e-04, 6.74283032e-04, 3.28828690e-03,\n       2.83781098e-03, 3.92432694e-04, 4.73081800e-04, 7.26042221e-02,\n       5.42512552e-03, 8.54840059e-03, 4.42773246e-03, 1.26015531e-02])</pre> <p>Woah, looks like we get one value per feature in our dataset.</p> In\u00a0[144]: Copied! <pre>print(f\"[INFO] Number of feature importance values: {best_model_feature_importances.shape[0]}\") \nprint(f\"[INFO] Number of features in training dataset: {X_train_preprocessed.shape[1]}\")\n</pre> print(f\"[INFO] Number of feature importance values: {best_model_feature_importances.shape[0]}\")  print(f\"[INFO] Number of features in training dataset: {X_train_preprocessed.shape[1]}\") <pre>[INFO] Number of feature importance values: 56\n[INFO] Number of features in training dataset: 56\n</pre> <p>We can inspect these further by turning them into a DataFrame.</p> <p>We'll sort it descending order so we can see which feature our model is assigning the highest value.</p> In\u00a0[145]: Copied! <pre># Create feature importance DataFrame\ncolumn_names = test_df.columns\nfeature_importance_df = pd.DataFrame({\"feature_names\": column_names,\n                                      \"feature_importance\": best_model_feature_importances}).sort_values(by=\"feature_importance\",\n                                                                                                         ascending=False)\nfeature_importance_df.head()\n</pre> # Create feature importance DataFrame column_names = test_df.columns feature_importance_df = pd.DataFrame({\"feature_names\": column_names,                                       \"feature_importance\": best_model_feature_importances}).sort_values(by=\"feature_importance\",                                                                                                          ascending=False) feature_importance_df.head() Out[145]: feature_names feature_importance 5 YearMade 0.192041 13 ProductSize 0.160579 51 saleYear 0.072604 19 Enclosure 0.063209 2 ModelID 0.058580 <p>Hmmm... looks like <code>YearMade</code> may be contributing the most value in the model's eyes.</p> <p>How about we turn our DataFrame into a plot to compare values?</p> In\u00a0[146]: Copied! <pre># Plot the top feature importance values\ntop_n = 20\nplt.figure(figsize=(10, 5))\nplt.barh(y=feature_importance_df[\"feature_names\"][:top_n], # Plot the top_n feature importance values\n         width=feature_importance_df[\"feature_importance\"][:top_n])\nplt.title(f\"Top {top_n} Feature Importance Values for Best RandomForestRegressor Model\")\nplt.xlabel(\"Feature importance value\")\nplt.ylabel(\"Feature name\")\nplt.gca().invert_yaxis();\n</pre> # Plot the top feature importance values top_n = 20 plt.figure(figsize=(10, 5)) plt.barh(y=feature_importance_df[\"feature_names\"][:top_n], # Plot the top_n feature importance values          width=feature_importance_df[\"feature_importance\"][:top_n]) plt.title(f\"Top {top_n} Feature Importance Values for Best RandomForestRegressor Model\") plt.xlabel(\"Feature importance value\") plt.ylabel(\"Feature name\") plt.gca().invert_yaxis(); <p>Ok, looks like the top 4 features contributing to our model's predictions are <code>YearMade</code>, <code>ProductSize</code>, <code>Enclosure</code> and <code>saleYear</code>.</p> <p>Referring to the original data dictionary, do these values make sense to be contributing the most to the model?</p> <ul> <li><code>YearMade</code> - Year of manufacture of the machine.</li> <li><code>ProductSize</code> - Size of the bulldozer.</li> <li><code>Enclosure</code> - Type of bulldozer enclosure (e.g. OROPS = Open Rollover Protective Structures, EROPS = Enclosed Rollover Protective Structures).</li> <li><code>saleYear</code> - The year the bulldozer was sold (this is one of our engineered features from <code>saledate</code>).</li> </ul> <p>Now I've never sold a bulldozer but reading about each of these values seems to make sense that they would contribute significantly to the sale price.</p> <p>I know when I've bought cars in the past, the year that is was made was an important part of my decision.</p> <p>And it also makes sense that <code>ProductSize</code> be an important feature when deciding on the price of a bulldozer.</p> <p>Let's check out the unique values for <code>ProductSize</code> and <code>Enclosure</code>.</p> In\u00a0[147]: Copied! <pre>print(f\"[INFO] Unique ProductSize values: {train_df['ProductSize'].unique()}\")\nprint(f\"[INFO] Unique Enclosure values: {train_df['Enclosure'].unique()}\")\n</pre> print(f\"[INFO] Unique ProductSize values: {train_df['ProductSize'].unique()}\") print(f\"[INFO] Unique Enclosure values: {train_df['Enclosure'].unique()}\") <pre>[INFO] Unique ProductSize values: ['Medium' nan 'Compact' 'Small' 'Large' 'Large / Medium' 'Mini']\n[INFO] Unique Enclosure values: ['OROPS' 'EROPS' 'EROPS w AC' nan 'EROPS AC' 'NO ROPS'\n 'None or Unspecified']\n</pre> <p>My guess is that a bulldozer with a <code>ProductSize</code> of <code>'Mini'</code> would sell for less than a bulldozer with a size of <code>'Large'</code>.</p> <p>We could investigate this further in an extension to model driven data exploratory analysis or we could take this information to a colleague or client to discuss further.</p> <p>Either way, we've now got a machine learning model capable of predicting the sale price of bulldozers given their features/attributes!</p> <p>That's a huuuuuuge effort!</p> <p>And you should be very proud of yourself for making it this far.</p> In\u00a0[244]: Copied! <pre>from sklearn.impute import SimpleImputer\nfrom sklearn.preprocessing import OrdinalEncoder\nfrom sklearn.metrics import mean_absolute_error, root_mean_squared_log_error\nfrom sklearn.ensemble import RandomForestRegressor\n\n# Import train samples (making sure to parse dates and then sort by them)\ntrain_df = pd.read_csv(filepath_or_buffer=\"../data/bluebook-for-bulldozers/Train.csv\",\n                       parse_dates=[\"saledate\"],\n                       low_memory=False).sort_values(by=\"saledate\", ascending=True)\n\n# Import validation samples (making sure to parse dates and then sort by them)\nvalid_df = pd.read_csv(filepath_or_buffer=\"../data/bluebook-for-bulldozers/Valid.csv\",\n                       parse_dates=[\"saledate\"])\n\n# The ValidSolution.csv contains the SalePrice values for the samples in Valid.csv\nvalid_solution = pd.read_csv(filepath_or_buffer=\"../data/bluebook-for-bulldozers/ValidSolution.csv\")\n\n# Map valid_solution to valid_df\nvalid_df[\"SalePrice\"] = valid_df[\"SalesID\"].map(valid_solution.set_index(\"SalesID\")[\"SalePrice\"])\n\n# Make sure valid_df is sorted by saledate still\nvalid_df = valid_df.sort_values(\"saledate\", ascending=True).reset_index(drop=True)\n\n# How many samples are in each DataFrame?\nprint(f\"[INFO] Number of samples in training DataFrame: {len(train_df)}\")\nprint(f\"[INFO] Number of samples in validation DataFrame: {len(valid_df)}\")\n\n# Make a function to add date columns\ndef add_datetime_features_to_df(df, date_column=\"saledate\"):\n    # Add datetime parameters for saledate\n    df[\"saleYear\"] = df[date_column].dt.year\n    df[\"saleMonth\"] = df[date_column].dt.month\n    df[\"saleDay\"] = df[date_column].dt.day\n    df[\"saleDayofweek\"] = df[date_column].dt.dayofweek\n    df[\"saleDayofyear\"] = df[date_column].dt.dayofyear\n\n    # Drop original saledate column\n    df.drop(\"saledate\", axis=1, inplace=True)\n\n    return df\n\n# Add datetime features to DataFrames\ntrain_df = add_datetime_features_to_df(df=train_df)\nvalid_df = add_datetime_features_to_df(df=valid_df)\n\n# Split training data into features and labels\nX_train = train_df.drop(\"SalePrice\", axis=1)\ny_train = train_df[\"SalePrice\"]\n\n# Split validation data into features and labels\nX_valid = valid_df.drop(\"SalePrice\", axis=1)\ny_valid = valid_df[\"SalePrice\"]\n\n# Define numerical and categorical features\nnumeric_features = [label for label, content in X_train.items() if pd.api.types.is_numeric_dtype(content)]\ncategorical_features = [label for label, content in X_train.items() if not pd.api.types.is_numeric_dtype(content)]\n\n### Filling missing values ### \n\n# Create an ordinal encoder (turns category items into numeric representation)\nordinal_encoder = OrdinalEncoder(categories=\"auto\",\n                                 handle_unknown=\"use_encoded_value\",\n                                 unknown_value=np.nan,\n                                 encoded_missing_value=np.nan) # treat unknown categories as np.nan (or None)\n\n# Create a simple imputer to fill missing values with median\nsimple_imputer_median = SimpleImputer(missing_values=np.nan,\n                                      strategy=\"median\")\n\n# Fit and transform the categorical and numerical columns of X_train\nX_train_preprocessed = X_train.copy() # make copies of the oringal DataFrames so we can keep the original values in tact and view them later\nX_train_preprocessed[categorical_features] = ordinal_encoder.fit_transform(X_train_preprocessed[categorical_features].astype(str)) # OrdinalEncoder expects all values as the same type (e.g. string or numeric only)\nX_train_preprocessed[numerical_features] = simple_imputer_median.fit_transform(X_train_preprocessed[numerical_features])\n\n# Transform the categorical and numerical columns of X_valid \nX_valid_preprocessed = X_valid.copy()\nX_valid_preprocessed[categorical_features] = ordinal_encoder.transform(X_valid_preprocessed[categorical_features].astype(str)) # only use `transform` on the validation data\nX_valid_preprocessed[numerical_features] = simple_imputer_median.transform(X_valid_preprocessed[numerical_features])\n\n# Create function to evaluate our model\ndef show_scores(model, \n                train_features=X_train_preprocessed,\n                train_labels=y_train,\n                valid_features=X_valid_preprocessed,\n                valid_labels=y_valid):\n    \n    # Make predictions on train and validation features\n    train_preds = model.predict(X=train_features)\n    val_preds = model.predict(X=valid_features)\n\n    # Create a scores dictionary of different evaluation metrics\n    scores = {\"Training MAE\": mean_absolute_error(y_true=train_labels, \n                                                  y_pred=train_preds),\n              \"Valid MAE\": mean_absolute_error(y_true=valid_labels, \n                                               y_pred=val_preds),\n              \"Training RMSLE\": root_mean_squared_log_error(y_true=train_labels, \n                                                            y_pred=train_preds),\n              \"Valid RMSLE\": root_mean_squared_log_error(y_true=valid_labels, \n                                                         y_pred=val_preds),\n              \"Training R^2\": model.score(X=train_features, \n                                          y=train_labels),\n              \"Valid R^2\": model.score(X=valid_features, \n                                       y=valid_labels)}\n    return scores\n\n# Instantiate a model with best hyperparameters \nideal_model_2 = RandomForestRegressor(n_estimators=90,\n                                      max_depth=None,\n                                      min_samples_leaf=1,\n                                      min_samples_split=5,\n                                      max_features=0.5,\n                                      n_jobs=-1,\n                                      max_samples=None)\n\n# Fit a model to the preprocessed data\nideal_model_2.fit(X=X_train_preprocessed, \n                  y=y_train)\n\n# Evalute the model\nideal_model_2_scores = show_scores(model=ideal_model_2)\nideal_model_2_scores\n</pre> from sklearn.impute import SimpleImputer from sklearn.preprocessing import OrdinalEncoder from sklearn.metrics import mean_absolute_error, root_mean_squared_log_error from sklearn.ensemble import RandomForestRegressor  # Import train samples (making sure to parse dates and then sort by them) train_df = pd.read_csv(filepath_or_buffer=\"../data/bluebook-for-bulldozers/Train.csv\",                        parse_dates=[\"saledate\"],                        low_memory=False).sort_values(by=\"saledate\", ascending=True)  # Import validation samples (making sure to parse dates and then sort by them) valid_df = pd.read_csv(filepath_or_buffer=\"../data/bluebook-for-bulldozers/Valid.csv\",                        parse_dates=[\"saledate\"])  # The ValidSolution.csv contains the SalePrice values for the samples in Valid.csv valid_solution = pd.read_csv(filepath_or_buffer=\"../data/bluebook-for-bulldozers/ValidSolution.csv\")  # Map valid_solution to valid_df valid_df[\"SalePrice\"] = valid_df[\"SalesID\"].map(valid_solution.set_index(\"SalesID\")[\"SalePrice\"])  # Make sure valid_df is sorted by saledate still valid_df = valid_df.sort_values(\"saledate\", ascending=True).reset_index(drop=True)  # How many samples are in each DataFrame? print(f\"[INFO] Number of samples in training DataFrame: {len(train_df)}\") print(f\"[INFO] Number of samples in validation DataFrame: {len(valid_df)}\")  # Make a function to add date columns def add_datetime_features_to_df(df, date_column=\"saledate\"):     # Add datetime parameters for saledate     df[\"saleYear\"] = df[date_column].dt.year     df[\"saleMonth\"] = df[date_column].dt.month     df[\"saleDay\"] = df[date_column].dt.day     df[\"saleDayofweek\"] = df[date_column].dt.dayofweek     df[\"saleDayofyear\"] = df[date_column].dt.dayofyear      # Drop original saledate column     df.drop(\"saledate\", axis=1, inplace=True)      return df  # Add datetime features to DataFrames train_df = add_datetime_features_to_df(df=train_df) valid_df = add_datetime_features_to_df(df=valid_df)  # Split training data into features and labels X_train = train_df.drop(\"SalePrice\", axis=1) y_train = train_df[\"SalePrice\"]  # Split validation data into features and labels X_valid = valid_df.drop(\"SalePrice\", axis=1) y_valid = valid_df[\"SalePrice\"]  # Define numerical and categorical features numeric_features = [label for label, content in X_train.items() if pd.api.types.is_numeric_dtype(content)] categorical_features = [label for label, content in X_train.items() if not pd.api.types.is_numeric_dtype(content)]  ### Filling missing values ###   # Create an ordinal encoder (turns category items into numeric representation) ordinal_encoder = OrdinalEncoder(categories=\"auto\",                                  handle_unknown=\"use_encoded_value\",                                  unknown_value=np.nan,                                  encoded_missing_value=np.nan) # treat unknown categories as np.nan (or None)  # Create a simple imputer to fill missing values with median simple_imputer_median = SimpleImputer(missing_values=np.nan,                                       strategy=\"median\")  # Fit and transform the categorical and numerical columns of X_train X_train_preprocessed = X_train.copy() # make copies of the oringal DataFrames so we can keep the original values in tact and view them later X_train_preprocessed[categorical_features] = ordinal_encoder.fit_transform(X_train_preprocessed[categorical_features].astype(str)) # OrdinalEncoder expects all values as the same type (e.g. string or numeric only) X_train_preprocessed[numerical_features] = simple_imputer_median.fit_transform(X_train_preprocessed[numerical_features])  # Transform the categorical and numerical columns of X_valid  X_valid_preprocessed = X_valid.copy() X_valid_preprocessed[categorical_features] = ordinal_encoder.transform(X_valid_preprocessed[categorical_features].astype(str)) # only use `transform` on the validation data X_valid_preprocessed[numerical_features] = simple_imputer_median.transform(X_valid_preprocessed[numerical_features])  # Create function to evaluate our model def show_scores(model,                  train_features=X_train_preprocessed,                 train_labels=y_train,                 valid_features=X_valid_preprocessed,                 valid_labels=y_valid):          # Make predictions on train and validation features     train_preds = model.predict(X=train_features)     val_preds = model.predict(X=valid_features)      # Create a scores dictionary of different evaluation metrics     scores = {\"Training MAE\": mean_absolute_error(y_true=train_labels,                                                    y_pred=train_preds),               \"Valid MAE\": mean_absolute_error(y_true=valid_labels,                                                 y_pred=val_preds),               \"Training RMSLE\": root_mean_squared_log_error(y_true=train_labels,                                                              y_pred=train_preds),               \"Valid RMSLE\": root_mean_squared_log_error(y_true=valid_labels,                                                           y_pred=val_preds),               \"Training R^2\": model.score(X=train_features,                                            y=train_labels),               \"Valid R^2\": model.score(X=valid_features,                                         y=valid_labels)}     return scores  # Instantiate a model with best hyperparameters  ideal_model_2 = RandomForestRegressor(n_estimators=90,                                       max_depth=None,                                       min_samples_leaf=1,                                       min_samples_split=5,                                       max_features=0.5,                                       n_jobs=-1,                                       max_samples=None)  # Fit a model to the preprocessed data ideal_model_2.fit(X=X_train_preprocessed,                    y=y_train)  # Evalute the model ideal_model_2_scores = show_scores(model=ideal_model_2) ideal_model_2_scores <pre>[INFO] Number of samples in training DataFrame: 401125\n[INFO] Number of samples in validation DataFrame: 11573\n</pre> Out[244]: <pre>{'Training MAE': np.float64(1951.2971558280735),\n 'Valid MAE': np.float64(5964.025764507629),\n 'Training RMSLE': np.float64(0.101909965049995),\n 'Valid RMSLE': np.float64(0.24697812443315573),\n 'Training R^2': 0.9810825663665007,\n 'Valid R^2': 0.8809697755766817}</pre> <p>Looks like filling the missing numeric values made our <code>ideal_model_2</code> perform slightly worse than our original <code>ideal_model</code>.</p> <p><code>ideal_model_2</code> had a validation RMSLE of <code>0.24697812443315573</code> where as <code>ideal_model</code> had a validation RMSLE of <code>0.24654150224930685</code>.</p> In\u00a0[247]: Copied! <pre>import pandas as pd\nimport numpy as np\n\nfrom sklearn.compose import ColumnTransformer\nfrom sklearn.ensemble import RandomForestRegressor\nfrom sklearn.impute import SimpleImputer\nfrom sklearn.metrics import mean_absolute_error, root_mean_squared_log_error\nfrom sklearn.preprocessing import OrdinalEncoder, FunctionTransformer\nfrom sklearn.pipeline import Pipeline\n\n\n# Import and prepare data\ntrain_df = pd.read_csv(\"../data/bluebook-for-bulldozers/Train.csv\",\n                       parse_dates=[\"saledate\"],\n                       low_memory=False).sort_values(by=\"saledate\", ascending=True)\n\nvalid_df = pd.read_csv(\"../data/bluebook-for-bulldozers/Valid.csv\",\n                       parse_dates=[\"saledate\"])\n\nvalid_solution = pd.read_csv(\"../data/bluebook-for-bulldozers/ValidSolution.csv\")\nvalid_df[\"SalePrice\"] = valid_df[\"SalesID\"].map(valid_solution.set_index(\"SalesID\")[\"SalePrice\"])\nvalid_df = valid_df.sort_values(\"saledate\", ascending=True).reset_index(drop=True)\n\n# Add datetime features\ndef add_datetime_features_to_df(df, date_column=\"saledate\"):\n    df = df.copy()\n    df[\"saleYear\"] = df[date_column].dt.year\n    df[\"saleMonth\"] = df[date_column].dt.month\n    df[\"saleDay\"] = df[date_column].dt.day\n    df[\"saleDayofweek\"] = df[date_column].dt.dayofweek\n    df[\"saleDayofyear\"] = df[date_column].dt.dayofyear\n    return df.drop(date_column, axis=1)\n\n# Apply datetime features\ntrain_df = add_datetime_features_to_df(train_df)\nvalid_df = add_datetime_features_to_df(valid_df)\n\n# Split data into features and labels\nX_train = train_df.drop(\"SalePrice\", axis=1)\ny_train = train_df[\"SalePrice\"]\nX_valid = valid_df.drop(\"SalePrice\", axis=1)\ny_valid = valid_df[\"SalePrice\"]\n\n# Define feature types\nnumeric_features = [label for label, content in X_train.items() \n                   if pd.api.types.is_numeric_dtype(content)]\ncategorical_features = [label for label, content in X_train.items() \n                       if not pd.api.types.is_numeric_dtype(content)]\n\n# Create preprocessing steps\nnumeric_transformer = Pipeline(steps=[\n    ('imputer', SimpleImputer(strategy='median'))\n])\n\ncategorical_transformer = Pipeline(steps=[\n    ('string_converter', FunctionTransformer(lambda x: x.astype(str))), # convert values to string\n    ('ordinal', OrdinalEncoder(handle_unknown='use_encoded_value',\n                              unknown_value=np.nan,\n                              encoded_missing_value=np.nan)),\n])\n\n# Create preprocessor using ColumnTransformer\npreprocessor = ColumnTransformer(\n    transformers=[\n        ('numerical_transforms', numeric_transformer, numeric_features),\n        ('categorical_transforms', categorical_transformer, categorical_features)\n    ])\n\n# Create full pipeline\nmodel_pipeline = Pipeline([\n    ('preprocessor', preprocessor),\n    ('regressor', RandomForestRegressor(\n        n_estimators=90,\n        max_depth=None,\n        min_samples_leaf=1,\n        min_samples_split=5,\n        max_features=0.5,\n        n_jobs=-1,\n        max_samples=None\n    ))\n])\n\n# Function to evaluate the pipeline\ndef evaluate_pipeline(pipeline, X_train, y_train, X_valid, y_valid):\n    # Make predictions\n    train_preds = pipeline.predict(X_train)\n    valid_preds = pipeline.predict(X_valid)\n    \n    # Calculate scores\n    scores = {\n        \"Training MAE\": mean_absolute_error(y_train, train_preds),\n        \"Valid MAE\": mean_absolute_error(y_valid, valid_preds),\n        \"Training RMSLE\": root_mean_squared_log_error(y_train, train_preds),\n        \"Valid RMSLE\": root_mean_squared_log_error(y_valid, valid_preds),\n        \"Training R^2\": pipeline.score(X_train, y_train),\n        \"Valid R^2\": pipeline.score(X_valid, y_valid)\n    }\n    return scores\n\n# Fit and evaluate pipeline\nmodel_pipeline.fit(X_train, y_train)\npipeline_scores = evaluate_pipeline(model_pipeline, X_train, y_train, X_valid, y_valid)\nprint(\"\\nPipeline Scores:\")\npipeline_scores\n</pre> import pandas as pd import numpy as np  from sklearn.compose import ColumnTransformer from sklearn.ensemble import RandomForestRegressor from sklearn.impute import SimpleImputer from sklearn.metrics import mean_absolute_error, root_mean_squared_log_error from sklearn.preprocessing import OrdinalEncoder, FunctionTransformer from sklearn.pipeline import Pipeline   # Import and prepare data train_df = pd.read_csv(\"../data/bluebook-for-bulldozers/Train.csv\",                        parse_dates=[\"saledate\"],                        low_memory=False).sort_values(by=\"saledate\", ascending=True)  valid_df = pd.read_csv(\"../data/bluebook-for-bulldozers/Valid.csv\",                        parse_dates=[\"saledate\"])  valid_solution = pd.read_csv(\"../data/bluebook-for-bulldozers/ValidSolution.csv\") valid_df[\"SalePrice\"] = valid_df[\"SalesID\"].map(valid_solution.set_index(\"SalesID\")[\"SalePrice\"]) valid_df = valid_df.sort_values(\"saledate\", ascending=True).reset_index(drop=True)  # Add datetime features def add_datetime_features_to_df(df, date_column=\"saledate\"):     df = df.copy()     df[\"saleYear\"] = df[date_column].dt.year     df[\"saleMonth\"] = df[date_column].dt.month     df[\"saleDay\"] = df[date_column].dt.day     df[\"saleDayofweek\"] = df[date_column].dt.dayofweek     df[\"saleDayofyear\"] = df[date_column].dt.dayofyear     return df.drop(date_column, axis=1)  # Apply datetime features train_df = add_datetime_features_to_df(train_df) valid_df = add_datetime_features_to_df(valid_df)  # Split data into features and labels X_train = train_df.drop(\"SalePrice\", axis=1) y_train = train_df[\"SalePrice\"] X_valid = valid_df.drop(\"SalePrice\", axis=1) y_valid = valid_df[\"SalePrice\"]  # Define feature types numeric_features = [label for label, content in X_train.items()                     if pd.api.types.is_numeric_dtype(content)] categorical_features = [label for label, content in X_train.items()                         if not pd.api.types.is_numeric_dtype(content)]  # Create preprocessing steps numeric_transformer = Pipeline(steps=[     ('imputer', SimpleImputer(strategy='median')) ])  categorical_transformer = Pipeline(steps=[     ('string_converter', FunctionTransformer(lambda x: x.astype(str))), # convert values to string     ('ordinal', OrdinalEncoder(handle_unknown='use_encoded_value',                               unknown_value=np.nan,                               encoded_missing_value=np.nan)), ])  # Create preprocessor using ColumnTransformer preprocessor = ColumnTransformer(     transformers=[         ('numerical_transforms', numeric_transformer, numeric_features),         ('categorical_transforms', categorical_transformer, categorical_features)     ])  # Create full pipeline model_pipeline = Pipeline([     ('preprocessor', preprocessor),     ('regressor', RandomForestRegressor(         n_estimators=90,         max_depth=None,         min_samples_leaf=1,         min_samples_split=5,         max_features=0.5,         n_jobs=-1,         max_samples=None     )) ])  # Function to evaluate the pipeline def evaluate_pipeline(pipeline, X_train, y_train, X_valid, y_valid):     # Make predictions     train_preds = pipeline.predict(X_train)     valid_preds = pipeline.predict(X_valid)          # Calculate scores     scores = {         \"Training MAE\": mean_absolute_error(y_train, train_preds),         \"Valid MAE\": mean_absolute_error(y_valid, valid_preds),         \"Training RMSLE\": root_mean_squared_log_error(y_train, train_preds),         \"Valid RMSLE\": root_mean_squared_log_error(y_valid, valid_preds),         \"Training R^2\": pipeline.score(X_train, y_train),         \"Valid R^2\": pipeline.score(X_valid, y_valid)     }     return scores  # Fit and evaluate pipeline model_pipeline.fit(X_train, y_train) pipeline_scores = evaluate_pipeline(model_pipeline, X_train, y_train, X_valid, y_valid) print(\"\\nPipeline Scores:\") pipeline_scores <pre>\nPipeline Scores:\n</pre> Out[247]: <pre>{'Training MAE': np.float64(1951.4776197781914),\n 'Valid MAE': np.float64(5974.931566226864),\n 'Training RMSLE': np.float64(0.10196097739473307),\n 'Valid RMSLE': np.float64(0.24760612684722114),\n 'Training R^2': 0.9811027965058758,\n 'Valid R^2': 0.8807288353268701}</pre> In\u00a0[148]: Copied! <pre>import pandas as pd\nimport numpy as np\n\nfrom sklearn.compose import ColumnTransformer\nfrom sklearn.ensemble import HistGradientBoostingRegressor\nfrom sklearn.impute import SimpleImputer\nfrom sklearn.metrics import mean_absolute_error, root_mean_squared_log_error\nfrom sklearn.preprocessing import OrdinalEncoder, FunctionTransformer, StandardScaler\nfrom sklearn.pipeline import Pipeline\n\n# Import and prepare data\ntrain_df = pd.read_csv(\"../data/bluebook-for-bulldozers/Train.csv\",\n                       parse_dates=[\"saledate\"],\n                       low_memory=False).sort_values(by=\"saledate\", ascending=True)\n\nvalid_df = pd.read_csv(\"../data/bluebook-for-bulldozers/Valid.csv\",\n                       parse_dates=[\"saledate\"])\n\nvalid_solution = pd.read_csv(\"../data/bluebook-for-bulldozers/ValidSolution.csv\")\nvalid_df[\"SalePrice\"] = valid_df[\"SalesID\"].map(valid_solution.set_index(\"SalesID\")[\"SalePrice\"])\nvalid_df = valid_df.sort_values(\"saledate\", ascending=True).reset_index(drop=True)\n\n# Add datetime features\ndef add_datetime_features_to_df(df, date_column=\"saledate\"):\n    df = df.copy()\n    df[\"saleYear\"] = df[date_column].dt.year\n    df[\"saleMonth\"] = df[date_column].dt.month\n    df[\"saleDay\"] = df[date_column].dt.day\n    df[\"saleDayofweek\"] = df[date_column].dt.dayofweek\n    df[\"saleDayofyear\"] = df[date_column].dt.dayofyear\n    return df.drop(date_column, axis=1)\n\n# Apply datetime features\ntrain_df = add_datetime_features_to_df(train_df)\nvalid_df = add_datetime_features_to_df(valid_df)\n\n# Split data into features and labels\nX_train = train_df.drop(\"SalePrice\", axis=1)\ny_train = train_df[\"SalePrice\"]\nX_valid = valid_df.drop(\"SalePrice\", axis=1)\ny_valid = valid_df[\"SalePrice\"]\n\n# Define feature types\nnumeric_features = [label for label, content in X_train.items() \n                   if pd.api.types.is_numeric_dtype(content)]\ncategorical_features = [label for label, content in X_train.items() \n                       if not pd.api.types.is_numeric_dtype(content)]\n\n# Create preprocessing steps for different types of values\nnumeric_transformer = Pipeline(steps=[\n    ('imputer', SimpleImputer(strategy='median')),\n])\n\ncategorical_transformer = Pipeline(steps=[\n    ('string_converter', FunctionTransformer(lambda x: x.astype(str))), # convert values to string\n    ('ordinal', OrdinalEncoder(categories='auto',\n                               handle_unknown='use_encoded_value',\n                               unknown_value=np.nan,\n                               encoded_missing_value=np.nan)), \n])\n\n# Create preprocessor using ColumnTransformer\npreprocessor = ColumnTransformer(\n    transformers=[\n        ('numerical_transforms', numeric_transformer, numeric_features),\n        ('categorical_transforms', categorical_transformer, categorical_features)\n    ])\n\n# Create full pipeline\nmodel_pipeline_hist_gradient_boosting_regressor = Pipeline([\n    ('preprocessor', preprocessor),\n    ('regressor', HistGradientBoostingRegressor()) # Change model to HistGradientBoostingRegressor\n])\n\n# Function to evaluate the pipeline\ndef evaluate_pipeline(pipeline, X_train, y_train, X_valid, y_valid):\n    # Make predictions\n    train_preds = pipeline.predict(X_train)\n    valid_preds = pipeline.predict(X_valid)\n    \n    # Calculate scores\n    scores = {\n        \"Training MAE\": mean_absolute_error(y_train, train_preds),\n        \"Valid MAE\": mean_absolute_error(y_valid, valid_preds),\n        \"Training RMSLE\": root_mean_squared_log_error(y_train, train_preds),\n        \"Valid RMSLE\": root_mean_squared_log_error(y_valid, valid_preds),\n        \"Training R^2\": pipeline.score(X_train, y_train),\n        \"Valid R^2\": pipeline.score(X_valid, y_valid)\n    }\n    return scores\n\n# Fit and evaluate pipeline\nprint(f\"[INFO] Fitting HistGradientBoostingRegressor model with pipeline...\")\nmodel_pipeline_hist_gradient_boosting_regressor.fit(X_train, y_train)\nprint(f\"[INFO] Evaluating HistGradientBoostingRegressor model with pipeline...\")\npipeline_hist_scores = evaluate_pipeline(model_pipeline_hist_gradient_boosting_regressor, X_train, y_train, X_valid, y_valid)\nprint(\"\\nPipeline HistGradientBoostingRegressor Scores:\")\npipeline_hist_scores\n</pre> import pandas as pd import numpy as np  from sklearn.compose import ColumnTransformer from sklearn.ensemble import HistGradientBoostingRegressor from sklearn.impute import SimpleImputer from sklearn.metrics import mean_absolute_error, root_mean_squared_log_error from sklearn.preprocessing import OrdinalEncoder, FunctionTransformer, StandardScaler from sklearn.pipeline import Pipeline  # Import and prepare data train_df = pd.read_csv(\"../data/bluebook-for-bulldozers/Train.csv\",                        parse_dates=[\"saledate\"],                        low_memory=False).sort_values(by=\"saledate\", ascending=True)  valid_df = pd.read_csv(\"../data/bluebook-for-bulldozers/Valid.csv\",                        parse_dates=[\"saledate\"])  valid_solution = pd.read_csv(\"../data/bluebook-for-bulldozers/ValidSolution.csv\") valid_df[\"SalePrice\"] = valid_df[\"SalesID\"].map(valid_solution.set_index(\"SalesID\")[\"SalePrice\"]) valid_df = valid_df.sort_values(\"saledate\", ascending=True).reset_index(drop=True)  # Add datetime features def add_datetime_features_to_df(df, date_column=\"saledate\"):     df = df.copy()     df[\"saleYear\"] = df[date_column].dt.year     df[\"saleMonth\"] = df[date_column].dt.month     df[\"saleDay\"] = df[date_column].dt.day     df[\"saleDayofweek\"] = df[date_column].dt.dayofweek     df[\"saleDayofyear\"] = df[date_column].dt.dayofyear     return df.drop(date_column, axis=1)  # Apply datetime features train_df = add_datetime_features_to_df(train_df) valid_df = add_datetime_features_to_df(valid_df)  # Split data into features and labels X_train = train_df.drop(\"SalePrice\", axis=1) y_train = train_df[\"SalePrice\"] X_valid = valid_df.drop(\"SalePrice\", axis=1) y_valid = valid_df[\"SalePrice\"]  # Define feature types numeric_features = [label for label, content in X_train.items()                     if pd.api.types.is_numeric_dtype(content)] categorical_features = [label for label, content in X_train.items()                         if not pd.api.types.is_numeric_dtype(content)]  # Create preprocessing steps for different types of values numeric_transformer = Pipeline(steps=[     ('imputer', SimpleImputer(strategy='median')), ])  categorical_transformer = Pipeline(steps=[     ('string_converter', FunctionTransformer(lambda x: x.astype(str))), # convert values to string     ('ordinal', OrdinalEncoder(categories='auto',                                handle_unknown='use_encoded_value',                                unknown_value=np.nan,                                encoded_missing_value=np.nan)),  ])  # Create preprocessor using ColumnTransformer preprocessor = ColumnTransformer(     transformers=[         ('numerical_transforms', numeric_transformer, numeric_features),         ('categorical_transforms', categorical_transformer, categorical_features)     ])  # Create full pipeline model_pipeline_hist_gradient_boosting_regressor = Pipeline([     ('preprocessor', preprocessor),     ('regressor', HistGradientBoostingRegressor()) # Change model to HistGradientBoostingRegressor ])  # Function to evaluate the pipeline def evaluate_pipeline(pipeline, X_train, y_train, X_valid, y_valid):     # Make predictions     train_preds = pipeline.predict(X_train)     valid_preds = pipeline.predict(X_valid)          # Calculate scores     scores = {         \"Training MAE\": mean_absolute_error(y_train, train_preds),         \"Valid MAE\": mean_absolute_error(y_valid, valid_preds),         \"Training RMSLE\": root_mean_squared_log_error(y_train, train_preds),         \"Valid RMSLE\": root_mean_squared_log_error(y_valid, valid_preds),         \"Training R^2\": pipeline.score(X_train, y_train),         \"Valid R^2\": pipeline.score(X_valid, y_valid)     }     return scores  # Fit and evaluate pipeline print(f\"[INFO] Fitting HistGradientBoostingRegressor model with pipeline...\") model_pipeline_hist_gradient_boosting_regressor.fit(X_train, y_train) print(f\"[INFO] Evaluating HistGradientBoostingRegressor model with pipeline...\") pipeline_hist_scores = evaluate_pipeline(model_pipeline_hist_gradient_boosting_regressor, X_train, y_train, X_valid, y_valid) print(\"\\nPipeline HistGradientBoostingRegressor Scores:\") pipeline_hist_scores <pre>[INFO] Fitting HistGradientBoostingRegressor model with pipeline...\n[INFO] Evaluating HistGradientBoostingRegressor model with pipeline...\n\nPipeline HistGradientBoostingRegressor Scores:\n</pre> Out[148]: <pre>{'Training MAE': np.float64(5638.6121797753785),\n 'Valid MAE': np.float64(7264.258786098576),\n 'Training RMSLE': np.float64(0.2691456681483351),\n 'Valid RMSLE': np.float64(0.30482586120872424),\n 'Training R^2': 0.8646511348082063,\n 'Valid R^2': 0.8319021596407035}</pre> In\u00a0[7]: Copied! <pre>%%time\n\nimport pandas as pd\nimport numpy as np\nfrom sklearn.impute import SimpleImputer\nfrom sklearn.preprocessing import OneHotEncoder\nfrom sklearn.ensemble import RandomForestRegressor\nfrom sklearn.metrics import mean_absolute_error, root_mean_squared_log_error\nfrom sklearn.pipeline import Pipeline\nfrom sklearn.compose import ColumnTransformer\nfrom sklearn.preprocessing import FunctionTransformer\n\n# Import and prepare data\ntrain_df = pd.read_csv(\"../data/bluebook-for-bulldozers/Train.csv\",\n                       parse_dates=[\"saledate\"],\n                       low_memory=False).sort_values(by=\"saledate\", ascending=True)\n\nvalid_df = pd.read_csv(\"../data/bluebook-for-bulldozers/Valid.csv\",\n                       parse_dates=[\"saledate\"])\n\nvalid_solution = pd.read_csv(\"../data/bluebook-for-bulldozers/ValidSolution.csv\")\nvalid_df[\"SalePrice\"] = valid_df[\"SalesID\"].map(valid_solution.set_index(\"SalesID\")[\"SalePrice\"])\nvalid_df = valid_df.sort_values(\"saledate\", ascending=True).reset_index(drop=True)\n\n# Add datetime features\ndef add_datetime_features_to_df(df, date_column=\"saledate\"):\n    df = df.copy()\n    df[\"saleYear\"] = df[date_column].dt.year\n    df[\"saleMonth\"] = df[date_column].dt.month\n    df[\"saleDay\"] = df[date_column].dt.day\n    df[\"saleDayofweek\"] = df[date_column].dt.dayofweek\n    df[\"saleDayofyear\"] = df[date_column].dt.dayofyear\n    return df.drop(date_column, axis=1)\n\n# Apply datetime features\ntrain_df = add_datetime_features_to_df(train_df)\nvalid_df = add_datetime_features_to_df(valid_df)\n\n# Split data\nX_train = train_df.drop(\"SalePrice\", axis=1)\ny_train = train_df[\"SalePrice\"]\nX_valid = valid_df.drop(\"SalePrice\", axis=1)\ny_valid = valid_df[\"SalePrice\"]\n\n# Define feature types\nnumeric_features = [label for label, content in X_train.items() \n                   if pd.api.types.is_numeric_dtype(content)]\ncategorical_features = [label for label, content in X_train.items() \n                       if not pd.api.types.is_numeric_dtype(content)]\n\n# Create preprocessing steps\nnumeric_transformer = Pipeline(steps=[\n    ('imputer', SimpleImputer(strategy='median'))\n])\n\ncategorical_transformer = Pipeline(steps=[\n    ('string_converter', FunctionTransformer(lambda x: x.astype(str))),\n    ('imputer', SimpleImputer(strategy='constant', fill_value='missing')), # fill missing values with the term \"missing\"\n    ('onehot', OneHotEncoder(handle_unknown='ignore', sparse_output=True)) # use OneHotEncoder instead of OrdinalEncoder\n])\n\n# Create preprocessor using ColumnTransformer\npreprocessor = ColumnTransformer(\n    transformers=[\n        ('num', numeric_transformer, numeric_features),\n        ('cat', categorical_transformer, categorical_features)\n    ],\n    verbose_feature_names_out=False  # Simplify feature names\n)\n\n# Create full pipeline\nmodel_one_hot_pipeline = Pipeline([\n    ('preprocessor', preprocessor),\n    ('regressor', RandomForestRegressor(\n        n_estimators=10,\n        max_depth=None,\n        min_samples_leaf=1,\n        min_samples_split=5,\n        max_features=0.5,\n        n_jobs=-1,\n        max_samples=None\n    ))\n])\n\n# Function to evaluate the pipeline\ndef evaluate_pipeline(pipeline, X_train, y_train, X_valid, y_valid):\n    # Make predictions\n    train_preds = pipeline.predict(X_train)\n    valid_preds = pipeline.predict(X_valid)\n    \n    # Calculate scores\n    scores = {\n        \"Training MAE\": mean_absolute_error(y_train, train_preds),\n        \"Valid MAE\": mean_absolute_error(y_valid, valid_preds),\n        \"Training RMSLE\": root_mean_squared_log_error(y_train, train_preds),\n        \"Valid RMSLE\": root_mean_squared_log_error(y_valid, valid_preds),\n        \"Training R^2\": pipeline.score(X_train, y_train),\n        \"Valid R^2\": pipeline.score(X_valid, y_valid)\n    }\n    return scores\n\n# Fit and evaluate pipeline\nprint(f\"[INFO] Fitting model with one hot encoded values...\")\nmodel_one_hot_pipeline.fit(X_train, y_train)\nprint(f\"[INFO] Evaluating model with one hot encoded values...\")\npipeline_one_hot_scores = evaluate_pipeline(model_one_hot_pipeline, X_train, y_train, X_valid, y_valid)\nprint(\"[INFO] Pipeline with one hot encoding scores:\")\npipeline_one_hot_scores\n</pre> %%time  import pandas as pd import numpy as np from sklearn.impute import SimpleImputer from sklearn.preprocessing import OneHotEncoder from sklearn.ensemble import RandomForestRegressor from sklearn.metrics import mean_absolute_error, root_mean_squared_log_error from sklearn.pipeline import Pipeline from sklearn.compose import ColumnTransformer from sklearn.preprocessing import FunctionTransformer  # Import and prepare data train_df = pd.read_csv(\"../data/bluebook-for-bulldozers/Train.csv\",                        parse_dates=[\"saledate\"],                        low_memory=False).sort_values(by=\"saledate\", ascending=True)  valid_df = pd.read_csv(\"../data/bluebook-for-bulldozers/Valid.csv\",                        parse_dates=[\"saledate\"])  valid_solution = pd.read_csv(\"../data/bluebook-for-bulldozers/ValidSolution.csv\") valid_df[\"SalePrice\"] = valid_df[\"SalesID\"].map(valid_solution.set_index(\"SalesID\")[\"SalePrice\"]) valid_df = valid_df.sort_values(\"saledate\", ascending=True).reset_index(drop=True)  # Add datetime features def add_datetime_features_to_df(df, date_column=\"saledate\"):     df = df.copy()     df[\"saleYear\"] = df[date_column].dt.year     df[\"saleMonth\"] = df[date_column].dt.month     df[\"saleDay\"] = df[date_column].dt.day     df[\"saleDayofweek\"] = df[date_column].dt.dayofweek     df[\"saleDayofyear\"] = df[date_column].dt.dayofyear     return df.drop(date_column, axis=1)  # Apply datetime features train_df = add_datetime_features_to_df(train_df) valid_df = add_datetime_features_to_df(valid_df)  # Split data X_train = train_df.drop(\"SalePrice\", axis=1) y_train = train_df[\"SalePrice\"] X_valid = valid_df.drop(\"SalePrice\", axis=1) y_valid = valid_df[\"SalePrice\"]  # Define feature types numeric_features = [label for label, content in X_train.items()                     if pd.api.types.is_numeric_dtype(content)] categorical_features = [label for label, content in X_train.items()                         if not pd.api.types.is_numeric_dtype(content)]  # Create preprocessing steps numeric_transformer = Pipeline(steps=[     ('imputer', SimpleImputer(strategy='median')) ])  categorical_transformer = Pipeline(steps=[     ('string_converter', FunctionTransformer(lambda x: x.astype(str))),     ('imputer', SimpleImputer(strategy='constant', fill_value='missing')), # fill missing values with the term \"missing\"     ('onehot', OneHotEncoder(handle_unknown='ignore', sparse_output=True)) # use OneHotEncoder instead of OrdinalEncoder ])  # Create preprocessor using ColumnTransformer preprocessor = ColumnTransformer(     transformers=[         ('num', numeric_transformer, numeric_features),         ('cat', categorical_transformer, categorical_features)     ],     verbose_feature_names_out=False  # Simplify feature names )  # Create full pipeline model_one_hot_pipeline = Pipeline([     ('preprocessor', preprocessor),     ('regressor', RandomForestRegressor(         n_estimators=10,         max_depth=None,         min_samples_leaf=1,         min_samples_split=5,         max_features=0.5,         n_jobs=-1,         max_samples=None     )) ])  # Function to evaluate the pipeline def evaluate_pipeline(pipeline, X_train, y_train, X_valid, y_valid):     # Make predictions     train_preds = pipeline.predict(X_train)     valid_preds = pipeline.predict(X_valid)          # Calculate scores     scores = {         \"Training MAE\": mean_absolute_error(y_train, train_preds),         \"Valid MAE\": mean_absolute_error(y_valid, valid_preds),         \"Training RMSLE\": root_mean_squared_log_error(y_train, train_preds),         \"Valid RMSLE\": root_mean_squared_log_error(y_valid, valid_preds),         \"Training R^2\": pipeline.score(X_train, y_train),         \"Valid R^2\": pipeline.score(X_valid, y_valid)     }     return scores  # Fit and evaluate pipeline print(f\"[INFO] Fitting model with one hot encoded values...\") model_one_hot_pipeline.fit(X_train, y_train) print(f\"[INFO] Evaluating model with one hot encoded values...\") pipeline_one_hot_scores = evaluate_pipeline(model_one_hot_pipeline, X_train, y_train, X_valid, y_valid) print(\"[INFO] Pipeline with one hot encoding scores:\") pipeline_one_hot_scores <pre>[INFO] Fitting model with one hot encoded values...\n[INFO] Evaluating model with one hot encoded values...\n[INFO] Pipeline with one hot encoding scores:\nCPU times: user 29min, sys: 23min 12s, total: 52min 13s\nWall time: 9min 14s\n</pre> Out[7]: <pre>{'Training MAE': np.float64(2133.748251811842),\n 'Valid MAE': np.float64(6176.810802667383),\n 'Training RMSLE': np.float64(0.11021214524792695),\n 'Valid RMSLE': np.float64(0.2539881442090813),\n 'Training R^2': 0.9759312990258391,\n 'Valid R^2': 0.870741470996933}</pre>"},{"location":"end-to-end-bluebook-bulldozer-price-regression-v2/#predicting-the-sale-price-of-bulldozers-using-machine-learning","title":"Predicting the Sale Price of Bulldozers using Machine Learning \ud83d\ude9c\u00b6","text":"<p>In this notebook, we're going to go through an example machine learning project to use the characteristics of bulldozers and their past sales prices to predict the sale price of future bulldozers based on their characteristics.</p> <ul> <li>Inputs: Bulldozer characteristics such as make year, base model, model series, state of sale (e.g. which US state was it sold in), drive system and more.</li> <li>Outputs: Bulldozer sale price (in USD).</li> </ul> <p>Since we're trying to predict a number, this kind of problem is known as a regression problem.</p> <p>And since we're going to predicting results with a time component (predicting future sales based on past sales), this is also known as a time series or forecasting problem.</p> <p>The data and evaluation metric we'll be using (root mean square log error or RMSLE) is from the Kaggle Bluebook for Bulldozers competition.</p> <p>The techniques used in here have been inspired and adapted from the fast.ai machine learning course.</p>"},{"location":"end-to-end-bluebook-bulldozer-price-regression-v2/#overview","title":"Overview\u00b6","text":"<p>Since we already have a dataset, we'll approach the problem with the following machine learning modelling framework.</p> 6 Step Machine Learning Modelling Framework (read more) <p>To work through these topics, we'll use pandas, Matplotlib and NumPy for data analysis, as well as, Scikit-Learn for machine learning and modelling tasks.</p> Tools that can be used for each step of the machine learning modelling process. <p>We'll work through each step and by the end of the notebook, we'll have a trained machine learning model which predicts the sale price of a bulldozer given different characteristics about it.</p>"},{"location":"end-to-end-bluebook-bulldozer-price-regression-v2/#6-step-machine-learning-framework","title":"6 Step Machine Learning Framework\u00b6","text":""},{"location":"end-to-end-bluebook-bulldozer-price-regression-v2/#1-problem-definition","title":"1. Problem Definition\u00b6","text":"<p>For this dataset, the problem we're trying to solve, or better, the question we're trying to answer is,</p> <p>How well can we predict the future sale price of a bulldozer, given its characteristics previous examples of how much similar bulldozers have been sold for?</p>"},{"location":"end-to-end-bluebook-bulldozer-price-regression-v2/#2-data","title":"2. Data\u00b6","text":"<p>Looking at the dataset from Kaggle we see that it contains historical sales data of bulldozers. Including things like, model type, size, sale date and more.</p> <p>There are 3 datasets:</p> <ol> <li>Train.csv - Historical bulldozer sales examples up to 2011 (close to 400,000 examples with 50+ different attributes, including <code>SalePrice</code> which is the target variable).</li> <li>Valid.csv - Historical bulldozer sales examples from January 1 2012 to April 30 2012 (close to 12,000 examples with the same attributes as Train.csv).</li> <li>Test.csv - Historical bulldozer sales examples from May 1 2012 to November 2012 (close to 12,000 examples but missing the <code>SalePrice</code> attribute, as this is what we'll be trying to predict).</li> </ol> <p>Note: You can download the dataset <code>bluebook-for-bulldozers</code> dataset directly from Kaggle. Alternatively, you can also download it directly from the course GitHub.</p>"},{"location":"end-to-end-bluebook-bulldozer-price-regression-v2/#3-evaluation","title":"3. Evaluation\u00b6","text":"<p>For this problem, Kaggle has set the evaluation metric to being root mean squared log error (RMSLE). As with many regression evaluations, the goal will be to get this value as low as possible (a low error value means our model's predictions are close to what the real values are).</p> <p>To see how well our model is doing, we'll calculate the RMSLE and then compare our results to others on the Kaggle leaderboard.</p>"},{"location":"end-to-end-bluebook-bulldozer-price-regression-v2/#4-features","title":"4. Features\u00b6","text":"<p>Features are different parts and attributes of the data.</p> <p>During this step, you'll want to start finding out what you can about the data.</p> <p>One of the most common ways to do this is to create a data dictionary.</p> <p>For this dataset, Kaggle provides a data dictionary which contains information about what each attribute of the dataset means.</p> <p>For example:</p> Variable Name Description Variable Type SalesID unique identifier of a particular sale of a machine at auction Independent  variable MachineID identifier for a particular machine; machines may have multiple sales Independent  variable ModelID identifier for a unique machine model (i.e. fiModelDesc) Independent  variable datasource source of the sale record; some sources are more diligent about reporting attributes of the machine than others. Note that a particular datasource may report on multiple auctioneerIDs. Independent  variable auctioneerID identifier of a particular auctioneer, i.e. company that sold the machine at auction. Not the same as datasource. Independent  variable YearMade year of manufacturer of the Machine Independent  variable MachineHoursCurrentMeter current usage of the machine in hours at time of sale (saledate); null or 0 means no hours have been reported for that sale Independent  variable UsageBand value (low, medium, high) calculated comparing this particular Machine-Sale hours to average usage for the fiBaseModel; e.g. 'Low' means this machine has fewer hours given its lifespan relative to the average of fiBaseModel. Independent  variable Saledate time of sale Independent  variable fiModelDesc Description of a unique machine model (see ModelID); concatenation of fiBaseModel &amp; fiSecondaryDesc &amp; fiModelSeries &amp; fiModelDescriptor Independent  variable State US State in which sale occurred Independent  variable Drive_System machine configuration; typically describes whether 2 or 4 wheel drive Independent  variable Enclosure machine configuration - does the machine have an enclosed cab or not Independent  variable Forks machine configuration - attachment used for lifting Independent  variable Pad_Type machine configuration - type of treads a crawler machine uses Independent  variable Ride_Control machine configuration - optional feature on loaders to make the ride smoother Independent  variable Transmission machine configuration - describes type of transmission; typically automatic or manual Independent  variable ... ... ... SalePrice cost of sale in USD Target/dependent variable <p>You can download the full version of this file directly from the Kaggle competition page (Kaggle account required) or view it on Google Sheets.</p> <p>With all of this being known, let's get started!</p> <p>First, we'll import the dataset and start exploring.</p>"},{"location":"end-to-end-bluebook-bulldozer-price-regression-v2/#1-importing-the-data-and-preparing-it-for-modelling","title":"1. Importing the data and preparing it for modelling\u00b6","text":"<p>First thing is first, let's get the libraries we need imported and the data we'll need for the project.</p> <p>We'll start by importing pandas, NumPy and matplotlib.</p>"},{"location":"end-to-end-bluebook-bulldozer-price-regression-v2/#11-parsing-dates","title":"1.1 Parsing dates\u00b6","text":"<p>When working with time series data, it's a good idea to make sure any date data is the format of a datetime object (a Python data type which encodes specific information about dates).</p> <p>We can tell pandas which columns to read in as dates by setting the <code>parse_dates</code> parameter in <code>pd.read_csv</code>.</p> <p>Once we've imported our CSV with the <code>saledate</code> column parsed, we can view information about our DataFrame again with <code>df.info()</code>.</p>"},{"location":"end-to-end-bluebook-bulldozer-price-regression-v2/#12-sorting-our-dataframe-by-saledate","title":"1.2 Sorting our DataFrame by saledate\u00b6","text":"<p>Now we've formatted our <code>saledate</code> column to be NumPy <code>datetime64[ns]</code> objects, we can use built-in pandas methods such as <code>sort_values</code> to sort our DataFrame by date.</p> <p>And considering this is a time series problem, sorting our DataFrame by date has the added benefit of making sure our data is sequential.</p> <p>In other words, we want to use examples from the past (example sale prices from previous dates) to try and predict future bulldozer sale prices.</p> <p>Let's use the <code>pandas.DataFrame.sort_values</code> method to sort our DataFrame by <code>saledate</code> in ascending order.</p>"},{"location":"end-to-end-bluebook-bulldozer-price-regression-v2/#13-adding-extra-features-to-our-dataframe","title":"1.3 Adding extra features to our DataFrame\u00b6","text":"<p>One way to potentially increase the predictive power of our data is to enhance it with more features.</p> <p>This practice is known as feature engineering, taking existing features and using them to create more/different features.</p> <p>There is no set in stone way to do feature engineering and often it takes quite a bit of practice/exploration/experimentation to figure out what might work and what won't.</p> <p>For now, we'll use our <code>saledate</code> column to add extra features such as:</p> <ul> <li>Year of sale</li> <li>Month of sale</li> <li>Day of sale</li> <li>Day of week sale (e.g. Monday = 1, Tuesday = 2)</li> <li>Day of year sale (e.g. January 1st = 1, January 2nd = 2)</li> </ul> <p>Since we're going to be manipulating the data, we'll make a copy of the original DataFrame and perform our changes there.</p> <p>This will keep the original DataFrame in tact if we need it again.</p>"},{"location":"end-to-end-bluebook-bulldozer-price-regression-v2/#14-inspect-values-of-other-columns","title":"1.4 Inspect values of other columns\u00b6","text":"<p>When first exploring a new problem, it's often a good idea to become as familiar with the data as you can.</p> <p>Of course, with a dataset that has over 400,000 samples, it's unlikely you'll ever get through every sample.</p> <p>But that's where the power of data analysis and machine learning can help.</p> <p>We can use pandas to aggregate thousands of samples into smaller more managable pieces.</p> <p>And as we'll see later on, we can use machine learning models to model the data and then later inspect which features the model thought were most important.</p> <p>How about we see which states sell the most bulldozers?</p>"},{"location":"end-to-end-bluebook-bulldozer-price-regression-v2/#2-model-driven-data-exploration","title":"2. Model driven data exploration\u00b6","text":"<p>We've performed a small Exploratory Data Analysis (EDA) as well as enriched it with some <code>datetime</code> attributes, now let's try to model it.</p> <p>Why model so early?</p> <p>Well, we know the evaluation metric (root mean squared log error or RMSLE) we're heading towards.</p> <p>We could spend more time doing EDA, finding more out about the data ourselves but what we'll do instead is use a machine learning model to help us do EDA whilst simultaneously working towards the best evaluation metric we can get.</p> <p>Remember, one of the biggest goals of starting any new machine learning project is reducing the time between experiments.</p> <p>Following the Scikit-Learn machine learning map and taking into account the fact we've got over 100,000 examples, we find a <code>sklearn.linear_model.SGDRegressor</code> or a <code>sklearn.ensemble.RandomForestRegressor</code> model might be a good candidate.</p> <p>Since we're worked with the Random Forest algorithm before (on the heart disease classification problem), let's try it out on our regression problem.</p> <p>Note: We're trying just one model here for now. But you can try many other kinds of models from the Scikit-Learn library, they mostly work with a similar API. There are even libraries such as <code>LazyPredict</code> which will try many models simultaneously and return a table with the results.</p>"},{"location":"end-to-end-bluebook-bulldozer-price-regression-v2/#21-inspecting-the-datatypes-in-our-dataframe","title":"2.1 Inspecting the datatypes in our DataFrame\u00b6","text":"<p>One way to help turn all of our data into numbers is to convert the columns with the <code>object</code> datatype into a <code>category</code> datatype using <code>pandas.CategoricalDtype</code>.</p> <p>Note: There are many different ways to convert values into numbers. And often the best way will be specific to the value you're trying to convert. The method we're going to use, converting all objects (that are mostly strings) to categories is one of the faster methods as it makes a quick assumption that each unique value is its own number.</p> <p>We can check the datatype of an individual column using the <code>.dtype</code> attribute and we can get its full name using <code>.dtype.name</code>.</p>"},{"location":"end-to-end-bluebook-bulldozer-price-regression-v2/#22-converting-strings-to-categories-with-pandas","title":"2.2 Converting strings to categories with pandas\u00b6","text":"<p>In pandas, one way to convert object/string values to numerical values is to convert them to categories or more specifically, the <code>pd.CategoricalDtype</code> datatype.</p> <p>This datatype keeps the underlying data the same (e.g. doesn't change the string) but enables easy conversion to a numeric code using <code>.cat.codes</code>.</p> <p>For example, the column <code>state</code> might have the values <code>'Alabama', 'Alaska', 'Arizona'...</code> and these could be mapped to numeric values <code>1, 2, 3...</code> respectively.</p> <p>To see this in action, let's first convert the object datatype columns to <code>\"category\"</code> datatype.</p> <p>We can do so by looping through the <code>.items()</code> of our DataFrame and reassigning each object datatype column using <code>pandas.Series.astype(dtype=\"category\")</code>.</p>"},{"location":"end-to-end-bluebook-bulldozer-price-regression-v2/#23-saving-our-preprocessed-data-part-1","title":"2.3 Saving our preprocessed data (part 1)\u00b6","text":"<p>Before we start doing any further preprocessing steps on our DataFrame, how about we save our current DataFrame to file so we could import it again later if necessary.</p> <p>Saving and updating your dataset as you go is common practice in machine learning problems. As your problem changes and evolves, the dataset you're working with will likely change too.</p> <p>Making checkpoints of your dataset is similar to making checkpoints of your code.</p>"},{"location":"end-to-end-bluebook-bulldozer-price-regression-v2/#24-finding-and-filling-missing-values","title":"2.4 Finding and filling missing values\u00b6","text":"<p>Let's remind ourselves of the missing values by getting the top 20 columns with the most missing values.</p> <p>We do so by summing the results of <code>pandas.DataFrame.isna()</code> and then using <code>sort_values(ascending=False)</code> to showcase the rows with the most missing.</p>"},{"location":"end-to-end-bluebook-bulldozer-price-regression-v2/#25-filling-missing-numerical-values","title":"2.5 Filling missing numerical values\u00b6","text":"<p>There's no set way to fill missing values in your dataset.</p> <p>And unless you're filling the missing samples with newly discovered actual data, every way you fill your dataset's missing values will introduce some sort of noise or bias.</p> <p>We'll start by filling the missing numerical values in ourdataet.</p> <p>To do this, we'll first find the numeric datatype columns.</p> <p>We can do by looping through the columns in our DataFrame and calling <code>pd.api.types.is_numeric_dtype(arr_or_dtype)</code> on them.</p>"},{"location":"end-to-end-bluebook-bulldozer-price-regression-v2/#26-discussing-possible-ways-to-handle-missing-values","title":"2.6 Discussing possible ways to handle missing values\u00b6","text":"<p>As previously discussed, there are many ways to fill missing values.</p> <p>For missing numeric values, some potential options are:</p> Method Pros Cons Fill with mean of column - Easy to calculate/implement  - Retains overall data distribution - Averages out variation  - Affected by outliers (e.g. if one value is much higher/lower than others) Fill with median of column - Easy to calculate/implement  - Robust to outliers  - Preserves center of data - Ignores data distribution shape Fill with mode of column - Easy to calculate/implement  - More useful for categorical-like data - May not make sense for continuous/numerical data Fill with 0 (or another constant) - Simple to implement  - Useful in certain contexts like counts - Introduces bias (e.g. if 0 was a value that meant something)  - Skews data (e.g. if many missing values, replacing all with 0 makes it look like that's the most common value) Forward/Backward fill (use previous/future values to fill future/previous values) - Maintains temporal continuity (for time series) - Assumes data is continuous, which may not be valid Use a calculation from other columns - Takes existing information and reinterprets it - Can result in unlikely outputs if calculations are not continuous Interpolate  (e.g. like dragging a cell in Excel/Google Sheets) - Captures trends  - Suitable for ordered data - Can introduce errors  - May assume linearity (data continues in a straight line) Drop missing values - Ensures complete data (only use samples with all information)  - Useful for small datasets - Can result in data loss (e.g. if many missing values are scattered across columns, data size can be dramatically reduced)  - Reduces dataset size <p>Which method you choose will be dataset and problem dependant and will likely require several phases of experimentation to see what works and what doesn't.</p> <p>For now, we'll fill our missing numeric values with the median value of the target column.</p> <p>We'll also add a binary column (0 or 1) with rows reflecting whether or not a value was missing.</p> <p>For example, <code>MachineHoursCurrentMeter_is_missing</code> will be a column with rows which have a value of <code>0</code> if that row's <code>MachineHoursCurrentMeter</code> column was not missing and <code>1</code> if it was.</p>"},{"location":"end-to-end-bluebook-bulldozer-price-regression-v2/#27-filling-missing-categorical-values-with-pandas","title":"2.7 Filling missing categorical values with pandas\u00b6","text":"<p>Now we've filled the numeric values, we'll do the same with the categorical values whilst ensuring that they are all numerical too.</p> <p>Let's first investigate the columns which aren't numeric (we've already worked with these).</p>"},{"location":"end-to-end-bluebook-bulldozer-price-regression-v2/#28-saving-our-preprocessed-data-part-2","title":"2.8 Saving our preprocessed data (part 2)\u00b6","text":"<p>One more step before we train new model!</p> <p>Let's save our work so far so we could re-import our preprocessed dataset if we wanted to.</p> <p>We'll save it to the <code>parquet</code> format again, this time with a suffix to show we've filled the missing values.</p>"},{"location":"end-to-end-bluebook-bulldozer-price-regression-v2/#29-fitting-a-machine-learning-model-to-our-preprocessed-data","title":"2.9 Fitting a machine learning model to our preprocessed data\u00b6","text":"<p>Now all of our data is numeric and there are no missing values, we should be able to fit a machine learning model to it!</p> <p>Let's reinstantiate our trusty <code>sklearn.ensemble.RandomForestRegressor</code> model.</p> <p>Since our dataset has a substantial amount of rows (~400k+), let's first make sure the model will work on a smaller sample of 1000 or so.</p> <p>Note: It's common practice on machine learning problems to see if your experiments will work on smaller scale problems (e.g. smaller amounts of data) before scaling them up to the full dataset. This practice enables you to try many different kinds of experiments with faster runtimes. The benefit of this is that you can figure out what doesn't work before spending more time on what does.</p> <p>Our <code>X</code> values (features) will be every column except the <code>SalePrice</code> column.</p> <p>And our <code>y</code> values (labels) will be the entirety of the <code>SalePrice</code> column.</p> <p>We'll time how long our smaller experiment takes using the magic function <code>%%time</code> and placing it at the top of the notebook cell.</p> <p>Note: You can find out more about the <code>%%time</code> magic command by typing <code>%%time?</code> (note the question mark on the end) in a notebook cell.</p>"},{"location":"end-to-end-bluebook-bulldozer-price-regression-v2/#210-a-big-but-fixable-mistake","title":"2.10 A big (but fixable) mistake\u00b6","text":"<p>One of the hard things about bugs in machine learning projects is that they are often silent.</p> <p>For example, our model seems to have fit the data with no issues and then evaluated with a good score.</p> <p>So what's wrong?</p> <p>It seems we've stumbled across one of the most common bugs in machine learning and that's data leakage (data from the training set leaking into the validation/testing sets).</p> <p>We've evaluated our model on the same data it was trained on.</p> <p>This isn't the model's fault either.</p> <p>It's our fault.</p> <p>Right back at the start we imported a file called <code>TrainAndValid.csv</code>, this file contains both the training and validation data.</p> <p>And while we preprocessed it to make sure there were no missing values and the samples were all numeric, we never split the data into separate training and validation splits.</p> <p>The right workflow would've been to train the model on the training split and then evaluate it on the unseen and separate validation split.</p> <p>Our evaluation scores above are quite good but they can't necessarily be trusted to be replicated on unseen data (data in the real world) because they've been obtained by evaluating the model on data its already seen during training.</p> <p>This would be the equivalent of a final exam at university containing all of the same questions as the practice exam without any changes, you may get a good grade, but does that good grade translate to the real world?</p> <p>Not to worry, we can fix this!</p> <p>How?</p> <p>We can import the training and validation datasets separately via <code>Train.csv</code> and <code>Valid.csv</code> respectively.</p> <p>Or we could import <code>TrainAndValid.csv</code> and perform the appropriate splits according the original Kaggle competition page (training data includes all samples prior to 2012 and validation data includes samples from January 1 2012 to April 30 2012).</p> <p>In both methods, we'll have to perform similar preprocessing steps we've done so far.</p> <p>Except because the validation data is supposed to remain as unseen data, we'll only use information from the training set to preprocess the validation set (and not mix the two).</p> <p>We'll work on this in the subsequent sections.</p> <p>The takeaway?</p> <p>Always (if possible) create appropriate data splits at the start of a project.</p> <p>Because it's one thing to train a machine learning model but if you can't evaluate it properly (on unseen data), how can you know how it'll perform (or may perform) in the real world on new and unseen data?</p>"},{"location":"end-to-end-bluebook-bulldozer-price-regression-v2/#3-splitting-data-into-the-right-trainvalidation-sets","title":"3. Splitting data into the right train/validation sets\u00b6","text":"<p>The bad news is, we evaluated our model on the same data we trained it on.</p> <p>The good news is, we get to practice importing and preprocessing our data again.</p> <p>This time we'll make sure we've got separate training and validation splits.</p> <p>Previously, we used pandas to ensure our data was all numeric and had no missing values.</p> <p>And we can still use pandas for things such as creating/altering date-related columns.</p> <p>But using pandas for all of our data preprocessing can be an issue with larger scale datasets or when new data is introduced.</p> <p>How about this time we add Scikit-Learn to the mix and make a reproducible pipeline for our data preprocessing needs?</p> <p>Note: Scikit-Learn has a fantastic guide on data transformations and in particular data preprocessing. I'd highly recommend spending an hour or so reading through this documentation, even if it doesn't make a lot of sense to begin with. Rest assured, with practice and experimentation you'll start to get the hang of it.</p> <p>According to the Kaggle data page, the train, validation and test sets are split according to dates.</p> <p>This makes sense since we're working on a time series problem (using past sale prices to try and predict future sale prices).</p> <p>Knowing this, randomly splitting our data into train, validation and test sets using something like <code>sklearn.model_selection.train_test_split()</code> wouldn't work as this would mix samples from different dates in an unintended way.</p> <p>Instead, we split our data into training, validation and test sets using the date each sample occured.</p> <p>In our case:</p> <ul> <li>Training data (<code>Train.csv</code>) = all samples up until 2011.</li> <li>Validation data (<code>Valid.csv</code>) = all samples form January 1, 2012 - April 30, 2012.</li> <li>Testing data (<code>Test.csv</code>) = all samples from May 1, 2012 - November 2012.</li> </ul> <p>Previously we imported <code>TrainAndValid.csv</code> which is a combination of <code>Train.csv</code> and <code>Valid.csv</code> in one file.</p> <p>We could split this based on the <code>saledate</code> column.</p> <p>However, we could also import the <code>Train.csv</code> and <code>Valid.csv</code> files separately (we'll import <code>Test.csv</code> later on when we've trained a model).</p> <p>We'll also import <code>ValidSolution.csv</code> which contains the <code>SalePrice</code> of <code>Valid.csv</code> and make sure we match the columns based on the <code>SalesID</code> key.</p> <p>Note: For more on making good training, validation and test sets, check out the post How (and why) to create a good validation set by Rachel Thomas as well as The importance of a test set by Daniel Bourke.</p>"},{"location":"end-to-end-bluebook-bulldozer-price-regression-v2/#31-trying-to-fit-a-model-on-our-training-data","title":"3.1 Trying to fit a model on our training data\u00b6","text":"<p>I'm a big fan of trying to fit a model on your dataset as early as possible.</p> <p>If it works, you'll have to inspect and check its results.</p> <p>And if it doesn't work, you'll get some insights into what you may have to do to your dataset to prepare it.</p> <p>Let's turn our DataFrames into features (<code>X</code>) by dropping the <code>SalePrice</code> column (this is the value we're trying to predict) and labels (<code>y</code>) by extracting the <code>SalePrice</code> column.</p> <p>Then we'll create a model using <code>sklearn.ensemble.RandomForestRegressor</code> and finally we'll try to fit it to only the training data.</p>"},{"location":"end-to-end-bluebook-bulldozer-price-regression-v2/#32-encoding-categorical-features-as-numbers-using-scikit-learn","title":"3.2 Encoding categorical features as numbers using Scikit-Learn\u00b6","text":"<p>We've preprocessed our data previously with pandas.</p> <p>And while this is a viable approach, how about we practice using another method?</p> <p>This time we'll use Scikit-Learn's built-in preprocessing methods.</p> <p>Why?</p> <p>Because it's good exposure to different techniques.</p> <p>And Scikit-Learn has many built-in helpful and well tested methods for preparing data.</p> <p>You can also string together many of these methods and create a reusable pipeline (you can think of this pipeline as plumbing for data).</p> <p>To preprocess our data with Scikit-Learn, we'll first define the numerical and categorical features of our dataset.</p>"},{"location":"end-to-end-bluebook-bulldozer-price-regression-v2/#33-fitting-a-model-to-our-preprocessed-training-data","title":"3.3 Fitting a model to our preprocessed training data\u00b6","text":"<p>We've used Scikit-Learn to convert the categorical data in our training and validation sets into numbers.</p> <p>But we haven't yet done anything with missing numerical values.</p> <p>As it turns out, we can still try and fit a model.</p> <p>Why?</p> <p>Because there are several estimators/models in Scikit-Learn that can handle missing (<code>NaN</code>) values.</p> <p>And our trusty <code>sklearn.ensemble.RandomForestRegressor</code> is one of them!</p> <p>Let's try it out on our <code>X_train_preprocessed</code> DataFrame.</p> <p>Note: For a list of all Scikit-Learn estimators that can handle <code>NaN</code> values, check out the Scikit-Learn imputation of missing values user guide.</p>"},{"location":"end-to-end-bluebook-bulldozer-price-regression-v2/#4-building-an-evaluation-function","title":"4. Building an evaluation function\u00b6","text":"<p>Evaluating a machine learning model is just as important as training one.</p> <p>And so because of this, let's create an evaluation function to make evaluation faster and reproducible.</p> <p>According to Kaggle for the Bluebook for Bulldozers competition, the evaluation function they use is root mean squared log error (RMSLE).</p> <p>$$ \\text{RMSLE} = \\sqrt{\\frac{1}{n} \\sum_{i=1}^{n} \\left( \\log(1 + \\hat{y}_i) - \\log(1 + y_i) \\right)^2} $$</p> <p>Where:</p> <ul> <li>$ \\hat{y}_i $ is the predicted value,</li> <li>$ y_i $ is the actual value,</li> <li>$ n $ is the number of observations.</li> </ul> <p>Contrast this with mean absolute error (MAE), another common regression metric.</p> <p>$$ \\text{MAE} = \\frac{1}{n} \\sum_{i=1}^{n} \\left| \\hat{y}_i - y_i \\right| $$</p> <p>With RMSLE, the relative error is more meaningful than the absolute error. You care more about ratios than absolute errors. For example, being off by $100 on a $1000 prediction (10% error) is more significant than being off by $100 on a $10,000 prediction (1% error). RMSLE is sensitive to large percentage errors.</p> <p>Where as with MAE, is more about exact differences, a $100 prediction error is weighted the same regardless of the actual value.</p> <p>In each of case, a lower value (closer to 0) is better.</p> <p>For any problem, it's important to define the evaluation metric you're going to try and improve on.</p> <p>In our case, let's create a function that calculates multiple evaluation metrics.</p> <p>Namely, we'll use:</p> <ul> <li>MAE (mean absolute error) via <code>sklearn.metrics.mean_absolute_error</code> - lower is better.</li> <li>RMSLE (root mean squared log error) via <code>sklearn.metrics.root_mean_squared_log_error</code> - lower is better.</li> <li>$R^2$ (R-squared or coefficient of determination) via the <code>score</code> method - higher is better.</li> </ul> <p>For MAE and RMSLE we'll be comparing the model's predictions to the truth labels.</p> <p>We can get an array of predicted values from our model using <code>model.predict(X=features_to_predict_on)</code>.</p>"},{"location":"end-to-end-bluebook-bulldozer-price-regression-v2/#5-tuning-our-models-hyperparameters","title":"5. Tuning our model's hyperparameters\u00b6","text":"<p>Hyperparameters are the settings we can change on our model.</p> <p>And tuning hyperparameters on a given model can often alter its performance on a given dataset.</p> <p>Ideally, changing hyperparameters would lead to better results.</p> <p>However, it's often hard to know what hyperparameter changes would improve a model ahead of time.</p> <p>So what we can do is run several experiments across various different hyperparameter settings and record which lead to the best results.</p>"},{"location":"end-to-end-bluebook-bulldozer-price-regression-v2/#51-making-our-modelling-experiments-faster-to-speed-up-hyperparameter-tuning","title":"5.1 Making our modelling experiments faster (to speed up hyperparameter tuning)\u00b6","text":"<p>Because of the size of our dataset (~400,000 rows), retraining an entire model (about 1-1.5 minutes on my MacBook Pro M1 Pro) for each new set of hyperparameters would take far too long to continuing experimenting as fast as we want to.</p> <p>So what we'll do is take a sample of the training set and tune the hyperparameters on that before training a larger model.</p> <p>Note: If you're experiments are taking longer than 10-seconds (or far longer than what you can interact with), you should be trying to speed things up. You can speed experiments up by sampling less data, using a faster computer or using a smaller model.</p> <p>We can take a artificial sample of the training set by altering the number of samples seen by each <code>n_estimator</code> (an <code>n_estimator</code> is a decision tree a random forest will create during training, more trees generally leads to better performance but sacrifices compute time) in <code>sklearn.ensemble.RandomForestRegressor</code> using the <code>max_samples</code> parameter.</p> <p>For example, setting <code>max_samples</code> to 10,000 means every <code>n_estimator</code> (default 100) in our <code>RandomForestRegressor</code> will only see 10,000 random samples from our DataFrame instead of the entire ~400,000.</p> <p>In other words, we'll be looking at 40x less samples which means we should get faster computation speeds but we should also  expect our results to worsen (because the model has less samples to learn patterns from).</p> <p>Let's see if reducing the number samples speeds up our modelling time.</p>"},{"location":"end-to-end-bluebook-bulldozer-price-regression-v2/#52-hyperparameter-tuning-with-randomizedsearchcv","title":"5.2 Hyperparameter tuning with RandomizedSearchCV\u00b6","text":"<p>The goal of hyperparameter tuning is to values for our model's settings which lead to better results.</p> <p>We could sit there and do this by hand, adjusting parameters on <code>sklearn.ensemble.RandomForestRegressor</code> such as <code>n_estimators</code>, <code>max_depth</code>, <code>min_samples_split</code> and more.</p> <p>However, this would quite tedious.</p> <p>Instead, we can define a dictionary of hyperparametmer settings in the form <code>{\"hyperparamter_name\": [values_to_test]}</code> and then use <code>sklearn.model_selection.RandomizedSearchCV</code> (randomly search for best combination of hyperparameters) or <code>sklearn.model_selection.GridSearchCV</code> (exhaustively search for best combination of hyperparameters) to go through all of these settings for us on a given model and dataset and then record which perform best.</p> <p>A general workflow is to start with a large number and wide range of potential settings and use <code>RandomizedSearchCV</code> to search across these randomly for a limited number of iterations (e.g. <code>n_iter=10</code>).</p> <p>And then take the best results and narrow the search space down before exhaustively search for the best hyperparameters with <code>GridSearchCV</code>.</p> <p>Let's start trying to find better hyperparameters by:</p> <ol> <li>Define a dictionary of hyperparameter values for our <code>RandomForestRegressor</code> model. We'll keep <code>max_samples=10000</code> so our experiments run faster.</li> <li>Setup an instance of <code>RandomizedSearchCV</code> to explore the parameter values defined in step 1. We can adjust how many sets of hyperparameters our model tries using the <code>n_iter</code> parameter as well as how many times our model performs cross-validation using the <code>cv</code> parameter. For example, setting <code>n_iter=20</code> and <code>cv=3</code> means there will be 3 cross-validation folds for each of the 20 different combinations of hyperparameters, a total of 60 (3*20) experiments.</li> <li>Fit the instance of <code>RandomizedSearchCV</code> to the data. This will automatically go through the defined number of iterations and record the results for each. The best model gets loaded at the end.</li> </ol> <p>Note: You can read more about the tuning of hyperparameters of an esimator/model in the Scikit-Learn user guide.</p>"},{"location":"end-to-end-bluebook-bulldozer-price-regression-v2/#53-training-a-model-with-the-best-hyperparameters","title":"5.3 Training a model with the best hyperparameters\u00b6","text":"<p>Like all good machine learning cooking shows, I prepared a model earlier.</p> <p>I tried 100 different combinations of hyperparameters (setting <code>n_iter=100</code> in <code>RandomizedSearchCV</code>) and found the best results came from the settings below.</p> <ul> <li><code>n_estimators=90</code></li> <li><code>max_depth=None</code></li> <li><code>min_samples_leaf=1</code></li> <li><code>min_samples_split=5</code></li> <li><code>max_features=0.5</code></li> <li><code>n_jobs=-1</code></li> <li><code>max_samples=None</code></li> </ul> <p>Note: This search (<code>n_iter=100</code>) took ~2-hours on my MacBook Pro M1 Pro. So it's kind of a set and come back later experiment. That's one of the things you'll have to get used to as a machine learning engineer, figuring out what to do whilst your model trains. I like to go for long walks or to the gym (rule of thumb: while my model trains, I train).</p> <p>We'll instantiate a new model with these discovered hyperparameters and reset the <code>max_samples</code> back to its original value.</p>"},{"location":"end-to-end-bluebook-bulldozer-price-regression-v2/#54-comparing-our-models-scores","title":"5.4 Comparing our model's scores\u00b6","text":"<p>We've built four models so far with varying amounts of data and hyperparameters.</p> <p>Let's compile the results into a DataFrame and then make a plot to compare them.</p>"},{"location":"end-to-end-bluebook-bulldozer-price-regression-v2/#6-saving-our-best-model-to-file","title":"6. Saving our best model to file\u00b6","text":"<p>Since we've confirmed our best model as our <code>ideal_model</code> object, we can save it to file so we can load it in later and use it without having to retrain it.</p> <p>Note: For more on model saving options with Scikit-Learn, see the documentation on model persistence.</p> <p>To save our model we can use the <code>joblib.dump</code> method.</p>"},{"location":"end-to-end-bluebook-bulldozer-price-regression-v2/#7-making-predictions-on-test-data","title":"7. Making predictions on test data\u00b6","text":"<p>Now we've got a trained model saved and loaded, it's time to make predictions on the test data.</p> <p>Our model is trained on data prior to 2011, however, the test data is from May 1 2012 to November 2012.</p> <p>So what we're doing is trying to use the patterns our model has learned from the training data to predict the sale price of a bulldozer with characteristics it's never seen before but are assumed to be similar to that of those in the training data.</p> <p>Let's load in the test data from <code>Test.csv</code>, we'll make sure to parse the dates of the <code>saledate</code> column.</p>"},{"location":"end-to-end-bluebook-bulldozer-price-regression-v2/#71-preprocessing-the-test-data-to-be-in-the-same-format-as-the-training-data","title":"7.1 Preprocessing the test data (to be in the same format as the training data)\u00b6","text":"<p>Our model has been trained on data preprocessed in a certain way.</p> <p>This means in order to make predictions on the test data, we need to take the same steps we used to preprocess the training data to preprocess the test data.</p> <p>Remember, whatever you do to preprocess the training data, you have to do to the test data.</p> <p>Let's recreate the steps we used for preprocessing the training data except this time we'll do it on the test data.</p> <p>First, we'll add the extra date features to breakdown the <code>saledate</code> column.</p>"},{"location":"end-to-end-bluebook-bulldozer-price-regression-v2/#8-making-a-prediction-on-a-custom-sample","title":"8. Making a prediction on a custom sample\u00b6","text":"<p>We've made predictions on the test dataset which contains sale data from May to November 2012.</p> <p>But how does our model go on a more recent bulldozer sale?</p> <p>If we were to find an advertisement on a bulldozer sale, could we use our model on the information in the advertisement to predict the sale price?</p> <p>In other words, how could we use our model on a single custom sample?</p> <p>It's one thing to predict on data that has already been formatted but it's another thing to be able to predict a on a completely new and unseen sample.</p> <p>Note: For predicting on a custom sample, the same rules apply as making predictions on the test dataset. The data you make predictions on should be in the same format that your model was trained on. For example, it should have all the same features and the numerical encodings should be in the same ballpark (e.g. preprocessed by the <code>ordinal_encoder</code> we fit to the training set). It's likely that samples you collect from the wild may not be as well formatted as samples in a pre-existing dataset. So it's the job of the machine learning engineer to be able to format/preprocess new samples in the same way a model was trained on.</p> <p>If we're going to make a prediction on a custom sample, it'll need to be in the same format as our other datasets.</p> <p>So let's remind ourselves of the columns/features in our test dataset.</p>"},{"location":"end-to-end-bluebook-bulldozer-price-regression-v2/#9-finding-the-most-important-predictive-features","title":"9. Finding the most important predictive features\u00b6","text":"<p>Since we've built a model which is able to make predictions, the people you share these predictions with (or yourself) might be curious of what parts of the data led to these predictions.</p> <p>This is where feature importance comes in.</p> <p>Feature importance seeks to figure out which different attributes of the data were most important when it comes to predicting the target variable.</p> <p>In our case, after our model learned the patterns in the data, which bulldozer sale attributes were most important for predicting its overall sale price?</p> <p>We can do this for our <code>sklearn.ensemble.RandomForestRegressor</code> instance using the <code>feature_importances_</code> attribute.</p> <p>Let's check it out.</p>"},{"location":"end-to-end-bluebook-bulldozer-price-regression-v2/#summary","title":"Summary\u00b6","text":"<p>We've covered a lot of ground.</p> <p>But there are some main takeaways to go over.</p> <ul> <li>Every machine learning problem is different - Since machine learning is such a widespread technology, it can be used for a multitude of different problems. In saying this, there will often be many different ways to approach a problem. In this example, we've focused on predicting a number, which is a regression problem. And since our data had a time component, it could also be considered a time series problem.</li> <li>The machine learner's motto: Experiment, experiment, experiment! - Since there are many different ways to approach machine learning problems, one of the best habits you can develop is an experimental mindset. That means not being afraid to try new things over and over. Because the more things you try, the quicker you can figure what doesn't work and the quicker you can start to move towards what does.</li> <li>Always keep the test set separate - If you can't evaluate your model on unseen data, how would you know how it will perform in the real world on future unseen data? Of course, using a test set isn't a perfect replica of the real world but if it's done right, it can give you a good idea. Because evaluating a model is just as important as training a model.</li> <li>If you've trained a model on a data in a certain format, you'll have to make predictions in the same format - Any preprocessing you do to the training dataset, you'll have to do to the validation, test and custom data. Any computed values should happen on the training set only and then be used to update any subsequent datasets.</li> </ul>"},{"location":"end-to-end-bluebook-bulldozer-price-regression-v2/#exercises","title":"Exercises\u00b6","text":"<ol> <li>Fill the missing values in the numeric columns with the median using Scikit-Learn and see if that helps our best model's performance (hint: see <code>sklearn.impute.SimpleImputer</code> for more).</li> <li>Try putting multiple steps together (e.g. preprocessing -&gt; modelling) with Scikit-Learn's <code>sklearn.pipeline.Pipeline</code> features.</li> <li>Try using another regression model/estimator on our preprocessed dataset and see how it goes. See the Scikit-Learn machine learning map for potential model options.</li> <li>Try replacing the <code>sklearn.preprocessing.OrdinalEncoder</code> we used for the categorical variables with <code>sklearn.preprocessing.OneHotEncoder</code> (you may even want to do this within a pipeline) with the <code>sklearn.ensemble.RandomForestRegressor</code> model and see how it performs. Which is better for our specific dataset?</li> </ol>"},{"location":"end-to-end-bluebook-bulldozer-price-regression-v2/#extra-curriculum","title":"Extra-curriculum\u00b6","text":"<p>The following resources are suggested extra reading and activities to add backing to the materials we've covered in this project.</p> <p>Reading documentation and knowing where to find information is one of the best skills you can develop as an engineer.</p> <ul> <li>Read the pandas IO tools documentation page for an idea of all the possible ways to get data in and out of pandas.</li> <li>See all of the available datatypes in the pandas user guide (knowing what type your data is in can help prevent a lot of future errors).</li> <li>Read the Scikit-Learn dataset transformations and data preprocessing guide for an overview of all the different ways you can preprocess and transform data.</li> <li>For more on saving and loading model objects with Scikit-Learn, see the documentation on model persistence.</li> <li>For more on the importance of creating good validation and test sets, I'd recommend reading How (and why) to create a good validation set by Rachel Thomas as well as The importance of a test set by Daniel Bourke.</li> <li>We've covered a handful of models in the Scikit-Learn library, however, there are some other ML models which are worth exploring such as CatBoost and XGBoost. Both of these models can handle missing values and are often touted as some of the most performant ML models on the market. A good extension would be to try get one of them working on our bulldozer data.<ul> <li>Bonus: You can also see a list of models in Scikit-Learn which can handle missing/NaN values.</li> </ul> </li> </ul>"},{"location":"end-to-end-bluebook-bulldozer-price-regression-v2/#example-exercise-solutions","title":"Example Exercise Solutions\u00b6","text":"<p>The following are examples of how to solve the above exercises.</p>"},{"location":"end-to-end-bluebook-bulldozer-price-regression-v2/#1-fill-the-missing-values-in-the-numeric-columns-with-the-median-using-scikit-learn-and-see-if-that-helps-our-best-models-performance","title":"1. Fill the missing values in the numeric columns with the median using Scikit-Learn and see if that helps our best model's performance\u00b6","text":""},{"location":"end-to-end-bluebook-bulldozer-price-regression-v2/#2-try-putting-multiple-steps-together-eg-preprocessing-modelling-with-scikit-learns-sklearnpipelinepipeline","title":"2. Try putting multiple steps together (e.g. preprocessing -&gt; modelling) with Scikit-Learn's <code>sklearn.pipeline.Pipeline</code>\u00b6","text":""},{"location":"end-to-end-bluebook-bulldozer-price-regression-v2/#3-try-using-another-regression-modelestimator-on-our-preprocessed-dataset-and-see-how-it-goes","title":"3. Try using another regression model/estimator on our preprocessed dataset and see how it goes\u00b6","text":"<p>Going to use <code>sklearn.linear_model.HistGradientBoostingRegressor</code>.</p>"},{"location":"end-to-end-bluebook-bulldozer-price-regression-v2/#4-try-replacing-the-sklearnpreprocessingordinalencoder-we-used-for-the-categorical-variables-with-sklearnpreprocessingonehotencoder","title":"4. Try replacing the <code>sklearn.preprocessing.OrdinalEncoder</code> we used for the categorical variables with <code>sklearn.preprocessing.OneHotEncoder</code>\u00b6","text":"<p>Note: This may take quite a long time depending on your machine. For example, on my MacBook Pro M1 Pro it took ~10 minutes with <code>n_estimators=10</code> (9x lower than what we used for our <code>best_model</code>). This is because using <code>sklearn.preprocessing.OneHotEncoder</code> adds many more features to our dataset (each feature gets turned into an array of 0's and 1's for each unique value). And the more features, the longer it takes to compute and find patterns between them.</p>"},{"location":"end-to-end-dog-vision-v2/","title":"Introduction to TensorFlow, Deep Learning and Transfer Learning","text":"<p>View source code | Read notebook in online book format</p> In\u00a0[1]: Copied! <pre># Quick timestamp\nimport datetime\nprint(f\"Last updated: {datetime.datetime.now()}\")\n</pre> # Quick timestamp import datetime print(f\"Last updated: {datetime.datetime.now()}\") <pre>Last updated: 2024-04-26 01:26:48.838163\n</pre> In\u00a0[2]: Copied! <pre>import tensorflow as tf\ntf.__version__\n</pre> import tensorflow as tf tf.__version__ Out[2]: <pre>'2.15.0'</pre> <p>Nice!</p> <p>Note: If you want to run TensorFlow locally, you can follow the TensorFlow installation guide.</p> <p>Now let's check to see if TensorFlow has access to a GPU (this isn't 100% required to complete this project but will speed things up dramatically).</p> <p>We can do so with the method <code>tf.config.list_physical_devices()</code>.</p> In\u00a0[3]: Copied! <pre># Do we have access to a GPU?\ndevice_list = tf.config.list_physical_devices()\nif \"GPU\" in [device.device_type for device in device_list]:\n  print(f\"[INFO] TensorFlow has GPU available to use. Woohoo!! Computing will be sped up!\")\n  print(f\"[INFO] Accessible devices:\\n{device_list}\")\nelse:\n  print(f\"[INFO] TensorFlow does not have GPU available to use. Models may take a while to train.\")\n  print(f\"[INFO] Accessible devices:\\n{device_list}\")\n</pre> # Do we have access to a GPU? device_list = tf.config.list_physical_devices() if \"GPU\" in [device.device_type for device in device_list]:   print(f\"[INFO] TensorFlow has GPU available to use. Woohoo!! Computing will be sped up!\")   print(f\"[INFO] Accessible devices:\\n{device_list}\") else:   print(f\"[INFO] TensorFlow does not have GPU available to use. Models may take a while to train.\")   print(f\"[INFO] Accessible devices:\\n{device_list}\") <pre>[INFO] TensorFlow has GPU available to use. Woohoo!! Computing will be sped up!\n[INFO] Accessible devices:\n[PhysicalDevice(name='/physical_device:CPU:0', device_type='CPU'), PhysicalDevice(name='/physical_device:GPU:0', device_type='GPU')]\n</pre> In\u00a0[4]: Copied! <pre># Download the dataset into train and test split using TensorFlow Datasets\n# import tensorflow_datasets as tfds\n# ds_train, ds_test = tfds.load('stanford_dogs', split=['train', 'test'])\n</pre> # Download the dataset into train and test split using TensorFlow Datasets # import tensorflow_datasets as tfds # ds_train, ds_test = tfds.load('stanford_dogs', split=['train', 'test']) In\u00a0[5]: Copied! <pre>from pathlib import Path\nfrom google.colab import drive\n\n# 1. Mount Google Drive (this will bring up a pop-up to sign-in/authenticate)\n# Note: This step is specifically for Google Colab, if you're working locally, you may need a different setup\ndrive.mount(\"/content/drive\")\n\n# 2. Setup constants\n# Note: For constants like this, you'll often see them created as variables with all capitals\nTARGET_DRIVE_PATH = Path(\"drive/MyDrive/tensorflow/dog_vision_data\")\nTARGET_FILES = [\"images.tar\", \"annotation.tar\", \"lists.tar\"]\nTARGET_URL = \"http://vision.stanford.edu/aditya86/ImageNetDogs\"\n\n# 3. Setup local path\nlocal_dir = Path(\"dog_vision_data\")\n\n# 4. Check if the target files exist in Google Drive, if so, copy them to Google Colab\nif all((TARGET_DRIVE_PATH / file).is_file() for file in TARGET_FILES):\n  print(f\"[INFO] Copying Dog Vision files from Google Drive to local directory...\")\n  print(f\"[INFO] Source dir: {TARGET_DRIVE_PATH} -&gt; Target dir: {local_dir}\")\n  !cp -r {TARGET_DRIVE_PATH} .\n  print(\"[INFO] Good to go!\")\n\nelse:\n  # 5. If the files don't exist in Google Drive, download them\n  print(f\"[INFO] Target files not found in Google Drive.\")\n  print(f\"[INFO] Downloading the target files... this shouldn't take too long...\")\n  for file in TARGET_FILES:\n    # wget is short for \"world wide web get\", as in \"get a file from the web\"\n    # -nc or --no-clobber = don't download files that already exist locally\n    # -P = save the target file to a specified prefix, in our case, local_dir\n    !wget -nc {TARGET_URL}/{file} -P {local_dir} # the \"!\" means to execute the command on the command line rather than in Python\n\n  print(f\"[INFO] Saving the target files to Google Drive, so they can be loaded later...\")\n\n  # 6. Ensure target directory in Google Drive exists\n  TARGET_DRIVE_PATH.mkdir(parents=True, exist_ok=True)\n\n  # 7. Copy downloaded files to Google Drive (so we can use them later and not have to re-download them)\n  !cp -r {local_dir}/* {TARGET_DRIVE_PATH}/\n</pre> from pathlib import Path from google.colab import drive  # 1. Mount Google Drive (this will bring up a pop-up to sign-in/authenticate) # Note: This step is specifically for Google Colab, if you're working locally, you may need a different setup drive.mount(\"/content/drive\")  # 2. Setup constants # Note: For constants like this, you'll often see them created as variables with all capitals TARGET_DRIVE_PATH = Path(\"drive/MyDrive/tensorflow/dog_vision_data\") TARGET_FILES = [\"images.tar\", \"annotation.tar\", \"lists.tar\"] TARGET_URL = \"http://vision.stanford.edu/aditya86/ImageNetDogs\"  # 3. Setup local path local_dir = Path(\"dog_vision_data\")  # 4. Check if the target files exist in Google Drive, if so, copy them to Google Colab if all((TARGET_DRIVE_PATH / file).is_file() for file in TARGET_FILES):   print(f\"[INFO] Copying Dog Vision files from Google Drive to local directory...\")   print(f\"[INFO] Source dir: {TARGET_DRIVE_PATH} -&gt; Target dir: {local_dir}\")   !cp -r {TARGET_DRIVE_PATH} .   print(\"[INFO] Good to go!\")  else:   # 5. If the files don't exist in Google Drive, download them   print(f\"[INFO] Target files not found in Google Drive.\")   print(f\"[INFO] Downloading the target files... this shouldn't take too long...\")   for file in TARGET_FILES:     # wget is short for \"world wide web get\", as in \"get a file from the web\"     # -nc or --no-clobber = don't download files that already exist locally     # -P = save the target file to a specified prefix, in our case, local_dir     !wget -nc {TARGET_URL}/{file} -P {local_dir} # the \"!\" means to execute the command on the command line rather than in Python    print(f\"[INFO] Saving the target files to Google Drive, so they can be loaded later...\")    # 6. Ensure target directory in Google Drive exists   TARGET_DRIVE_PATH.mkdir(parents=True, exist_ok=True)    # 7. Copy downloaded files to Google Drive (so we can use them later and not have to re-download them)   !cp -r {local_dir}/* {TARGET_DRIVE_PATH}/ <pre>Mounted at /content/drive\n[INFO] Copying Dog Vision files from Google Drive to local directory...\n[INFO] Source dir: drive/MyDrive/tensorflow/dog_vision_data -&gt; Target dir: dog_vision_data\n[INFO] Good to go!\n</pre> <p>Data downloaded!</p> <p>Nice work! This may seem like a bit of work but it's an important step with any deep learning project. Getting data to work with.</p> <p>Now if we get the contents of <code>local_dir</code> (<code>dog_vision_data</code>), what do we get?</p> <p>We can first make sure it exists with <code>Path.exists()</code> and then we can iterate through its contents with <code>Path.iterdir()</code> and print out the <code>.name</code> attribute of each file.</p> In\u00a0[6]: Copied! <pre>if local_dir.exists():\n  print(str(local_dir) + \"/\")\n  for item in local_dir.iterdir():\n    print(\"  \", item.name)\n</pre> if local_dir.exists():   print(str(local_dir) + \"/\")   for item in local_dir.iterdir():     print(\"  \", item.name) <pre>dog_vision_data/\n   lists.tar\n   images.tar\n   annotation.tar\n</pre> <p>Excellent! That's exactly the format we wanted.</p> <p>Now you might've noticed that each file ends in <code>.tar</code>.</p> <p>What's this?</p> <p>Searching \"what is .tar?\", I found:</p> <p>In computing, tar is a computer software utility for collecting many files into one archive file, often referred to as a tarball, for distribution or backup purposes.</p> <p>Source: Wikipedia tar page).</p> <p>Exploring a bit more, I found that the <code>.tar</code> format is similar to <code>.zip</code>, however, <code>.zip</code> offers compression, where as <code>.tar</code> mostly combines many files into one.</p> <p>So how do we \"untar\" the files in <code>images.tar</code>, <code>annotation.tar</code> and <code>lists.tar</code>?</p> <p>We can use the <code>!tar</code> command (or just <code>tar</code> from outside of a Jupyter Cell)!</p> <p>Doing this will expand all of the files within each of the <code>.tar</code> archives.</p> <p>We'll also use a couple of flags to help us out:</p> <ul> <li>The <code>-x</code> flag tells <code>tar</code> to extract files from an archive.</li> <li>The <code>-f</code> flag specifies that the following argument is the name of the archive file.</li> <li>You can combine flags by putting them together <code>-xf</code>.</li> </ul> <p>Let's try it out!</p> In\u00a0[7]: Copied! <pre># Untar images, notes/tags:\n# -x = extract files from the zipped file\n# -v = verbose\n# -z = decompress files\n# -f = tell tar which file to deal with\n!tar -xf dog_vision_data/images.tar\n!tar -xf dog_vision_data/annotation.tar\n!tar -xf dog_vision_data/lists.tar\n</pre> # Untar images, notes/tags: # -x = extract files from the zipped file # -v = verbose # -z = decompress files # -f = tell tar which file to deal with !tar -xf dog_vision_data/images.tar !tar -xf dog_vision_data/annotation.tar !tar -xf dog_vision_data/lists.tar <p>What new files did we get?</p> <p>We can check in Google Colab by inspecting the \"Files\" tab on the left.</p> <p>Or with Python by using <code>os.listdir(\".\")</code> where <code>\".\"</code> means \"the current directory\".</p> In\u00a0[8]: Copied! <pre>import os\n\nos.listdir(\".\") # \".\" stands for \"here\" or \"current directory\"\n</pre> import os  os.listdir(\".\") # \".\" stands for \"here\" or \"current directory\" Out[8]: <pre>['.config',\n 'dog_vision_data',\n 'file_list.mat',\n 'drive',\n 'train_list.mat',\n 'Images',\n 'Annotation',\n 'test_list.mat',\n 'sample_data']</pre> <p>Ooooh!</p> <p>Looks like we've got some new files!</p> <p>Specifically:</p> <ul> <li><code>train_list.mat</code> - a list of all the training set images.</li> <li><code>test_list.mat</code> - a list of all the testing set images.</li> <li><code>Images/</code> - a folder containing all of the images of dogs.</li> <li><code>Annotation/</code> - a folder containing all of the annotations for each image.</li> <li><code>file_list.mat</code> - a list of all the files (training and test list combined).</li> </ul> <p>Our next step is to go through them and see what we've got.</p> In\u00a0[9]: Copied! <pre>import scipy\n\n# Open lists of train and test .mat\ntrain_list = scipy.io.loadmat(\"train_list.mat\")\ntest_list = scipy.io.loadmat(\"test_list.mat\")\nfile_list = scipy.io.loadmat(\"file_list.mat\")\n\n# Let's inspect the output and type of the train_list\ntrain_list, type(train_list)\n</pre> import scipy  # Open lists of train and test .mat train_list = scipy.io.loadmat(\"train_list.mat\") test_list = scipy.io.loadmat(\"test_list.mat\") file_list = scipy.io.loadmat(\"file_list.mat\")  # Let's inspect the output and type of the train_list train_list, type(train_list) Out[9]: <pre>({'__header__': b'MATLAB 5.0 MAT-file, Platform: GLNXA64, Created on: Sun Oct  9 08:36:13 2011',\n  '__version__': '1.0',\n  '__globals__': [],\n  'file_list': array([[array(['n02085620-Chihuahua/n02085620_5927.jpg'], dtype='&lt;U38')],\n         [array(['n02085620-Chihuahua/n02085620_4441.jpg'], dtype='&lt;U38')],\n         [array(['n02085620-Chihuahua/n02085620_1502.jpg'], dtype='&lt;U38')],\n         ...,\n         [array(['n02116738-African_hunting_dog/n02116738_6754.jpg'], dtype='&lt;U48')],\n         [array(['n02116738-African_hunting_dog/n02116738_9333.jpg'], dtype='&lt;U48')],\n         [array(['n02116738-African_hunting_dog/n02116738_2503.jpg'], dtype='&lt;U48')]],\n        dtype=object),\n  'annotation_list': array([[array(['n02085620-Chihuahua/n02085620_5927'], dtype='&lt;U34')],\n         [array(['n02085620-Chihuahua/n02085620_4441'], dtype='&lt;U34')],\n         [array(['n02085620-Chihuahua/n02085620_1502'], dtype='&lt;U34')],\n         ...,\n         [array(['n02116738-African_hunting_dog/n02116738_6754'], dtype='&lt;U44')],\n         [array(['n02116738-African_hunting_dog/n02116738_9333'], dtype='&lt;U44')],\n         [array(['n02116738-African_hunting_dog/n02116738_2503'], dtype='&lt;U44')]],\n        dtype=object),\n  'labels': array([[  1],\n         [  1],\n         [  1],\n         ...,\n         [120],\n         [120],\n         [120]], dtype=uint8)},\n dict)</pre> <p>Okay, looks like we get a dictionary with several fields we may be interested in.</p> <p>Let's check out the keys of the dictionary.</p> In\u00a0[10]: Copied! <pre>train_list.keys()\n</pre> train_list.keys() Out[10]: <pre>dict_keys(['__header__', '__version__', '__globals__', 'file_list', 'annotation_list', 'labels'])</pre> <p>My guess is that the <code>file_list</code> key is what we're after, as this looks like a large array of image names (the files all end in <code>.jpg</code>).</p> <p>How about we see how many files are in each <code>file_list</code> key?</p> In\u00a0[11]: Copied! <pre># Check the length of the file_list key\nprint(f\"Number of files in training list: {len(train_list['file_list'])}\")\nprint(f\"Number of files in testing list: {len(test_list['file_list'])}\")\nprint(f\"Number of files in full list: {len(file_list['file_list'])}\")\n</pre> # Check the length of the file_list key print(f\"Number of files in training list: {len(train_list['file_list'])}\") print(f\"Number of files in testing list: {len(test_list['file_list'])}\") print(f\"Number of files in full list: {len(file_list['file_list'])}\") <pre>Number of files in training list: 12000\nNumber of files in testing list: 8580\nNumber of files in full list: 20580\n</pre> <p>Beautiful! Looks like these lists contain our training and test splits and the full list has a list of all the files in the dataset.</p> <p>Let's inspect the <code>train_list['file_list']</code> further.</p> In\u00a0[12]: Copied! <pre>train_list['file_list']\n</pre> train_list['file_list'] Out[12]: <pre>array([[array(['n02085620-Chihuahua/n02085620_5927.jpg'], dtype='&lt;U38')],\n       [array(['n02085620-Chihuahua/n02085620_4441.jpg'], dtype='&lt;U38')],\n       [array(['n02085620-Chihuahua/n02085620_1502.jpg'], dtype='&lt;U38')],\n       ...,\n       [array(['n02116738-African_hunting_dog/n02116738_6754.jpg'], dtype='&lt;U48')],\n       [array(['n02116738-African_hunting_dog/n02116738_9333.jpg'], dtype='&lt;U48')],\n       [array(['n02116738-African_hunting_dog/n02116738_2503.jpg'], dtype='&lt;U48')]],\n      dtype=object)</pre> <p>Looks like we've got an array of arrays.</p> <p>How about we turn them into a Python list for easier handling?</p> <p>We can do so by extracting each individual item via indexing and list comprehension.</p> <p>Let's see what it's like to get a single file name.</p> In\u00a0[13]: Copied! <pre># Get a single filename\ntrain_list['file_list'][0][0][0]\n</pre> # Get a single filename train_list['file_list'][0][0][0] Out[13]: <pre>'n02085620-Chihuahua/n02085620_5927.jpg'</pre> <p>Now let's get a Python list of all the individual file names (e.g. <code>n02097130-giant_schnauzer/n02097130_2866.jpg</code>) so we can use them later.</p> In\u00a0[14]: Copied! <pre># Get a Python list of all file names for each list\ntrain_file_list = list([item[0][0] for item in train_list[\"file_list\"]])\ntest_file_list = list([item[0][0] for item in test_list[\"file_list\"]])\nfull_file_list = list([item[0][0] for item in file_list[\"file_list\"]])\n\nlen(train_file_list), len(test_file_list), len(full_file_list)\n</pre> # Get a Python list of all file names for each list train_file_list = list([item[0][0] for item in train_list[\"file_list\"]]) test_file_list = list([item[0][0] for item in test_list[\"file_list\"]]) full_file_list = list([item[0][0] for item in file_list[\"file_list\"]])  len(train_file_list), len(test_file_list), len(full_file_list) Out[14]: <pre>(12000, 8580, 20580)</pre> <p>Wonderful!</p> <p>How about we view a random sample of the filenames we extracted?</p> <p>Note: One of my favourite things to do whilst exploring data is to continually view random samples of it. Whether it be file names or images or text snippets. Why? You can always view the first X number of samples, however, I find that continually viewing random samples of the data gives you a better of overview of the different kinds of data you're working with. It also gives you the small chance of stumbling upon a potential error.</p> <p>We can view random samples of the data using Python's <code>random.sample()</code> method.</p> In\u00a0[15]: Copied! <pre>import random\n\nrandom.sample(train_file_list, k=10)\n</pre> import random  random.sample(train_file_list, k=10) Out[15]: <pre>['n02094258-Norwich_terrier/n02094258_439.jpg',\n 'n02113624-toy_poodle/n02113624_3624.jpg',\n 'n02102973-Irish_water_spaniel/n02102973_3635.jpg',\n 'n02102318-cocker_spaniel/n02102318_2048.jpg',\n 'n02098286-West_Highland_white_terrier/n02098286_1261.jpg',\n 'n02088238-basset/n02088238_10095.jpg',\n 'n02108915-French_bulldog/n02108915_9457.jpg',\n 'n02098286-West_Highland_white_terrier/n02098286_5979.jpg',\n 'n02109047-Great_Dane/n02109047_31274.jpg',\n 'n02095889-Sealyham_terrier/n02095889_760.jpg']</pre> <p>Now let's do a quick check to make sure none of the training image file names appear in the testing image file names list.</p> <p>This is important because the number 1 rule in machine learning is: always keep the test set separate from the training set.</p> <p>We can check that there are no overlaps by turning <code>train_file_list</code> into a Python <code>set()</code> and using the <code>intersection()</code> method.</p> In\u00a0[16]: Copied! <pre># How many files in the training set intersect with the testing set?\nlen(set(train_file_list).intersection(test_file_list))\n</pre> # How many files in the training set intersect with the testing set? len(set(train_file_list).intersection(test_file_list)) Out[16]: <pre>0</pre> <p>Excellent! Looks like there are no overlaps.</p> <p>We could even put an <code>assert</code> check to raise an error if there are any overlaps (e.g. the length of the intersection is greater than 0).</p> <p><code>assert</code> works in the fashion: <code>assert expression, message_if_expression_fails</code>.</p> <p>If the <code>assert</code> check doesn't output anything, we're good to go!</p> In\u00a0[17]: Copied! <pre># Make an assertion statement to check there are no overlaps (try changing test_file_list to train_file_list to see how it works)\nassert len(set(train_file_list).intersection(test_file_list)) == 0, \"There are overlaps between the training and test set files, please check them.\"\n</pre> # Make an assertion statement to check there are no overlaps (try changing test_file_list to train_file_list to see how it works) assert len(set(train_file_list).intersection(test_file_list)) == 0, \"There are overlaps between the training and test set files, please check them.\" <p>Woohoo!</p> <p>Looks like there's no overlaps, let's keep exploring the data.</p> In\u00a0[18]: Copied! <pre>os.listdir(\"Annotation\")[:10]\n</pre> os.listdir(\"Annotation\")[:10] Out[18]: <pre>['n02111129-Leonberg',\n 'n02102973-Irish_water_spaniel',\n 'n02110806-basenji',\n 'n02105251-briard',\n 'n02093991-Irish_terrier',\n 'n02099267-flat-coated_retriever',\n 'n02110627-affenpinscher',\n 'n02112137-chow',\n 'n02094114-Norfolk_terrier',\n 'n02095570-Lakeland_terrier']</pre> <p>Looks like there are files each with a dog breed name with several numbered files inside.</p> <p>Each of the files contains a HTML version of an annotation relating to an image.</p> <p>For example, <code>Annotation/n02085620-Chihuahua/n02085620_10074</code>:</p> <pre>&lt;annotation&gt;\n\t&lt;folder&gt;02085620&lt;/folder&gt;\n\t&lt;filename&gt;n02085620_10074&lt;/filename&gt;\n\t&lt;source&gt;\n\t\t&lt;database&gt;ImageNet database&lt;/database&gt;\n\t&lt;/source&gt;\n\t&lt;size&gt;\n\t\t&lt;width&gt;333&lt;/width&gt;\n\t\t&lt;height&gt;500&lt;/height&gt;\n\t\t&lt;depth&gt;3&lt;/depth&gt;\n\t&lt;/size&gt;\n\t&lt;segment&gt;0&lt;/segment&gt;\n\t&lt;object&gt;\n\t\t&lt;name&gt;Chihuahua&lt;/name&gt;\n\t\t&lt;pose&gt;Unspecified&lt;/pose&gt;\n\t\t&lt;truncated&gt;0&lt;/truncated&gt;\n\t\t&lt;difficult&gt;0&lt;/difficult&gt;\n\t\t&lt;bndbox&gt;\n\t\t\t&lt;xmin&gt;25&lt;/xmin&gt;\n\t\t\t&lt;ymin&gt;10&lt;/ymin&gt;\n\t\t\t&lt;xmax&gt;276&lt;/xmax&gt;\n\t\t\t&lt;ymax&gt;498&lt;/ymax&gt;\n\t\t&lt;/bndbox&gt;\n\t&lt;/object&gt;\n&lt;/annotation&gt;\n</pre> <p>The fields include the name of the image, the size of the image, the label of the object and where it is (bounding box coordinates).</p> <p>If we were performing object detection (finding the location of a thing in an image), we'd pay attention to the <code>&lt;bndbox&gt;</code> coordinates.</p> <p>However, since we're focused on classification, our main consideration is the mapping of image name to class name.</p> <p>Since we're dealing with 120 classes of dog breed, let's write a function to check the number of subfolders in the <code>Annotation</code> directory (there should be 120 subfolders, one for each breed of dog).</p> <p>To do so, we can use Python's <code>pathlib.Path</code> class, along with <code>Path.iterdir()</code> to loop over the contents of <code>Annotation</code> and <code>Path.is_dir()</code> to check if the target item is a directory.</p> In\u00a0[19]: Copied! <pre>from pathlib import Path\n\ndef count_subfolders(directory_path: str) -&gt; int:\n    \"\"\"\n    Count the number of subfolders in a given directory.\n\n    Args:\n    directory_path (str): The path to the directory in which to count subfolders.\n\n    Returns:\n    int: The number of subfolders in the specified directory.\n\n    Examples:\n    &gt;&gt;&gt; count_subfolders('/path/to/directory')\n    3  # if there are 3 subfolders in the specified directory\n    \"\"\"\n    return len([name for name in Path(directory_path).iterdir() if name.is_dir()])\n\n\ndirectory_path = \"Annotation\"\nfolder_count = count_subfolders(directory_path)\nprint(f\"Number of subfolders in {directory_path} directory: {folder_count}\")\n</pre> from pathlib import Path  def count_subfolders(directory_path: str) -&gt; int:     \"\"\"     Count the number of subfolders in a given directory.      Args:     directory_path (str): The path to the directory in which to count subfolders.      Returns:     int: The number of subfolders in the specified directory.      Examples:     &gt;&gt;&gt; count_subfolders('/path/to/directory')     3  # if there are 3 subfolders in the specified directory     \"\"\"     return len([name for name in Path(directory_path).iterdir() if name.is_dir()])   directory_path = \"Annotation\" folder_count = count_subfolders(directory_path) print(f\"Number of subfolders in {directory_path} directory: {folder_count}\") <pre>Number of subfolders in Annotation directory: 120\n</pre> <p>Perfect!</p> <p>There are 120 subfolders of annotations, one for each class of dog we'd like to identify.</p> <p>But on further inspection of our file lists, it looks like the class name is already in the filepath.</p> In\u00a0[20]: Copied! <pre># View a single training file pathname\ntrain_file_list[0]\n</pre> # View a single training file pathname train_file_list[0] Out[20]: <pre>'n02085620-Chihuahua/n02085620_5927.jpg'</pre> <p>With this information we know, that image <code>n02085620_5927.jpg</code> should contain a <code>Chihuahua</code>.</p> <p>Let's check.</p> <p>I searched \"how to display an image in Google Colab\" and found another answer on Stack Overflow.</p> <p>Turns out you can use <code>IPython.display.Image()</code>, as Google Colab comes with IPython (Interactive Python) built-in.</p> In\u00a0[21]: Copied! <pre>from IPython.display import Image\nImage(Path(\"Images\", train_file_list[0]))\n</pre> from IPython.display import Image Image(Path(\"Images\", train_file_list[0])) Out[21]: <p>Woah!</p> <p>We get an image of a dog!</p> In\u00a0[22]: Copied! <pre># Get a list of all image folders\nimage_folders = os.listdir(\"Images\")\nimage_folders[:10]\n</pre> # Get a list of all image folders image_folders = os.listdir(\"Images\") image_folders[:10] Out[22]: <pre>['n02111129-Leonberg',\n 'n02102973-Irish_water_spaniel',\n 'n02110806-basenji',\n 'n02105251-briard',\n 'n02093991-Irish_terrier',\n 'n02099267-flat-coated_retriever',\n 'n02110627-affenpinscher',\n 'n02112137-chow',\n 'n02094114-Norfolk_terrier',\n 'n02095570-Lakeland_terrier']</pre> <p>Excellent!</p> <p>Now let's make a dictionary which maps from the folder name to a simplified version of the class name, for example:</p> <pre><code>{'n02085782-Japanese_spaniel': 'japanese_spaniel',\n'n02106662-German_shepherd': 'german_shepherd',\n'n02093256-Staffordshire_bullterrier': 'staffordshire_bullterrier',\n...}\n</code></pre> In\u00a0[23]: Copied! <pre># Create folder name -&gt; class name dict\nfolder_to_class_name_dict = {}\nfor folder_name in image_folders:\n  # Turn folder name into class_name\n  # E.g. \"n02089078-black-and-tan_coonhound\" -&gt; \"black_and_tan_coonhound\"\n  # We'll split on the first \"-\" and join the rest of the string with \"_\" and then lower it\n  class_name = \"_\".join(folder_name.split(\"-\")[1:]).lower()\n  folder_to_class_name_dict[folder_name] = class_name\n\n# Make sure there are 120 entries in the dictionary\nassert len(folder_to_class_name_dict) == 120\n</pre> # Create folder name -&gt; class name dict folder_to_class_name_dict = {} for folder_name in image_folders:   # Turn folder name into class_name   # E.g. \"n02089078-black-and-tan_coonhound\" -&gt; \"black_and_tan_coonhound\"   # We'll split on the first \"-\" and join the rest of the string with \"_\" and then lower it   class_name = \"_\".join(folder_name.split(\"-\")[1:]).lower()   folder_to_class_name_dict[folder_name] = class_name  # Make sure there are 120 entries in the dictionary assert len(folder_to_class_name_dict) == 120 <p>Folder name to class name mapping created, let's view the first 10.</p> In\u00a0[24]: Copied! <pre>list(folder_to_class_name_dict.items())[:10]\n</pre> list(folder_to_class_name_dict.items())[:10] Out[24]: <pre>[('n02111129-Leonberg', 'leonberg'),\n ('n02102973-Irish_water_spaniel', 'irish_water_spaniel'),\n ('n02110806-basenji', 'basenji'),\n ('n02105251-briard', 'briard'),\n ('n02093991-Irish_terrier', 'irish_terrier'),\n ('n02099267-flat-coated_retriever', 'flat_coated_retriever'),\n ('n02110627-affenpinscher', 'affenpinscher'),\n ('n02112137-chow', 'chow'),\n ('n02094114-Norfolk_terrier', 'norfolk_terrier'),\n ('n02095570-Lakeland_terrier', 'lakeland_terrier')]</pre> <p>And we can get a list of unique dog names by getting the <code>values()</code> of the <code>folder_to_class_name_dict</code> and turning it into a list.</p> In\u00a0[25]: Copied! <pre>dog_names = sorted(list(folder_to_class_name_dict.values()))\ndog_names[:10]\n</pre> dog_names = sorted(list(folder_to_class_name_dict.values())) dog_names[:10] Out[25]: <pre>['affenpinscher',\n 'afghan_hound',\n 'african_hunting_dog',\n 'airedale',\n 'american_staffordshire_terrier',\n 'appenzeller',\n 'australian_terrier',\n 'basenji',\n 'basset',\n 'beagle']</pre> <p>Perfect!</p> <p>Now we've got:</p> <ol> <li><code>folder_to_class_name_dict</code> - a mapping from the folder name to the class name.</li> <li><code>dog_names</code> - a list of all the unique dog breeds we're working with.</li> </ol> In\u00a0[26]: Copied! <pre>import random\n\nfrom pathlib import Path\nfrom typing import List\n\nimport matplotlib.pyplot as plt\n\n# 1. Take in a select list of image paths\ndef plot_10_random_images_from_path_list(path_list: List[Path],\n                                         extract_title: bool=True) -&gt; None:\n  # 2. Set up a grid of plots\n  fig, axes = plt.subplots(nrows=2, ncols=5, figsize=(20, 10))\n\n  # 3. Randomly sample 10 paths from the list\n  samples = random.sample(path_list, 10)\n\n  # 4. Iterate through the flattened axes and corresponding sample paths\n  for i, ax in enumerate(axes.flat):\n\n    # 5. Get the target sample path (e.g. \"Images/n02087394-Rhodesian_ridgeback/n02087394_1161.jpg\")\n    sample_path = samples[i]\n\n    # 6. Extract the parent directory name to use as the title (if necessary)\n    # (e.g. n02087394-Rhodesian_ridgeback/n02087394_1161.jpg -&gt; n02087394-Rhodesian_ridgeback -&gt; rhodesian_ridgeback)\n    if extract_title:\n      sample_title = folder_to_class_name_dict[sample_path.parent.stem]\n    else:\n      sample_title = sample_path.parent.stem\n\n    # 7. Read the image file and plot it on the corresponding axis\n    ax.imshow(plt.imread(sample_path))\n\n    # 8. Set the title of the axis and turn of the axis (for pretty plots)\n    ax.set_title(sample_title)\n    ax.axis(\"off\")\n\n  # 9. Display the plot\n  plt.show()\n\nplot_10_random_images_from_path_list(path_list=[Path(\"Images\") / Path(file) for file in train_file_list])\n</pre> import random  from pathlib import Path from typing import List  import matplotlib.pyplot as plt  # 1. Take in a select list of image paths def plot_10_random_images_from_path_list(path_list: List[Path],                                          extract_title: bool=True) -&gt; None:   # 2. Set up a grid of plots   fig, axes = plt.subplots(nrows=2, ncols=5, figsize=(20, 10))    # 3. Randomly sample 10 paths from the list   samples = random.sample(path_list, 10)    # 4. Iterate through the flattened axes and corresponding sample paths   for i, ax in enumerate(axes.flat):      # 5. Get the target sample path (e.g. \"Images/n02087394-Rhodesian_ridgeback/n02087394_1161.jpg\")     sample_path = samples[i]      # 6. Extract the parent directory name to use as the title (if necessary)     # (e.g. n02087394-Rhodesian_ridgeback/n02087394_1161.jpg -&gt; n02087394-Rhodesian_ridgeback -&gt; rhodesian_ridgeback)     if extract_title:       sample_title = folder_to_class_name_dict[sample_path.parent.stem]     else:       sample_title = sample_path.parent.stem      # 7. Read the image file and plot it on the corresponding axis     ax.imshow(plt.imread(sample_path))      # 8. Set the title of the axis and turn of the axis (for pretty plots)     ax.set_title(sample_title)     ax.axis(\"off\")    # 9. Display the plot   plt.show()  plot_10_random_images_from_path_list(path_list=[Path(\"Images\") / Path(file) for file in train_file_list]) <p>Those are some nice looking dogs!</p> <p>What I like to do here is rerun the random visualizations until I've seen 100+ samples so I've got an idea of the data we're working with.</p> <p>Question: Here's something to think about, how would you code a system of rules to differentiate between all the different breeds of dogs? Perhaps you write an algorithm to look at the shapes or the colours? For example, if the dog had black fur, it's unlikely to be a golden retriever. You might be thinking \"that would take quite a long time...\" And you'd be right. Then how would we do it? With machine learning of course!</p> In\u00a0[27]: Copied! <pre># Create a dictionary of image counts\nfrom pathlib import Path\nfrom typing import List, Dict\n\n# 1. Take in a target directory\ndef count_images_in_subdirs(target_directory: str) -&gt; List[Dict[str, int]]:\n    \"\"\"\n    Counts the number of JPEG images in each subdirectory of the given directory.\n\n    Each subdirectory is assumed to represent a class, and the function counts\n    the number of '.jpg' files within each one. The result is a list of\n    dictionaries with the class name and corresponding image count.\n\n    Args:\n        target_directory (str): The path to the directory containing subdirectories.\n\n    Returns:\n        List[Dict[str, int]]: A list of dictionaries with 'class_name' and 'image_count' for each subdirectory.\n\n    Examples:\n        &gt;&gt;&gt; count_images_in_subdirs('/path/to/directory')\n        [{'class_name': 'beagle', 'image_count': 50}, {'class_name': 'poodle', 'image_count': 60}]\n    \"\"\"\n    # 2. Create a list of all the subdirectoires in the target directory (these contain our images)\n    images_dir = Path(target_directory)\n    image_class_dirs = [directory for directory in images_dir.iterdir() if directory.is_dir()]\n\n    # 3. Create an empty list to append image counts to\n    image_class_counts = []\n\n    # 4. Iterate through all of the subdirectories\n    for image_class_dir in image_class_dirs:\n\n        # 5. Get the class name from image directory (e.g. \"Images/n02116738-African_hunting_dog\" -&gt; \"n02116738-African_hunting_dog\")\n        class_name = image_class_dir.stem\n\n        # 6. Count the number of images in the target subdirectory\n        image_count = len(list(image_class_dir.rglob(\"*.jpg\")))  # get length all files with .jpg file extension\n\n        # 7. Append a dictionary of class name and image count to count list\n        image_class_counts.append({\"class_name\": class_name,\n                                   \"image_count\": image_count})\n\n    # 8. Return the list\n    return image_class_counts\n</pre> # Create a dictionary of image counts from pathlib import Path from typing import List, Dict  # 1. Take in a target directory def count_images_in_subdirs(target_directory: str) -&gt; List[Dict[str, int]]:     \"\"\"     Counts the number of JPEG images in each subdirectory of the given directory.      Each subdirectory is assumed to represent a class, and the function counts     the number of '.jpg' files within each one. The result is a list of     dictionaries with the class name and corresponding image count.      Args:         target_directory (str): The path to the directory containing subdirectories.      Returns:         List[Dict[str, int]]: A list of dictionaries with 'class_name' and 'image_count' for each subdirectory.      Examples:         &gt;&gt;&gt; count_images_in_subdirs('/path/to/directory')         [{'class_name': 'beagle', 'image_count': 50}, {'class_name': 'poodle', 'image_count': 60}]     \"\"\"     # 2. Create a list of all the subdirectoires in the target directory (these contain our images)     images_dir = Path(target_directory)     image_class_dirs = [directory for directory in images_dir.iterdir() if directory.is_dir()]      # 3. Create an empty list to append image counts to     image_class_counts = []      # 4. Iterate through all of the subdirectories     for image_class_dir in image_class_dirs:          # 5. Get the class name from image directory (e.g. \"Images/n02116738-African_hunting_dog\" -&gt; \"n02116738-African_hunting_dog\")         class_name = image_class_dir.stem          # 6. Count the number of images in the target subdirectory         image_count = len(list(image_class_dir.rglob(\"*.jpg\")))  # get length all files with .jpg file extension          # 7. Append a dictionary of class name and image count to count list         image_class_counts.append({\"class_name\": class_name,                                    \"image_count\": image_count})      # 8. Return the list     return image_class_counts <p>Ho ho, what a function!</p> <p>Let's run it on our target directory <code>Images</code> and view the first few indexes.</p> In\u00a0[28]: Copied! <pre>image_class_counts = count_images_in_subdirs(\"Images\")\nimage_class_counts[:3]\n</pre> image_class_counts = count_images_in_subdirs(\"Images\") image_class_counts[:3] Out[28]: <pre>[{'class_name': 'n02111129-Leonberg', 'image_count': 210},\n {'class_name': 'n02102973-Irish_water_spaniel', 'image_count': 150},\n {'class_name': 'n02110806-basenji', 'image_count': 209}]</pre> <p>Nice!</p> <p>Since our <code>image_class_counts</code> variable is the form of a list of dictionaries, we can turn it into a pandas <code>DataFrame</code>.</p> <p>Let's sort the <code>DataFrame</code> by <code>\"image_count\"</code> so the classes with the most images appear at the top, we can do so with <code>DataFrame.sort_values()</code>.</p> In\u00a0[29]: Copied! <pre># Create a DataFrame\nimport pandas as pd\nimage_counts_df = pd.DataFrame(image_class_counts).sort_values(by=\"image_count\", ascending=False)\nimage_counts_df.head()\n</pre> # Create a DataFrame import pandas as pd image_counts_df = pd.DataFrame(image_class_counts).sort_values(by=\"image_count\", ascending=False) image_counts_df.head() Out[29]: class_name image_count 116 n02085936-Maltese_dog 252 53 n02088094-Afghan_hound 239 111 n02092002-Scottish_deerhound 232 103 n02112018-Pomeranian 219 54 n02107683-Bernese_mountain_dog 218 <p>And let's cleanup the <code>\"class_name\"</code> column to be more readable by mapping the the values to our <code>folder_to_class_name_dict</code>.</p> In\u00a0[30]: Copied! <pre># Make class name column easier to read\nimage_counts_df[\"class_name\"] = image_counts_df[\"class_name\"].map(folder_to_class_name_dict)\nimage_counts_df.head()\n</pre> # Make class name column easier to read image_counts_df[\"class_name\"] = image_counts_df[\"class_name\"].map(folder_to_class_name_dict) image_counts_df.head() Out[30]: class_name image_count 116 maltese_dog 252 53 afghan_hound 239 111 scottish_deerhound 232 103 pomeranian 219 54 bernese_mountain_dog 218 <p>Now we've got a <code>DataFrame</code> of image counts per class, we can make them more visual by turning them into a plot.</p> <p>We covered plotting data directly from pandas <code>DataFrame</code>'s in Section 3 of the Introduction to Matplotlib notebook: Plotting data directly with pandas.</p> <p>To do so, we can use <code>image_counts_df.plot(kind=\"bar\", ...)</code> along with some other customization.</p> In\u00a0[31]: Copied! <pre># Turn the image counts DataFrame into a graph\nimport matplotlib.pyplot as plt\nplt.figure(figsize=(14, 7))\nimage_counts_df.plot(kind=\"bar\",\n                     x=\"class_name\",\n                     y=\"image_count\",\n                     legend=False,\n                     ax=plt.gca()) # plt.gca() = \"get current axis\", get the plt we setup above and put the data there\n\n# Add customization\nplt.ylabel(\"Image Count\")\nplt.title(\"Total Image Counts by Class\")\nplt.xticks(rotation=90, # Rotate the x labels for better visibility\n           fontsize=8) # Make the font size smaller for easier reading\nplt.tight_layout() # Ensure things fit nicely\nplt.show()\n</pre> # Turn the image counts DataFrame into a graph import matplotlib.pyplot as plt plt.figure(figsize=(14, 7)) image_counts_df.plot(kind=\"bar\",                      x=\"class_name\",                      y=\"image_count\",                      legend=False,                      ax=plt.gca()) # plt.gca() = \"get current axis\", get the plt we setup above and put the data there  # Add customization plt.ylabel(\"Image Count\") plt.title(\"Total Image Counts by Class\") plt.xticks(rotation=90, # Rotate the x labels for better visibility            fontsize=8) # Make the font size smaller for easier reading plt.tight_layout() # Ensure things fit nicely plt.show() <p>Beautiful! It looks like our classes are quite balanced. Each breed of dog has ~150 or more images.</p> <p>We can find out some other quick stats about our data with <code>DataFrame.describe()</code>.</p> In\u00a0[32]: Copied! <pre># Get various statistics about our data distribution\nimage_counts_df.describe()\n</pre> # Get various statistics about our data distribution image_counts_df.describe() Out[32]: image_count count 120.000000 mean 171.500000 std 23.220898 min 148.000000 25% 152.750000 50% 159.500000 75% 186.250000 max 252.000000 <p>And the table shows a similar story to the plot. We can see the minimum number of images per class is 148, where as the maximum number of images is 252.</p> <p>If one class had 10x less images than another class, we may look into collecting more data to improve the balance.</p> <p>The main takeaway(s):</p> <ul> <li>When working on a classification problem, ideally, all classes have a similar number of samples (however, in some problems this may be unattainable, such as fraud detection, where you may have 1000x more \"not fraud\" samples to \"fraud\" samples.</li> <li>If you wanted to add a new class of dog breed to the existing 120, ideally, you'd have at least ~150 images for it (though as we'll see with transfer learning, the number of required images could be less as long as they're high quality).</li> </ul> In\u00a0[33]: Copied! <pre>from pathlib import Path\n\n# Define the target directory for image splits to go\nimages_split_dir = Path(\"images_split\")\n\n# Define the training and test directories\ntrain_dir = images_split_dir / \"train\"\ntest_dir = images_split_dir / \"test\"\n\n# Using Path.mkdir with exist_ok=True ensures the directory is created only if it doesn't exist\ntrain_dir.mkdir(parents=True, exist_ok=True)\ntest_dir.mkdir(parents=True, exist_ok=True)\nprint(f\"Directory {train_dir} is exists.\")\nprint(f\"Directory {test_dir} is exists.\")\n\n# Make a folder for each dog name\nfor dog_name in dog_names:\n  # Make training dir folder\n  train_class_dir = train_dir / dog_name\n  train_class_dir.mkdir(parents=True, exist_ok=True)\n  # print(f\"Making directory: {train_class_dir}\")\n\n  # Make testing dir folder\n  test_class_dir = test_dir / dog_name\n  test_class_dir.mkdir(parents=True, exist_ok=True)\n  # print(f\"Making directory: {test_class_dir}\")\n\n# Make sure there is 120 subfolders in each\nassert count_subfolders(train_dir) == len(dog_names)\nassert count_subfolders(test_dir) == len(dog_names)\n</pre> from pathlib import Path  # Define the target directory for image splits to go images_split_dir = Path(\"images_split\")  # Define the training and test directories train_dir = images_split_dir / \"train\" test_dir = images_split_dir / \"test\"  # Using Path.mkdir with exist_ok=True ensures the directory is created only if it doesn't exist train_dir.mkdir(parents=True, exist_ok=True) test_dir.mkdir(parents=True, exist_ok=True) print(f\"Directory {train_dir} is exists.\") print(f\"Directory {test_dir} is exists.\")  # Make a folder for each dog name for dog_name in dog_names:   # Make training dir folder   train_class_dir = train_dir / dog_name   train_class_dir.mkdir(parents=True, exist_ok=True)   # print(f\"Making directory: {train_class_dir}\")    # Make testing dir folder   test_class_dir = test_dir / dog_name   test_class_dir.mkdir(parents=True, exist_ok=True)   # print(f\"Making directory: {test_class_dir}\")  # Make sure there is 120 subfolders in each assert count_subfolders(train_dir) == len(dog_names) assert count_subfolders(test_dir) == len(dog_names) <pre>Directory images_split/train is exists.\nDirectory images_split/test is exists.\n</pre> <p>Excellent!</p> <p>We can check out the data split directories/folders we created by inspecting them in the files panel in Google Colab.</p> <p>Alternatively, we can check the names of each by list the subdirectories inside them.</p> In\u00a0[34]: Copied! <pre># See the first 10 directories in the training split dir\nsorted([str(dir_name) for dir_name in train_dir.iterdir() if dir_name.is_dir()])[:10]\n</pre> # See the first 10 directories in the training split dir sorted([str(dir_name) for dir_name in train_dir.iterdir() if dir_name.is_dir()])[:10] Out[34]: <pre>['images_split/train/affenpinscher',\n 'images_split/train/afghan_hound',\n 'images_split/train/african_hunting_dog',\n 'images_split/train/airedale',\n 'images_split/train/american_staffordshire_terrier',\n 'images_split/train/appenzeller',\n 'images_split/train/australian_terrier',\n 'images_split/train/basenji',\n 'images_split/train/basset',\n 'images_split/train/beagle']</pre> <p>You might've noticed that all of our dog breed directories are empty.</p> <p>Let's change that by getting some images in there.</p> <p>To do so, we'll create a function called <code>copy_files_to_target_dir()</code> which will copy images from the <code>Images</code> directory into their respective directories inside <code>images/train</code> and <code>images/test</code>.</p> <p>More specifically, it will:</p> <ol> <li>Take in a list of source files to copy (e.g. <code>train_file_list</code>) and a target directory to copy files to.</li> <li>Iterate through the list of sources files to copy (we'll use <code>tqdm</code> which comes installed with Google Colab to create a progress bar of how many files have been copied).</li> <li>Convert the source file path to a <code>Path</code> object.</li> <li>Split the source file path and create a <code>Path</code> object for the destination folder (e.g. \"n02112018-Pomeranian\" -&gt; \"pomeranian\").</li> <li>Get the target file name (e.g. \"n02112018-Pomeranian/n02112018_6208.jpg\" -&gt; \"n02112018_6208.jpg\").</li> <li>Create a destination path for the source file to be copied to (e.g. <code>images_split/train/pomeranian/n02112018_6208.jpg</code>).</li> <li>Ensure the destination directory exists, similar to the step we took in the previous section (you can't copy files to a directory that doesn't exist).</li> <li>Print out the progress of copying (if necessary).</li> <li>Copy the source file to the destination using Python's <code>shutil.copy2(src, dst)</code>.</li> </ol> In\u00a0[35]: Copied! <pre>from pathlib import Path\nfrom shutil import copy2\nfrom tqdm.auto import tqdm\n\n# 1. Take in a list of source files to copy and a target directory\ndef copy_files_to_target_dir(file_list: list[str],\n                             target_dir: str,\n                             images_dir: str = \"Images\",\n                             verbose: bool = False) -&gt; None:\n    \"\"\"\n    Copies a list of files from the images directory to a target directory.\n\n    Parameters:\n    file_list (list[str]): A list of file paths to copy.\n    target_dir (str): The destination directory path where files will be copied.\n    images_dir (str, optional): The directory path where the images are currently stored. Defaults to 'Images'.\n    verbose (bool, optional): If set to True, the function will print out the file paths as they are being copied. Defaults to False.\n\n    Returns:\n    None\n    \"\"\"\n    # 2. Iterate through source files\n    for file in tqdm(file_list):\n\n      # 3. Convert file path to a Path object\n      source_file_path = Path(images_dir) / Path(file)\n\n      # 4. Split the file path and create a Path object for the destination folder\n      # e.g. \"n02112018-Pomeranian\" -&gt; \"pomeranian\"\n      file_class_name = folder_to_class_name_dict[Path(file).parts[0]]\n\n      # 5. Get the name of the target image\n      file_image_name = Path(file).name\n\n      # 6. Create the destination path\n      destination_file_path = Path(target_dir) / file_class_name / file_image_name\n\n      # 7. Ensure the destination directory exists (this is a safety check, can't copy an image to a file that doesn't exist)\n      destination_file_path.parent.mkdir(parents=True, exist_ok=True)\n\n      # 8. Print out copy message if necessary\n      if verbose:\n        print(f\"[INFO] Copying: {source_file_path} to {destination_file_path}\")\n\n      # 9. Copy the original path to the destination path\n      copy2(src=source_file_path, dst=destination_file_path)\n</pre> from pathlib import Path from shutil import copy2 from tqdm.auto import tqdm  # 1. Take in a list of source files to copy and a target directory def copy_files_to_target_dir(file_list: list[str],                              target_dir: str,                              images_dir: str = \"Images\",                              verbose: bool = False) -&gt; None:     \"\"\"     Copies a list of files from the images directory to a target directory.      Parameters:     file_list (list[str]): A list of file paths to copy.     target_dir (str): The destination directory path where files will be copied.     images_dir (str, optional): The directory path where the images are currently stored. Defaults to 'Images'.     verbose (bool, optional): If set to True, the function will print out the file paths as they are being copied. Defaults to False.      Returns:     None     \"\"\"     # 2. Iterate through source files     for file in tqdm(file_list):        # 3. Convert file path to a Path object       source_file_path = Path(images_dir) / Path(file)        # 4. Split the file path and create a Path object for the destination folder       # e.g. \"n02112018-Pomeranian\" -&gt; \"pomeranian\"       file_class_name = folder_to_class_name_dict[Path(file).parts[0]]        # 5. Get the name of the target image       file_image_name = Path(file).name        # 6. Create the destination path       destination_file_path = Path(target_dir) / file_class_name / file_image_name        # 7. Ensure the destination directory exists (this is a safety check, can't copy an image to a file that doesn't exist)       destination_file_path.parent.mkdir(parents=True, exist_ok=True)        # 8. Print out copy message if necessary       if verbose:         print(f\"[INFO] Copying: {source_file_path} to {destination_file_path}\")        # 9. Copy the original path to the destination path       copy2(src=source_file_path, dst=destination_file_path) <p>Copying function created!</p> <p>Let's test it out by copying the files in the <code>train_file_list</code> to <code>train_dir</code>.</p> In\u00a0[36]: Copied! <pre># Copy training images from Images to images_split/train/...\ncopy_files_to_target_dir(file_list=train_file_list,\n                         target_dir=train_dir,\n                         verbose=False) # set this to True to get an output of the copy process\n                                        # (warning: this will output a large amount of text)\n</pre> # Copy training images from Images to images_split/train/... copy_files_to_target_dir(file_list=train_file_list,                          target_dir=train_dir,                          verbose=False) # set this to True to get an output of the copy process                                         # (warning: this will output a large amount of text) <pre>  0%|          | 0/12000 [00:00&lt;?, ?it/s]</pre> <p>Woohoo!</p> <p>Looks like our copying function copied 12000 training images in their respective directories inside <code>images_split/train/</code>.</p> <p>How about we do the same for <code>test_file_list</code> and <code>test_dir</code>?</p> In\u00a0[37]: Copied! <pre>copy_files_to_target_dir(file_list=test_file_list,\n                         target_dir=test_dir,\n                         verbose=False)\n</pre> copy_files_to_target_dir(file_list=test_file_list,                          target_dir=test_dir,                          verbose=False) <pre>  0%|          | 0/8580 [00:00&lt;?, ?it/s]</pre> <p>Nice! 8580 testing images copied from <code>Images</code> to <code>images_split/test/</code>.</p> <p>Let's write some code to check that the number of files in the <code>train_file_list</code> is the same as the number of images files in <code>train_dir</code> (and the same for the test files).</p> In\u00a0[38]: Copied! <pre># Get list of of all .jpg paths in train and test image directories\ntrain_image_paths = list(train_dir.rglob(\"*.jpg\"))\ntest_image_paths = list(test_dir.rglob(\"*.jpg\"))\n\n# Make sure the number of images in the training and test directories equals the number of files in their original lists\nassert len(train_image_paths) == len(train_file_list)\nassert len(test_image_paths) == len(test_file_list)\n\nprint(f\"Number of images in {train_dir}: {len(train_image_paths)}\")\nprint(f\"Number of images in {test_dir}: {len(test_image_paths)}\")\n</pre> # Get list of of all .jpg paths in train and test image directories train_image_paths = list(train_dir.rglob(\"*.jpg\")) test_image_paths = list(test_dir.rglob(\"*.jpg\"))  # Make sure the number of images in the training and test directories equals the number of files in their original lists assert len(train_image_paths) == len(train_file_list) assert len(test_image_paths) == len(test_file_list)  print(f\"Number of images in {train_dir}: {len(train_image_paths)}\") print(f\"Number of images in {test_dir}: {len(test_image_paths)}\") <pre>Number of images in images_split/train: 12000\nNumber of images in images_split/test: 8580\n</pre> <p>And adhering to the data explorers motto of visualize, visualize, visualize!, let's plot some random images from the <code>train_image_paths</code> list.</p> In\u00a0[39]: Copied! <pre># Plot 10 random images from the train_image_paths\nplot_10_random_images_from_path_list(path_list=train_image_paths,\n                                     extract_title=False) # don't need to extract the title since the image directories are already named simply\n</pre> # Plot 10 random images from the train_image_paths plot_10_random_images_from_path_list(path_list=train_image_paths,                                      extract_title=False) # don't need to extract the title since the image directories are already named simply In\u00a0[40]: Copied! <pre># Create train_10_percent directory\ntrain_10_percent_dir = images_split_dir / \"train_10_percent\"\ntrain_10_percent_dir.mkdir(parents=True, exist_ok=True)\n</pre> # Create train_10_percent directory train_10_percent_dir = images_split_dir / \"train_10_percent\" train_10_percent_dir.mkdir(parents=True, exist_ok=True) <p>Now we should have 3 split folders inside <code>images_split</code>.</p> In\u00a0[41]: Copied! <pre>os.listdir(images_split_dir)\n</pre> os.listdir(images_split_dir) Out[41]: <pre>['test', 'train_10_percent', 'train']</pre> <p>Beautiful!</p> <p>Now let's create a list of random training sample filepaths using Python's <code>random.sample()</code>, we'll want the total length of the list to equal 10% of the original training split.</p> <p>To make things reproducible, we'll use a random seed (this is not 100% necessary, it just makes it so we get the same 10% of training image paths each time).</p> In\u00a0[42]: Copied! <pre>import random\n\n# Set a random seed\nrandom.seed(42)\n\n# Get a 10% sample of the training image paths\ntrain_image_paths_random_10_percent = random.sample(population=train_image_paths,\n                                                    k=int(0.1*len(train_image_paths)))\n\n# Check how many image paths we got\nprint(f\"Original number of training image paths: {len(train_image_paths)}\")\nprint(f\"Number of 10% training image paths: {len(train_image_paths_random_10_percent)}\")\nprint(\"First 5 random 10% training image paths:\")\ntrain_image_paths_random_10_percent[:5]\n</pre> import random  # Set a random seed random.seed(42)  # Get a 10% sample of the training image paths train_image_paths_random_10_percent = random.sample(population=train_image_paths,                                                     k=int(0.1*len(train_image_paths)))  # Check how many image paths we got print(f\"Original number of training image paths: {len(train_image_paths)}\") print(f\"Number of 10% training image paths: {len(train_image_paths_random_10_percent)}\") print(\"First 5 random 10% training image paths:\") train_image_paths_random_10_percent[:5] <pre>Original number of training image paths: 12000\nNumber of 10% training image paths: 1200\nFirst 5 random 10% training image paths:\n</pre> Out[42]: <pre>[PosixPath('images_split/train/miniature_pinscher/n02107312_2706.jpg'),\n PosixPath('images_split/train/irish_wolfhound/n02090721_272.jpg'),\n PosixPath('images_split/train/greater_swiss_mountain_dog/n02107574_3274.jpg'),\n PosixPath('images_split/train/italian_greyhound/n02091032_3763.jpg'),\n PosixPath('images_split/train/bloodhound/n02088466_7962.jpg')]</pre> <p>Random 10% training image paths acquired!</p> <p>Let's copy them to the <code>images_split/train_10_percent</code> directory using similar code to our <code>copy_files_to_target_dir()</code> function.</p> In\u00a0[43]: Copied! <pre># Copy training 10% split images from images_split/train/ to images_split/train_10_percent/...\nfor source_file_path in tqdm(train_image_paths_random_10_percent):\n\n  # Create the destination file path\n  destination_file_and_image_name = Path(*source_file_path.parts[-2:]) # \"images_split/train/yorkshire_terrier/n02094433_2223.jpg\" -&gt; \"yorkshire_terrier/n02094433_2223.jpg\"\n  destination_file_path = train_10_percent_dir / destination_file_and_image_name # \"yorkshire_terrier/n02094433_2223.jpg\" -&gt; \"images_split/train_10_percent/yorkshire_terrier/n02094433_2223.jpg\"\n\n  # If the target directory doesn't exist, make it\n  target_class_dir = destination_file_path.parent\n  if not target_class_dir.is_dir():\n    # print(f\"Making directory: {target_class_dir}\")\n    target_class_dir.mkdir(parents=True,\n                           exist_ok=True)\n\n  # print(f\"Copying: {source_file_path} to {destination_file_path}\")\n  copy2(src=source_file_path,\n        dst=destination_file_path)\n</pre> # Copy training 10% split images from images_split/train/ to images_split/train_10_percent/... for source_file_path in tqdm(train_image_paths_random_10_percent):    # Create the destination file path   destination_file_and_image_name = Path(*source_file_path.parts[-2:]) # \"images_split/train/yorkshire_terrier/n02094433_2223.jpg\" -&gt; \"yorkshire_terrier/n02094433_2223.jpg\"   destination_file_path = train_10_percent_dir / destination_file_and_image_name # \"yorkshire_terrier/n02094433_2223.jpg\" -&gt; \"images_split/train_10_percent/yorkshire_terrier/n02094433_2223.jpg\"    # If the target directory doesn't exist, make it   target_class_dir = destination_file_path.parent   if not target_class_dir.is_dir():     # print(f\"Making directory: {target_class_dir}\")     target_class_dir.mkdir(parents=True,                            exist_ok=True)    # print(f\"Copying: {source_file_path} to {destination_file_path}\")   copy2(src=source_file_path,         dst=destination_file_path) <pre>  0%|          | 0/1200 [00:00&lt;?, ?it/s]</pre> <p>1200 images copied!</p> <p>Let's check our training 10% set distribution and make sure we've got some images for each class.</p> <p>We can use our <code>count_images_in_subdirs()</code> function to count the images in each of the dog breed folders in the <code>train_10_percent_dir</code>.</p> In\u00a0[44]: Copied! <pre># Count images in train_10_percent_dir\ntrain_10_percent_image_class_counts = count_images_in_subdirs(train_10_percent_dir)\ntrain_10_percent_image_class_counts_df = pd.DataFrame(train_10_percent_image_class_counts).sort_values(\"image_count\", ascending=True)\ntrain_10_percent_image_class_counts_df.head()\n</pre> # Count images in train_10_percent_dir train_10_percent_image_class_counts = count_images_in_subdirs(train_10_percent_dir) train_10_percent_image_class_counts_df = pd.DataFrame(train_10_percent_image_class_counts).sort_values(\"image_count\", ascending=True) train_10_percent_image_class_counts_df.head() Out[44]: class_name image_count 33 labrador_retriever 3 23 welsh_springer_spaniel 4 61 great_dane 4 64 curly_coated_retriever 4 100 sussex_spaniel 5 <p>Okay, looks like a few classes have only a handful of images.</p> <p>Let's make sure there's 120 subfolders by checking the length of the <code>train_10_percent_image_class_counts_df</code>.</p> In\u00a0[45]: Copied! <pre># How many subfolders are there?\nprint(len(train_10_percent_image_class_counts_df))\n</pre> # How many subfolders are there? print(len(train_10_percent_image_class_counts_df)) <pre>120\n</pre> <p>Beautiful, our train 10% dataset split has a folder for each of the dog breed classes.</p> <p>Note: Ideally our random 10% training set would have the same distribution per class as the original training set, however, for this example, we've taken a global random 10% rather than a random 10% per class. This is okay for now, however for more fine-grained tasks, you may want to make sure your smaller training set is better distributed.</p> <p>For one last check, let's plot the distribution of our train 10% dataset.</p> In\u00a0[46]: Copied! <pre># Plot distribution of train 10% dataset.\nplt.figure(figsize=(14, 7))\ntrain_10_percent_image_class_counts_df.plot(kind=\"bar\",\n                     x=\"class_name\",\n                     y=\"image_count\",\n                     legend=False,\n                     ax=plt.gca()) # plt.gca() = \"get current axis\", get the plt we setup above and put the data there\n\n# Add customization\nplt.title(\"Train 10 Percent Image Counts by Class\")\nplt.ylabel(\"Image Count\")\nplt.xticks(rotation=90, # Rotate the x labels for better visibility\n           fontsize=8) # Make the font size smaller for easier reading\nplt.tight_layout() # Ensure things fit nicely\nplt.show()\n</pre> # Plot distribution of train 10% dataset. plt.figure(figsize=(14, 7)) train_10_percent_image_class_counts_df.plot(kind=\"bar\",                      x=\"class_name\",                      y=\"image_count\",                      legend=False,                      ax=plt.gca()) # plt.gca() = \"get current axis\", get the plt we setup above and put the data there  # Add customization plt.title(\"Train 10 Percent Image Counts by Class\") plt.ylabel(\"Image Count\") plt.xticks(rotation=90, # Rotate the x labels for better visibility            fontsize=8) # Make the font size smaller for easier reading plt.tight_layout() # Ensure things fit nicely plt.show() <p>Excellent! Our train 10% dataset distribution looks similar to the original training set distribution.</p> <p>However, it could be better.</p> <p>If we really wanted to, we could recreate the train 10% dataset with 10% of the images from each class rather than 10% of images globally.</p> <p>Extension: How would you create the <code>train_10_percent</code> data split with 10% of the images from each class? For example, each folder would have at least 10 images of a particular dog breed.</p> In\u00a0[47]: Copied! <pre>import tensorflow as tf\n\n# Create constants\nIMG_SIZE = (224, 224)\nBATCH_SIZE = 32\nSEED = 42\n\n# Create train 10% dataset\ntrain_10_percent_ds = tf.keras.utils.image_dataset_from_directory(\n    directory=train_10_percent_dir,\n    label_mode=\"categorical\", # turns labels into one-hot representations (e.g. [0, 0, 1, ..., 0, 0])\n    batch_size=BATCH_SIZE,\n    image_size=IMG_SIZE,\n    shuffle=True, # shuffle training datasets to prevent learning of order\n    seed=SEED\n)\n\n# Create full train dataset\ntrain_ds = tf.keras.utils.image_dataset_from_directory(\n    directory=train_dir,\n    label_mode=\"categorical\",\n    batch_size=BATCH_SIZE,\n    image_size=IMG_SIZE,\n    shuffle=True,\n    seed=SEED\n)\n\n# Create test dataset\ntest_ds = tf.keras.utils.image_dataset_from_directory(\n    directory=test_dir,\n    label_mode=\"categorical\",\n    batch_size=BATCH_SIZE,\n    image_size=IMG_SIZE,\n    shuffle=False, # don't need to shuffle the test dataset (this makes evaluations easier)\n    seed=SEED\n)\n</pre> import tensorflow as tf  # Create constants IMG_SIZE = (224, 224) BATCH_SIZE = 32 SEED = 42  # Create train 10% dataset train_10_percent_ds = tf.keras.utils.image_dataset_from_directory(     directory=train_10_percent_dir,     label_mode=\"categorical\", # turns labels into one-hot representations (e.g. [0, 0, 1, ..., 0, 0])     batch_size=BATCH_SIZE,     image_size=IMG_SIZE,     shuffle=True, # shuffle training datasets to prevent learning of order     seed=SEED )  # Create full train dataset train_ds = tf.keras.utils.image_dataset_from_directory(     directory=train_dir,     label_mode=\"categorical\",     batch_size=BATCH_SIZE,     image_size=IMG_SIZE,     shuffle=True,     seed=SEED )  # Create test dataset test_ds = tf.keras.utils.image_dataset_from_directory(     directory=test_dir,     label_mode=\"categorical\",     batch_size=BATCH_SIZE,     image_size=IMG_SIZE,     shuffle=False, # don't need to shuffle the test dataset (this makes evaluations easier)     seed=SEED ) <pre>Found 1200 files belonging to 120 classes.\nFound 12000 files belonging to 120 classes.\nFound 8580 files belonging to 120 classes.\n</pre> <p>Note: If you're working with similar styles of data (e.g. all dog photos), it's best practice to shuffle training datasets to prevent the model from learning any order in the data, no need to shuffle testing datasets (this makes for easier evaluation).</p> <p><code>tf.data.Dataset</code>s created!</p> <p>Let's check out one of them.</p> In\u00a0[48]: Copied! <pre>train_10_percent_ds\n</pre> train_10_percent_ds Out[48]: <pre>&lt;_PrefetchDataset element_spec=(TensorSpec(shape=(None, 224, 224, 3), dtype=tf.float32, name=None), TensorSpec(shape=(None, 120), dtype=tf.float32, name=None))&gt;</pre> <p>You'll notice a few things going on here.</p> <p>Essentially, we've got a collection of tuples:</p> <ol> <li>The image tensor(s) - <code>TensorSpec(shape=(None, 224, 224, 3), dtype=tf.float32, name=None)</code> where <code>(None, 224, 224, 3)</code> is the shape of the image tensor (<code>None</code> is the batch size, <code>(224, 224)</code> is the <code>IMG_SIZE</code> we set and <code>3</code> is the number of colour channels, as in, red, green, blue or RGB since our images are in colour).</li> <li>The label tensor(s) - <code>TensorSpec(shape=(None, 120), dtype=tf.float32, name=None)</code> where <code>None</code> is the batch size and <code>120</code> is the number of labels we're using.</li> </ol> <p>The batch size often appears as <code>None</code> since it's flexible and can change on the fly.</p> <p>Each batch of images is assosciated with a batch of labels.</p> <p>Instead of talking about it, let's check out what a single batch looks like.</p> <p>We can do so by turning the <code>tf.data.Dataset</code> into an iterable with Python's built-in <code>iter()</code> and then getting the \"next\" batch with <code>next()</code>.</p> In\u00a0[49]: Copied! <pre># What does a single batch look like?\nimage_batch, label_batch = next(iter(train_ds))\nimage_batch.shape, label_batch.shape\n</pre> # What does a single batch look like? image_batch, label_batch = next(iter(train_ds)) image_batch.shape, label_batch.shape Out[49]: <pre>(TensorShape([32, 224, 224, 3]), TensorShape([32, 120]))</pre> <p>Nice!</p> <p>We get back a single batch of images and labels.</p> <p>Looks like a single <code>image_batch</code> has a shape of <code>[32, 224, 224, 3]</code> (<code>[batch_size, height, width, colour_channels]</code>).</p> <p>And our labels have a shape of <code>[32, 120]</code> (<code>[batch_size, labels]</code>).</p> <p>These are numerical representations of our data images and labels!</p> <p>Note: The shape of a tensor does not necessarily reflect the values inside a tensor. The shape only reflects the dimensionality of a tensor. For example, <code>[32, 224, 224, 3]</code> is a 4-dimensional tensor. Values inside a tensor can be any number (positive, negative, 0, float, integer, etc) representing almost any kind of data.</p> <p>We can further inspect our data by looking at a single sample.</p> In\u00a0[50]: Copied! <pre># Get a single sample from a single batch\nprint(f\"Single image tensor:\\n{image_batch[0]}\\n\")\nprint(f\"Single label tensor: {label_batch[0]}\") # notice the 1 is the index of the target label (our labels are one-hot encoded)\nprint(f\"Single sample class name: {dog_names[tf.argmax(label_batch[0])]}\")\n</pre> # Get a single sample from a single batch print(f\"Single image tensor:\\n{image_batch[0]}\\n\") print(f\"Single label tensor: {label_batch[0]}\") # notice the 1 is the index of the target label (our labels are one-hot encoded) print(f\"Single sample class name: {dog_names[tf.argmax(label_batch[0])]}\") <pre>Single image tensor:\n[[[196.61607  174.61607  160.61607 ]\n  [197.84822  175.84822  161.84822 ]\n  [200.       178.       164.      ]\n  ...\n  [ 60.095097  79.75804   45.769207]\n  [ 61.83293   71.22575   63.288315]\n  [ 77.65755   83.65755   81.65755 ]]\n\n [[196.       174.       160.      ]\n  [197.83876  175.83876  161.83876 ]\n  [199.07945  177.07945  163.07945 ]\n  ...\n  [ 94.573715 110.55229   83.59694 ]\n  [125.869865 135.26268  127.33472 ]\n  [122.579605 128.5796   126.579605]]\n\n [[195.73691  173.73691  159.73691 ]\n  [196.896    174.896    160.896   ]\n  [199.       177.       163.      ]\n  ...\n  [ 26.679413  38.759026  20.500835]\n  [ 24.372307  31.440136  26.675896]\n  [ 20.214453  26.214453  24.214453]]\n\n ...\n\n [[ 61.57369   70.18976  104.72547 ]\n  [189.91965  199.61607  213.28572 ]\n  [247.26637  255.       252.70387 ]\n  ...\n  [113.40158   83.40158   57.40158 ]\n  [110.75214   78.75214   53.752136]\n  [107.37048   75.37048   50.370483]]\n\n [[ 61.27007   69.88614  104.42185 ]\n  [188.93079  198.62721  212.29686 ]\n  [246.33257  255.       251.77007 ]\n  ...\n  [110.88623   80.88623   54.88623 ]\n  [102.763245  70.763245  45.763245]\n  [ 99.457634  67.457634  42.457638]]\n\n [[ 60.25893   68.875    103.41071 ]\n  [188.58261  198.27904  211.94868 ]\n  [245.93112  254.6097   251.36862 ]\n  ...\n  [105.02222   75.02222   49.022217]\n  [109.11186   77.11186   52.111866]\n  [106.56936   74.56936   49.56936 ]]]\n\nSingle label tensor: [0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0.\n 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0.\n 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0.\n 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 1.\n 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]\nSingle sample class name: schipperke\n</pre> <p>Woah!!</p> <p>We've got a numerical representation of a dog image (in the form of red, green, blue pixel values)!</p> <p>This is exactly the kind of format our model will want.</p> <p>Can we do the reverse?</p> <p>Instead of image -&gt; numbers, can we go from numbers -&gt; image?</p> <p>You bet.</p> In\u00a0[51]: Copied! <pre>plt.imshow(image_batch[0].numpy().astype(\"uint8\")) # convert tensor to uint8 to avoid matplotlib colour range issues\nplt.title(dog_names[tf.argmax(label_batch[0])])\nplt.axis(\"off\");\n</pre> plt.imshow(image_batch[0].numpy().astype(\"uint8\")) # convert tensor to uint8 to avoid matplotlib colour range issues plt.title(dog_names[tf.argmax(label_batch[0])]) plt.axis(\"off\"); <p>How about we plot multiple images?</p> <p>We can do so by first setting up a plot with multiple subplots.</p> <p>And then we can iterate through our dataset with <code>tf.data.Dataset.take(count=1)</code> which will \"take\" <code>1</code> batch of data (in our case, one batch is 32 samples) which we can then index on for each subplot.</p> In\u00a0[52]: Copied! <pre># Create multiple subplots\nfig, axes = plt.subplots(nrows=2, ncols=5, figsize=(20, 10))\n\n# Iterate through a single batch and plot images\nfor images, labels in train_ds.take(count=1): # note: because our training data is shuffled, each \"take\" will be different\n  for i, ax in enumerate(axes.flat):\n    ax.imshow(images[i].numpy().astype(\"uint8\"))\n    ax.set_title(dog_names[tf.argmax(labels[i])])\n    ax.axis(\"off\")\n</pre> # Create multiple subplots fig, axes = plt.subplots(nrows=2, ncols=5, figsize=(20, 10))  # Iterate through a single batch and plot images for images, labels in train_ds.take(count=1): # note: because our training data is shuffled, each \"take\" will be different   for i, ax in enumerate(axes.flat):     ax.imshow(images[i].numpy().astype(\"uint8\"))     ax.set_title(dog_names[tf.argmax(labels[i])])     ax.axis(\"off\") <p>Aren't those good looking dogs!</p> In\u00a0[53]: Copied! <pre># Get the first 5 file paths of the training dataset\ntrain_ds.file_paths[:5]\n</pre> # Get the first 5 file paths of the training dataset train_ds.file_paths[:5] Out[53]: <pre>['images_split/train/boston_bull/n02096585_1753.jpg',\n 'images_split/train/kerry_blue_terrier/n02093859_855.jpg',\n 'images_split/train/border_terrier/n02093754_2281.jpg',\n 'images_split/train/rottweiler/n02106550_11823.jpg',\n 'images_split/train/airedale/n02096051_5884.jpg']</pre> <p>We can also get the class names assosciated with a dataset using <code>.class_names</code> (TensorFlow has read these from the names of our target folders in the <code>images_split</code> directory).</p> In\u00a0[54]: Copied! <pre># Get the class names TensorFlow has read from the target directory\nclass_names = train_ds.class_names\nclass_names[:5]\n</pre> # Get the class names TensorFlow has read from the target directory class_names = train_ds.class_names class_names[:5] Out[54]: <pre>['affenpinscher',\n 'afghan_hound',\n 'african_hunting_dog',\n 'airedale',\n 'american_staffordshire_terrier']</pre> <p>And we can make sure the class names are the same across our datasets by comparing them.</p> In\u00a0[55]: Copied! <pre>assert set(train_10_percent_ds.class_names) == set(train_ds.class_names) == set(test_ds.class_names)\n</pre> assert set(train_10_percent_ds.class_names) == set(train_ds.class_names) == set(test_ds.class_names) In\u00a0[56]: Copied! <pre>AUTOTUNE = tf.data.AUTOTUNE # let TensorFlow find the best values to use automatically\n\n# Shuffle and optimize performance on training datasets\n# Note: these methods can be chained together and will have the same effect as calling them individually\ntrain_10_percent_ds = train_10_percent_ds.cache().shuffle(buffer_size=10*BATCH_SIZE).prefetch(buffer_size=AUTOTUNE)\ntrain_ds = train_ds.cache().shuffle(buffer_size=100*BATCH_SIZE).prefetch(buffer_size=AUTOTUNE)\n\n# Don't need to shuffle test datasets (for easier evaluation)\ntest_ds = test_ds.cache().prefetch(buffer_size=AUTOTUNE)\n</pre> AUTOTUNE = tf.data.AUTOTUNE # let TensorFlow find the best values to use automatically  # Shuffle and optimize performance on training datasets # Note: these methods can be chained together and will have the same effect as calling them individually train_10_percent_ds = train_10_percent_ds.cache().shuffle(buffer_size=10*BATCH_SIZE).prefetch(buffer_size=AUTOTUNE) train_ds = train_ds.cache().shuffle(buffer_size=100*BATCH_SIZE).prefetch(buffer_size=AUTOTUNE)  # Don't need to shuffle test datasets (for easier evaluation) test_ds = test_ds.cache().prefetch(buffer_size=AUTOTUNE) <p>Dataset performance optimized!</p> <p>We spent some extra time here because datasets are so important to machine learning and deep learning workflows, wherever you can make them faster, you should.</p> <p>Time to create our first neural network with TensorFlow!</p> In\u00a0[57]: Copied! <pre># Create the input shape to our model\nINPUT_SHAPE = (*IMG_SIZE, 3)\n\nbase_model = tf.keras.applications.efficientnet_v2.EfficientNetV2B0(\n    include_top=True, # do want to include the top layer? (ImageNet has 1000 classes, so the top layer is formulated for this, we want to create our own top layer)\n    include_preprocessing=True, # do we want the network to preprocess our data into the right format for us? (yes)\n    weights=\"imagenet\", # do we want the network to come with pretrained weights? (yes)\n    input_shape=INPUT_SHAPE # what is the input shape of our data we're going to pass to the network? (224, 224, 3) -&gt; (height, width, colour_channels)\n)\n</pre> # Create the input shape to our model INPUT_SHAPE = (*IMG_SIZE, 3)  base_model = tf.keras.applications.efficientnet_v2.EfficientNetV2B0(     include_top=True, # do want to include the top layer? (ImageNet has 1000 classes, so the top layer is formulated for this, we want to create our own top layer)     include_preprocessing=True, # do we want the network to preprocess our data into the right format for us? (yes)     weights=\"imagenet\", # do we want the network to come with pretrained weights? (yes)     input_shape=INPUT_SHAPE # what is the input shape of our data we're going to pass to the network? (224, 224, 3) -&gt; (height, width, colour_channels) ) <pre>Downloading data from https://storage.googleapis.com/tensorflow/keras-applications/efficientnet_v2/efficientnetv2-b0.h5\n29403144/29403144 [==============================] - 0s 0us/step\n</pre> <p>Base model created!</p> <p>We can find out information about our base model by calling <code>base_model.summary()</code>.</p> In\u00a0[58]: Copied! <pre># Note: Uncomment to see full output\n# base_model.summary()\n</pre> # Note: Uncomment to see full output # base_model.summary() <p>Truncated output of <code>base_model.summary()</code>:</p> <p></p> <p>Woah! Look at all those layers... this is what the \"deep\" in deep learning means! A deep number of layers.</p> <p>How about we count the number of layers?</p> In\u00a0[59]: Copied! <pre># Count the number of layers\nprint(f\"Number of layers in base_model: {len(base_model.layers)}\")\n</pre> # Count the number of layers print(f\"Number of layers in base_model: {len(base_model.layers)}\") <pre>Number of layers in base_model: 273\n</pre> <p>273 layers!</p> <p>Wow, there's a lot going on.</p> <p>Rather than step through each layer and explain what's happening in each layer, I'll leave that for the curious mind to research on their own.</p> <p>Just know that when starting out deep learning you don't need to know what's happening every layer in a model to be able to use a model.</p> <p>For now, let's pay attention to a few things:</p> <ul> <li>The input layer (the first layer) input shape, this will tell us the shape of the data the model expects as input.</li> <li>The output layer (the last layer) output shape, this will tell us the shape of the data the model will output.</li> <li>The number of parameters of the model, these are \"learnable\" numbers (also called weights) that a model will use to derive patterns out of and represent the data. Generally, the more parameters a model has, the more learning capacity it has.</li> <li>The number of layers a model has. Generally, the more layers a model has, the more learning capacity it has (each layer will learn progressively deeper patterns from the data). However, this caps out at a certain range.</li> </ul> <p>Let's step through each of these.</p> In\u00a0[60]: Copied! <pre># Check the input shape of our model\nbase_model.input_shape\n</pre> # Check the input shape of our model base_model.input_shape Out[60]: <pre>(None, 224, 224, 3)</pre> <p>Nice! Looks like our model's input shape is where we want it (remember <code>None</code> in this case is equivalent to a wild card dimension, meaning it could be any value, but we've set ours to <code>32</code>).</p> <p>This is because the model we chose, <code>tf.keras.applications.efficientnet_v2.EfficientNetV2B0</code>, has been trained on images the same size as our images.</p> <p>If our model had a different input shape, we'd have to make sure we processed our images to be the same shape.</p> <p>Now let's check the output shape.</p> In\u00a0[61]: Copied! <pre># Check the model's output shape\nbase_model.output_shape\n</pre> # Check the model's output shape base_model.output_shape Out[61]: <pre>(None, 1000)</pre> <p>Hmm, is this what we're after?</p> <p>Since we have 120 dog classes, we'd like an output shape of <code>(None, 120)</code>.</p> <p>Why is it by default <code>(None, 1000)</code>?</p> <p>This is because the model has been trained already on ImageNet, a dataset of 1,000,000+ images with 1000 classes (hence the <code>1000</code> in the output shape).</p> <p>How can we change this?</p> <p>Let's recreate a <code>base_model</code> instance, except this time we'll change the <code>classes</code> parameter to 120.</p> In\u00a0[62]: Copied! <pre># Create a base model with 120 output classes\nbase_model = tf.keras.applications.efficientnet_v2.EfficientNetV2B0(\n    include_top=True,\n    include_preprocessing=True,\n    weights=\"imagenet\",\n    input_shape=INPUT_SHAPE,\n    classes=len(dog_names)\n)\n\nbase_model.output_shape\n</pre> # Create a base model with 120 output classes base_model = tf.keras.applications.efficientnet_v2.EfficientNetV2B0(     include_top=True,     include_preprocessing=True,     weights=\"imagenet\",     input_shape=INPUT_SHAPE,     classes=len(dog_names) )  base_model.output_shape <pre>\n---------------------------------------------------------------------------\nValueError                                Traceback (most recent call last)\n&lt;ipython-input-62-5e9b29e6f858&gt; in &lt;cell line: 2&gt;()\n      1 # Create a base model with 120 output classes\n----&gt; 2 base_model = tf.keras.applications.efficientnet_v2.EfficientNetV2B0(\n      3     include_top=True,\n      4     include_preprocessing=True,\n      5     weights=\"imagenet\",\n\n/usr/local/lib/python3.10/dist-packages/keras/src/applications/efficientnet_v2.py in EfficientNetV2B0(include_top, weights, input_tensor, input_shape, pooling, classes, classifier_activation, include_preprocessing)\n   1128     include_preprocessing=True,\n   1129 ):\n-&gt; 1130     return EfficientNetV2(\n   1131         width_coefficient=1.0,\n   1132         depth_coefficient=1.0,\n\n/usr/local/lib/python3.10/dist-packages/keras/src/applications/efficientnet_v2.py in EfficientNetV2(width_coefficient, depth_coefficient, default_size, dropout_rate, drop_connect_rate, depth_divisor, min_depth, bn_momentum, activation, blocks_args, model_name, include_top, weights, input_tensor, input_shape, pooling, classes, classifier_activation, include_preprocessing)\n    932 \n    933     if weights == \"imagenet\" and include_top and classes != 1000:\n--&gt; 934         raise ValueError(\n    935             \"If using `weights` as `'imagenet'` with `include_top`\"\n    936             \" as true, `classes` should be 1000\"\n\nValueError: If using `weights` as `'imagenet'` with `include_top` as true, `classes` should be 1000Received: classes=120</pre> <p>Oh dam!</p> <p>We get an error:</p> <p><code>ValueError: If using weights as 'imagenet' with include_top as true, classes should be 1000 Received: classes=120</code></p> <p>What this is saying is that if we want to using the pretrained <code>'imagenet'</code> weights (which we do to leverage the visual patterns/features a model has already learned on ImageNet, we need to change the parameters to the <code>base_model</code>.</p> <p>What we're going to do is create our own top layers.</p> <p>We can do this by setting <code>include_top=False</code>.</p> <p>What this means is we'll use most of the model's existing layers to extract features and patterns out of our images and then customize the final few layers to our own problem.</p> <p>This kind of transfer learning is often called feature extraction.</p> <p>A setup where you use an existing models pretrained weights to extract features (or patterns) from your own custom data.</p> <p>You can then used those extracted features and further tailor them to your own use case.</p> <p>Let's create an instance of <code>base_model</code> without a top layer.</p> In\u00a0[63]: Copied! <pre># Create a base model with no top\nbase_model = tf.keras.applications.efficientnet_v2.EfficientNetV2B0(\n    include_top=False, # don't include the top layer (we want to make our own top layer)\n    include_preprocessing=True,\n    weights=\"imagenet\",\n    input_shape=INPUT_SHAPE,\n)\n\n# Check the output shape\nbase_model.output_shape\n</pre> # Create a base model with no top base_model = tf.keras.applications.efficientnet_v2.EfficientNetV2B0(     include_top=False, # don't include the top layer (we want to make our own top layer)     include_preprocessing=True,     weights=\"imagenet\",     input_shape=INPUT_SHAPE, )  # Check the output shape base_model.output_shape <pre>Downloading data from https://storage.googleapis.com/tensorflow/keras-applications/efficientnet_v2/efficientnetv2-b0_notop.h5\n24274472/24274472 [==============================] - 0s 0us/step\n</pre> Out[63]: <pre>(None, 7, 7, 1280)</pre> <p>Hmm, what's this output shape?</p> <p>This still isn't what we want (we're after <code>(None, 120)</code> for our number of dog classes).</p> <p>How about we check the number of layers again?</p> In\u00a0[64]: Copied! <pre># Count the number of layers\nprint(f\"Number of layers in base_model: {len(base_model.layers)}\")\n</pre> # Count the number of layers print(f\"Number of layers in base_model: {len(base_model.layers)}\") <pre>Number of layers in base_model: 270\n</pre> <p>Looks like our new <code>base_model</code> has less layers than our previous one.</p> <p>This is because we used <code>include_top=False</code>.</p> <p>This means we've still got 270 base layers to extract features and patterns from our images, however, it also means we get to customize the output layers to our liking.</p> <p>We'll come back to this shortly.</p> In\u00a0[65]: Copied! <pre># Check the number of parameters in our model\nbase_model.count_params()\n</pre> # Check the number of parameters in our model base_model.count_params() Out[65]: <pre>5919312</pre> <p>Holy smokes!</p> <p>Our model has 5,919,312 parameters!</p> <p>That means each time an image goes through our model, it will be influenced in some small way by 5,919,312 numbers.</p> <p>Each one of these is a potential learning opportunity (except for parameters that are non-trainable but we'll get to that soon too).</p> <p>Now, you may be thinking, 5 million+ parameters sounds like a lot.</p> <p>And it is.</p> <p>However, many modern large scale models, such as GPT-3 (175B) and GPT-4 (200B+? the actual number of parameters was never released) deal in the billions of parameters (note: this is written in 2024, so if you're reading this in future, parameter counts may be in the trillions).</p> <p>Generally, more parameters leads to better models.</p> <p>However, there are always tradeoffs.</p> <p>More parameters means more compute power to run the models.</p> <p>In practice, if you have limited compute power (e.g. a single GPU on Google Colab), it's best to start with smaller models and gradually increase the size when necessary.</p> <p>We can get the trainable and non-trainable parameters from our model with the <code>trainable_weights</code> and <code>non_trainable_weights</code> attributes (remember, parameters are also referred to as weights).</p> <p>Note: Trainable weights are parameters of the model which are updated by backpropagation during training (they are changed to better match the data) where as non-trainable weights are parameters of the model which are not updated by backpropagation during training (they are fixed in place).</p> <p>Let's write a function to count the trainable, non-trainable and trainable parameters of a model.</p> In\u00a0[66]: Copied! <pre>import numpy as np\n\ndef count_parameters(model, print_output=True):\n  \"\"\"\n  Counts the number of trainable, non-trainable and total parameters of a given model.\n  \"\"\"\n  trainable_parameters = np.sum([np.prod(layer.shape) for layer in model.trainable_weights])\n  non_trainable_parameters = np.sum([np.prod(layer.shape) for layer in model.non_trainable_weights])\n  total_parameters = trainable_parameters + non_trainable_parameters\n  if print_output:\n    print(f\"Model {model.name} parameter counts:\")\n    print(f\"Total parameters: {total_parameters}\")\n    print(f\"Trainable parameters: {trainable_parameters}\")\n    print(f\"Non-trainable parameters: {non_trainable_parameters}\")\n  else:\n    return total_parameters, trainable_parameters, non_trainable_parameters\n\ncount_parameters(model=base_model, print_output=True)\n</pre> import numpy as np  def count_parameters(model, print_output=True):   \"\"\"   Counts the number of trainable, non-trainable and total parameters of a given model.   \"\"\"   trainable_parameters = np.sum([np.prod(layer.shape) for layer in model.trainable_weights])   non_trainable_parameters = np.sum([np.prod(layer.shape) for layer in model.non_trainable_weights])   total_parameters = trainable_parameters + non_trainable_parameters   if print_output:     print(f\"Model {model.name} parameter counts:\")     print(f\"Total parameters: {total_parameters}\")     print(f\"Trainable parameters: {trainable_parameters}\")     print(f\"Non-trainable parameters: {non_trainable_parameters}\")   else:     return total_parameters, trainable_parameters, non_trainable_parameters  count_parameters(model=base_model, print_output=True) <pre>Model efficientnetv2-b0 parameter counts:\nTotal parameters: 5919312\nTrainable parameters: 5858704\nNon-trainable parameters: 60608\n</pre> <p>Nice! It looks like our function worked.</p> <p>Most of our model's parameters are trainable.</p> <p>This means they will be tweaked as they see more images of dogs.</p> <p>However, a standard practice in transfer learning is to freeze the base layers of a model and only train the custom top layers to suit your problem.</p> <p></p> <p>Example of how we can take a pretrained model and customize it to our own use case. This kind of transfer learning workflow is often referred to as a feature extracting workflow as the base layers are frozen (not changed during training) and only the top layers are trained. Note: In this image the EfficientNetB0 architecture is being demonstrated, however we're going to be using the EfficientNetV2B0 architecture which is slightly different. I've used the older architecture image from the research paper as a newer one wasn't available.</p> <p>In other words, keep the patterns an existing model has learned on a similar problem (if they're good) to form a base representation of an input sample and then manipulate that base representation to suit our needs.</p> <p>Why do this?</p> <p>It's faster.</p> <p>The less trainable parameters, the faster your model training will be, the faster your experiments will be.</p> <p>But how will we know this works?</p> <p>We're going to run experiments to test it.</p> <p>Okay, so how do we freeze the parameters of our <code>base_model</code>?</p> <p>We can set its <code>.trainable</code> attribute to <code>False</code>.</p> In\u00a0[67]: Copied! <pre># Freeze the base model\nbase_model.trainable = False\nbase_model.trainable\n</pre> # Freeze the base model base_model.trainable = False base_model.trainable Out[67]: <pre>False</pre> <p><code>base_model</code> frozen!</p> <p>Now let's check the number of trainable and non-trainable parameters.</p> In\u00a0[68]: Copied! <pre>count_parameters(model=base_model, print_output=True)\n</pre> count_parameters(model=base_model, print_output=True) <pre>Model efficientnetv2-b0 parameter counts:\nTotal parameters: 5919312.0\nTrainable parameters: 0.0\nNon-trainable parameters: 5919312\n</pre> <p>Beautiful!</p> <p>Looks like all of the parameters in our <code>base_model</code> are now non-trainable (frozen).</p> <p>This means they won't be updated during training.</p> In\u00a0[69]: Copied! <pre># Extract features from a single image using our base model\nfeature_extraction = base_model(image_batch[0])\nfeature_extraction\n</pre> # Extract features from a single image using our base model feature_extraction = base_model(image_batch[0]) feature_extraction <pre>\n---------------------------------------------------------------------------\nValueError                                Traceback (most recent call last)\n&lt;ipython-input-69-957d897dc1dc&gt; in &lt;cell line: 2&gt;()\n      1 # Extract features from a single image using our base model\n----&gt; 2 feature_extraction = base_model(image_batch[0])\n      3 feature_extraction\n\n/usr/local/lib/python3.10/dist-packages/keras/src/utils/traceback_utils.py in error_handler(*args, **kwargs)\n     68             # To get the full stack trace, call:\n     69             # `tf.debugging.disable_traceback_filtering()`\n---&gt; 70             raise e.with_traceback(filtered_tb) from None\n     71         finally:\n     72             del filtered_tb\n\n/usr/local/lib/python3.10/dist-packages/keras/src/engine/input_spec.py in assert_input_compatibility(input_spec, inputs, layer_name)\n    296                 if spec_dim is not None and dim is not None:\n    297                     if spec_dim != dim:\n--&gt; 298                         raise ValueError(\n    299                             f'Input {input_index} of layer \"{layer_name}\" is '\n    300                             \"incompatible with the layer: \"\n\nValueError: Input 0 of layer \"efficientnetv2-b0\" is incompatible with the layer: expected shape=(None, 224, 224, 3), found shape=(224, 224, 3)</pre> <p>Oh no!</p> <p>Another error...</p> <p><code>ValueError: Input 0 of layer \"efficientnetv2-b0\" is incompatible with the layer: expected shape=(None, 224, 224, 3), found shape=(224, 224, 3)</code></p> <p>We've stumbled upon one of the most common errors in machine learning, shape errors.</p> <p>In our case, the shape of the data we're trying to put into the model doesn't match the input shape the model is expecting.</p> <p>Our input data shape is <code>(224, 224, 3)</code> (<code>(height, width, colour_channels)</code>), however, our model is expecting <code>(None, 224, 224, 3)</code> (<code>(batch_size, height, width, colour_channels)</code>).</p> <p>We can fix this error by adding a singluar <code>batch_size</code> dimension to our input and thus make it <code>(1, 224, 224, 3)</code> (a <code>batch_size</code> of <code>1</code> for a single sample).</p> <p>To do so, we can use the <code>tf.expand_dims(input=target_sample, axis=0)</code> where <code>target_sample</code> is our input tensor and <code>axis=0</code> means we want to expand the first dimension.</p> In\u00a0[70]: Copied! <pre># Current image shape\nshape_of_image_without_batch = image_batch[0].shape\n\n# Add a batch dimension to our single image\nshape_of_image_with_batch = tf.expand_dims(input=image_batch[0], axis=0).shape\n\nprint(f\"Shape of image without batch: {shape_of_image_without_batch}\")\nprint(f\"Shape of image with batch: {shape_of_image_with_batch}\")\n</pre> # Current image shape shape_of_image_without_batch = image_batch[0].shape  # Add a batch dimension to our single image shape_of_image_with_batch = tf.expand_dims(input=image_batch[0], axis=0).shape  print(f\"Shape of image without batch: {shape_of_image_without_batch}\") print(f\"Shape of image with batch: {shape_of_image_with_batch}\") <pre>Shape of image without batch: (224, 224, 3)\nShape of image with batch: (1, 224, 224, 3)\n</pre> <p>Perfect!</p> <p>Now let's pass this image with a batch dimension to our <code>base_model</code>.</p> In\u00a0[71]: Copied! <pre># Extract features from a single image using our base model\nfeature_extraction = base_model(tf.expand_dims(image_batch[0], axis=0))\nfeature_extraction\n</pre> # Extract features from a single image using our base model feature_extraction = base_model(tf.expand_dims(image_batch[0], axis=0)) feature_extraction Out[71]: <pre>&lt;tf.Tensor: shape=(1, 7, 7, 1280), dtype=float32, numpy=\narray([[[[-2.19177201e-01, -3.44185606e-02, -1.40321642e-01, ...,\n          -1.44454449e-01, -2.73809850e-01, -7.41252452e-02],\n         [-8.69670734e-02, -6.48750067e-02, -2.14546964e-01, ...,\n          -4.57209721e-02, -2.77900100e-01, -8.20885971e-02],\n         [-2.76872963e-01, -8.26781020e-02, -3.85153107e-02, ...,\n          -2.72128999e-01, -2.52802134e-01, -2.28105962e-01],\n         ...,\n         [-1.01604000e-01, -3.55145968e-02, -2.23027021e-01, ...,\n          -2.26227805e-01, -8.61771777e-02, -1.60450727e-01],\n         [-5.87608740e-02, -4.65543661e-03, -1.06193267e-01, ...,\n          -2.87548676e-02, -9.06914026e-02, -1.82624385e-01],\n         [-6.27618432e-02, -1.38620799e-03,  1.52704502e-02, ...,\n          -7.85450079e-03, -1.84584558e-01, -2.62404829e-01]],\n\n        [[-2.17334151e-01, -1.10280879e-01, -2.74605274e-01, ...,\n          -2.22405165e-01, -2.74738282e-01, -1.01998925e-01],\n         [-1.40700653e-01, -1.66820198e-01, -2.77449101e-01, ...,\n           2.40375683e-01, -2.77627349e-01, -9.07808691e-02],\n         [-2.40916476e-01, -2.00582087e-01, -2.38370374e-01, ...,\n          -8.27576742e-02, -2.78428614e-01, -1.23056054e-01],\n         ...,\n         [-2.67296195e-01, -5.43131726e-03, -6.44061863e-02, ...,\n          -3.34720500e-02, -1.55141622e-01, -3.23073938e-02],\n         [-2.66513556e-01, -2.09966358e-02, -1.50375053e-01, ...,\n          -6.29274473e-02, -2.69798309e-01, -2.74081439e-01],\n         [-8.39830115e-02, -1.58605091e-02, -2.78447241e-01, ...,\n          -1.43555822e-02, -2.77474761e-01,  1.37483165e-01]],\n\n        [[-2.15840712e-01,  4.50323820e-01, -7.51058161e-02, ...,\n          -2.43637279e-01, -2.75048614e-01, -6.00421876e-02],\n         [-2.39066556e-01, -2.25066260e-01, -4.89832312e-02, ...,\n          -2.77957618e-01, -1.14677951e-01, -2.69968715e-02],\n         [-1.60943881e-01, -2.12972730e-01, -1.08622171e-01, ...,\n          -2.78464079e-01, -1.95970193e-01, -2.92074662e-02],\n         ...,\n         [-2.67642140e-01, -7.13412274e-10, -2.47387841e-01, ...,\n          -1.27752789e-03,  1.69062471e+00, -1.07747754e-02],\n         [-2.69456387e-01, -3.02123808e-05, -2.19904676e-01, ...,\n          -1.19841937e-02,  6.54936790e-01,  4.92877871e-01],\n         [-1.83339473e-02, -9.84105989e-02, -2.77752399e-01, ...,\n          -9.53171253e-02, -2.76987553e-01, -1.81873620e-01]],\n\n        ...,\n\n        [[-6.59235120e-02, -1.64803467e-03, -1.58951283e-01, ...,\n          -1.34164095e-01, -6.30896613e-02, -7.77927637e-02],\n         [-1.83377475e-01, -4.98497509e-04, -1.57654762e-01, ...,\n          -4.48885784e-02, -1.06884383e-01, -2.78372377e-01],\n         [-2.45749369e-01, -9.95399058e-03, -1.79216102e-01, ...,\n          -1.02837617e-02, -1.84168354e-01, -1.70697242e-01],\n         ...,\n         [ 2.22050592e-01, -2.04384560e-04, -1.46467671e-01, ...,\n          -2.65387502e-02, -1.85434178e-01, -9.71652716e-02],\n         [ 1.52228832e+00, -3.39617883e-03, -3.22414264e-02, ...,\n          -1.19287046e-02, -1.46435276e-01, -8.73169452e-02],\n         [-1.89164400e-01, -5.49114570e-02, -2.05218419e-01, ...,\n          -1.32163316e-01, -1.48950770e-01, -1.18042991e-01]],\n\n        [[-2.16520607e-01, -7.84920622e-03, -1.43650264e-01, ...,\n          -1.73660204e-01, -4.83706780e-02, -3.76228467e-02],\n         [-2.78293848e-01, -6.24539470e-03, -2.28590608e-01, ...,\n          -2.06465453e-01, -1.93291768e-01, -9.23046917e-02],\n         [-2.40500003e-01, -2.73558766e-01, -1.58736348e-01, ...,\n          -4.13209312e-02, -2.64240265e-01, -3.26484852e-02],\n         ...,\n         [-2.31358394e-01, -2.72292078e-01, -6.80670887e-02, ...,\n          -2.16453914e-02, -2.71368980e-01, -3.88960652e-02],\n         [-2.45319903e-01, -2.78179497e-01, -6.18890636e-02, ...,\n          -1.86282583e-02, -2.23804727e-01, -2.72233319e-02],\n         [-2.31111392e-01, -2.37449735e-01, -5.13911694e-02, ...,\n          -4.55225781e-02, -2.74753064e-01, -3.51530202e-02]],\n\n        [[-3.96142267e-02, -1.39998682e-02, -9.56050456e-02, ...,\n          -2.33392462e-01, -1.83407709e-01, -4.99856956e-02],\n         [-2.60713607e-01, -3.96164991e-02, -1.29626304e-01, ...,\n          -2.78417081e-01, -2.78285533e-01, -7.70441368e-02],\n         [-8.02241415e-02, -2.30456606e-01, -1.13508031e-01, ...,\n          -5.45607917e-02, -2.71063268e-01, -2.75666509e-02],\n         ...,\n         [-9.41052362e-02, -2.42691532e-01, -5.48249595e-02, ...,\n          -2.13044193e-02, -2.63691694e-01, -9.28506851e-02],\n         [-9.08804908e-02, -2.40457997e-01, -7.88932368e-02, ...,\n          -3.80579121e-02, -2.71065891e-01, -4.05692160e-02],\n         [-1.26358300e-01, -2.17053503e-01, -7.44825602e-02, ...,\n          -5.66985942e-02, -2.75216103e-01, -6.91162944e-02]]]],\n      dtype=float32)&gt;</pre> <p>Woah! Look at all those numbers!</p> <p>After passing through ~270 layers, this is the numerical representation our model has created of our input image.</p> <p>You might be thinking, okay, there's a lot here, how can I possibly understand all of them?</p> <p>Well, with enough effort, you might.</p> <p>However, these numbers are more for a model/computer to understand than for a human to understand.</p> <p>Let's not stop there, let's check the shape of our <code>feature_extraction</code>.</p> In\u00a0[72]: Copied! <pre># Check shape of feature extraction\nfeature_extraction.shape\n</pre> # Check shape of feature extraction feature_extraction.shape Out[72]: <pre>TensorShape([1, 7, 7, 1280])</pre> <p>Ok, looks like our model has compressed our input image into a lower dimensional feature space.</p> <p>Note: Feature space (or latent space or embedding space) is a numerical region where pieces of data are represented by tensors of various dimensions. Feature space is hard for humans to imagine because it could be 1000s of dimensions (humans are only good at imagining 3-4 dimensions at max). But you can think of feature space as an area where numerical representations of similar items will be close to together. If feature space was a grocery store, one breed of dogs may be in one aisle (similar numbers) where as another breed of dogs may be in the next aisle. You can see an example of a large embedding space representation of 8M Stack Overflow questions on Nomic Atlas.</p> <p>Let's compare the new shape to the input shape.</p> In\u00a0[73]: Copied! <pre>num_input_features = 224*224*3\nfeature_extraction_features = 1*7*7*1280\n\n# Calculate the compression ratio\nnum_input_features / feature_extraction_features\n</pre> num_input_features = 224*224*3 feature_extraction_features = 1*7*7*1280  # Calculate the compression ratio num_input_features / feature_extraction_features Out[73]: <pre>2.4</pre> <p>Looks like our model has compressed the numerical representation of our input image by 2.4x so far.</p> <p>But you might've noticed our <code>feature_extraction</code> is still a tensor.</p> <p>How about we take it further and turn it into a vector and compress the representation even further?</p> <p>We can do so by taking our <code>feature_extraction</code> tensor and pooling together the inner dimensions.</p> <p>By pooling, I mean taking the average or the maximum values.</p> <p>Why?</p> <p>Because a neural network often outputs a large amount of learned feature values but many of them can be insignificant compared to others.</p> <p>So taking the average or the max across them helps us compress the representation further while stil preserving the most important features.</p> <p>This process is often referred to as:</p> <ul> <li>Average pooling - Take the average across given dimensions of a tensor, can perform with <code>tf.keras.layers.GlobalAveragePooling2D()</code>.</li> <li>Max pooling - Take the maximum value across given dimensions of a tensor, can perform with <code>tf.keras.layers.MaxPooling2D()</code>.</li> </ul> <p>Let's try apply average pooling to our feature extraction and see what happens.</p> In\u00a0[74]: Copied! <pre># Turn feature extraction into a feature vector\nfeature_vector = tf.keras.layers.GlobalAveragePooling2D()(feature_extraction) # pass feature_extraction to the pooling layer\nfeature_vector\n</pre> # Turn feature extraction into a feature vector feature_vector = tf.keras.layers.GlobalAveragePooling2D()(feature_extraction) # pass feature_extraction to the pooling layer feature_vector Out[74]: <pre>&lt;tf.Tensor: shape=(1, 1280), dtype=float32, numpy=\narray([[-0.11521906, -0.04476562, -0.12476546, ..., -0.09118073,\n        -0.08420841, -0.07769417]], dtype=float32)&gt;</pre> <p>Ho, ho!</p> <p>Looks like we've compressed our <code>feature_extraction</code> tensor into a feature vector (notice the new shape of <code>(1, 1280)</code>).</p> <p>Now if you're not sure what all these numbers mean, that's okay. I don't either.</p> <p>A feature vector (also called an embedding) is supposed to be a numerical representation that's meaningful to computers.</p> <p>We'll perform a few more transforms on it before it's recognizable to us.</p> <p>Let's check out its shape.</p> In\u00a0[75]: Copied! <pre># Check out the feature vector shape\nfeature_vector.shape\n</pre> # Check out the feature vector shape feature_vector.shape Out[75]: <pre>TensorShape([1, 1280])</pre> <p>We've reduced the shape of <code>feature_extraction</code> from <code>(1, 7, 7, 1280)</code> to <code>(1, 1280)</code> (we've gone from a tensor with multiple dimensions to a vector with one dimension of size 1280).</p> <p>Our neural network has performed calculations on our image and it is now represented by 1280 numbers.</p> <p>This is one of the main goals of deep learning, to reduce higher dimensional information into a lower dimensional but still representative space.</p> <p>Let's calculate how much we've reduced the dimensionality of our single input image.</p> In\u00a0[76]: Copied! <pre># Compare the reduction\nnum_input_features = 224*224*3\nfeature_extraction_features = 1*7*7*1280\nfeature_vector_features = 1*1280\n\nprint(f\"Input -&gt; feature extraction reduction factor: {num_input_features / feature_extraction_features}\")\nprint(f\"Feature extraction -&gt; feature vector reduction factor: {feature_extraction_features / feature_vector_features}\")\nprint(f\"Input -&gt; feature extraction -&gt; feature vector reduction factor: {num_input_features / feature_vector_features}\")\n</pre> # Compare the reduction num_input_features = 224*224*3 feature_extraction_features = 1*7*7*1280 feature_vector_features = 1*1280  print(f\"Input -&gt; feature extraction reduction factor: {num_input_features / feature_extraction_features}\") print(f\"Feature extraction -&gt; feature vector reduction factor: {feature_extraction_features / feature_vector_features}\") print(f\"Input -&gt; feature extraction -&gt; feature vector reduction factor: {num_input_features / feature_vector_features}\") <pre>Input -&gt; feature extraction reduction factor: 2.4\nFeature extraction -&gt; feature vector reduction factor: 49.0\nInput -&gt; feature extraction -&gt; feature vector reduction factor: 117.6\n</pre> <p>A 117.6x reduction from our original image to its feature vector representation!</p> <p>Why compress the representation like this?</p> <p>Because representing our data in a compressed format but still with meaningful numbers (to a computer) means that less computation is required to reuse the patterns.</p> <p>For example, imagine you have to relearn how to spell words every time you use them.</p> <p>Would this be efficient?</p> <p>Not at all.</p> <p>Instead, you take a while to learn them at the start and then continually reuse this knowledge over time.</p> <p>This is the same with a deep learning model.</p> <p>It learns representative patterns in data, figures out the ideal connections between inputs and outputs and then reuses them over time in the form of numerical weights.</p> In\u00a0[77]: Copied! <pre># Create a base model with no top and a pooling layer built-in\nbase_model = tf.keras.applications.efficientnet_v2.EfficientNetV2B0(\n    include_top=False,\n    weights=\"imagenet\",\n    input_shape=INPUT_SHAPE,\n    pooling=\"avg\", # can also use \"max\"\n    include_preprocessing=True,\n)\n\n# Check the summary (optional)\n# base_model.summary()\n\n# Check the output shape\nbase_model.output_shape\n</pre> # Create a base model with no top and a pooling layer built-in base_model = tf.keras.applications.efficientnet_v2.EfficientNetV2B0(     include_top=False,     weights=\"imagenet\",     input_shape=INPUT_SHAPE,     pooling=\"avg\", # can also use \"max\"     include_preprocessing=True, )  # Check the summary (optional) # base_model.summary()  # Check the output shape base_model.output_shape Out[77]: <pre>(None, 1280)</pre> <p>Boom!</p> <p>We get the same output shape from the <code>base_model</code> as we did when using it with a pooling layer thanks to using <code>pooling=\"avg\"</code>.</p> <p>Let's now freeze these base weights, so they're not trainable.</p> In\u00a0[78]: Copied! <pre># Freeze the base weights\nbase_model.trainable = False\n\n# Count the parameters\ncount_parameters(model=base_model, print_output=True)\n</pre> # Freeze the base weights base_model.trainable = False  # Count the parameters count_parameters(model=base_model, print_output=True) <pre>Model efficientnetv2-b0 parameter counts:\nTotal parameters: 5919312.0\nTrainable parameters: 0.0\nNon-trainable parameters: 5919312\n</pre> <p>And now we can pass an image through our base model and get a feature vector from it.</p> In\u00a0[79]: Copied! <pre># Get a feature vector of a single image (don't forget to add a batch dimension)\nfeature_vector_2 = base_model(tf.expand_dims(image_batch[0], axis=0))\nfeature_vector_2\n</pre> # Get a feature vector of a single image (don't forget to add a batch dimension) feature_vector_2 = base_model(tf.expand_dims(image_batch[0], axis=0)) feature_vector_2 Out[79]: <pre>&lt;tf.Tensor: shape=(1, 1280), dtype=float32, numpy=\narray([[-0.11521906, -0.04476562, -0.12476546, ..., -0.09118073,\n        -0.08420841, -0.07769417]], dtype=float32)&gt;</pre> <p>Wonderful!</p> <p>Now is this the same as our original <code>feature_vector</code>?</p> <p>We can find out by comparing <code>feature_vector</code> and <code>feature_vector_2</code> and seeing if all of the values are the same with <code>np.all()</code>.</p> In\u00a0[80]: Copied! <pre># Compare the two feature vectors\nnp.all(feature_vector == feature_vector_2)\n</pre> # Compare the two feature vectors np.all(feature_vector == feature_vector_2) Out[80]: <pre>True</pre> <p>Perfect!</p> <p>Let's put it all together and create a full model for our dog vision problem.</p> In\u00a0[81]: Copied! <pre># Create a sequential model\ntf.random.set_seed(42)\nsequential_model = tf.keras.Sequential([base_model, # input and middle layers\n                                        tf.keras.layers.Dense(units=len(dog_names), # output layer\n                                                              activation=\"softmax\")])\nsequential_model.summary()\n</pre> # Create a sequential model tf.random.set_seed(42) sequential_model = tf.keras.Sequential([base_model, # input and middle layers                                         tf.keras.layers.Dense(units=len(dog_names), # output layer                                                               activation=\"softmax\")]) sequential_model.summary() <pre>Model: \"sequential\"\n_________________________________________________________________\n Layer (type)                Output Shape              Param #   \n=================================================================\n efficientnetv2-b0 (Functio  (None, 1280)              5919312   \n nal)                                                            \n                                                                 \n dense (Dense)               (None, 120)               153720    \n                                                                 \n=================================================================\nTotal params: 6073032 (23.17 MB)\nTrainable params: 153720 (600.47 KB)\nNon-trainable params: 5919312 (22.58 MB)\n_________________________________________________________________\n</pre> <p>Wonderful!</p> <p>We've now got a model with 6,073,032 parameters, however, only 153,720 of them (the ones in the dense layer) are trainable.</p> <p>Our dense layer (also called a fully-connected layer or feed-forward layer) takes the outputs of the <code>base_model</code> and performs further calulations on them to map them to our required number of classes (120 for the number of dog breeds).</p> <p>We use <code>activation=\"softmax\"</code> (the Softmax function) to get prediction probablities, values between 0 and 1 which represent how much our model \"thinks\" a specific image relates to a certain class.</p> <p>There's another common activation function called Sigmoid. If we only had two classes, for example, \"dog\" or \"cat\", we'd lean towards using this function.</p> <p>Confusing, yes, but you'll get used to different functions with practice.</p> <p>The following table summarizes a few use cases.</p> Activation Function Use Cases Code Sigmoid - When you have two choices (like yes or no, true or false).  - In binary classification, where you're deciding between one thing or another (like if an email is spam or not spam).  - When you want the output to be a probability between 0 and 1. <code>tf.keras.activations.sigmoid</code> or <code>activation=\"sigmoid\"</code> Softmax - When you have more than two choices.  - In multi-class classification, like if you're trying to decide if a picture is of a dog, a cat, a horse, or a bird.  - When you want to compare the probabilities across different options and pick the most likely one. <code>tf.keras.activations.softmax</code> or <code>activation=\"softmax\"</code> <p>Now our model is built, let's check our input and output shapes.</p> In\u00a0[82]: Copied! <pre># Check the input shape\nsequential_model.input_shape\n</pre> # Check the input shape sequential_model.input_shape Out[82]: <pre>(None, 224, 224, 3)</pre> In\u00a0[83]: Copied! <pre># Check the output shape\nsequential_model.output_shape\n</pre> # Check the output shape sequential_model.output_shape Out[83]: <pre>(None, 120)</pre> <p>Beautiful!</p> <p>Our sequential model takes in an image tensor of size <code>[None, 224, 224, 3]</code> and outputs a vector of shape <code>[None, 120]</code> where <code>None</code> is the batch size we specify.</p> <p>Let's try our sequential model out with a single image input.</p> In\u00a0[84]: Copied! <pre># Get a single image with a batch size of 1\nsingle_image_input = tf.expand_dims(image_batch[0], axis=0)\n\n# Pass the image through our model\nsingle_image_output_sequential = sequential_model(single_image_input)\n\n# Check the output\nsingle_image_output_sequential\n</pre> # Get a single image with a batch size of 1 single_image_input = tf.expand_dims(image_batch[0], axis=0)  # Pass the image through our model single_image_output_sequential = sequential_model(single_image_input)  # Check the output single_image_output_sequential Out[84]: <pre>&lt;tf.Tensor: shape=(1, 120), dtype=float32, numpy=\narray([[0.00783153, 0.01119391, 0.00476165, 0.0072348 , 0.00766934,\n        0.00753752, 0.00522398, 0.02337082, 0.00579716, 0.00539333,\n        0.00549823, 0.01011768, 0.00610076, 0.0109506 , 0.00540159,\n        0.0079683 , 0.01227358, 0.01056393, 0.00507148, 0.00996652,\n        0.00604106, 0.00729022, 0.0155036 , 0.00745004, 0.00628229,\n        0.00796217, 0.00905823, 0.00712278, 0.01243507, 0.006427  ,\n        0.00602891, 0.01276839, 0.00652441, 0.00842482, 0.01247454,\n        0.00749902, 0.01086363, 0.007803  , 0.0058652 , 0.00474356,\n        0.00902809, 0.00715358, 0.00981051, 0.00444271, 0.01031628,\n        0.00691859, 0.00699083, 0.0065892 , 0.00966169, 0.01177148,\n        0.00908043, 0.00729699, 0.00496712, 0.00509035, 0.00584058,\n        0.01068885, 0.00817651, 0.00602052, 0.00901201, 0.01008151,\n        0.00495409, 0.01285929, 0.00480146, 0.0108622 , 0.01421483,\n        0.00814719, 0.00910061, 0.00798947, 0.00789293, 0.00636969,\n        0.00656019, 0.01309155, 0.00754355, 0.00702062, 0.00485884,\n        0.00958675, 0.01086809, 0.00682202, 0.00923016, 0.00856321,\n        0.00482627, 0.01234931, 0.01140433, 0.00771413, 0.01140642,\n        0.00382939, 0.00891482, 0.00409833, 0.00771865, 0.00652135,\n        0.00668143, 0.00935989, 0.00784146, 0.00751913, 0.00785116,\n        0.00794632, 0.0079146 , 0.00798953, 0.01011222, 0.01318719,\n        0.00721227, 0.00736159, 0.01369175, 0.01087009, 0.00510072,\n        0.00843218, 0.00451756, 0.00966478, 0.01013771, 0.00715721,\n        0.00367131, 0.00825834, 0.00832634, 0.01225684, 0.00724481,\n        0.00670675, 0.00536995, 0.01070637, 0.00937007, 0.00998812]],\n      dtype=float32)&gt;</pre> <p>Nice!</p> <p>Our model has output a tensor of prediction probabilities in shape <code>[1, 120]</code>, one value for each our dog classes.</p> <p>Thanks to the softmax function, all of these values are between 0 and 1 and they should all add up to 1 (or close to it).</p> In\u00a0[85]: Copied! <pre># Sum the output\nnp.sum(single_image_output_sequential)\n</pre> # Sum the output np.sum(single_image_output_sequential) Out[85]: <pre>1.0</pre> <p>Beautiful!</p> <p>Now how do we figure out which of the values our model thinks is most likely?</p> <p>We take the index of the highest value!</p> <p>We can find the index of the highest value using <code>tf.argmax()</code> or <code>np.argmax()</code>.</p> <p>We'll get the highest value (not the index) alongside it.</p> <p>Let's try.</p> In\u00a0[86]: Copied! <pre># Find the index with the highest value\nhighest_value_index_sequential_model_output = np.argmax(single_image_output_sequential)\nhighest_value_sequential_model_output = np.max(single_image_output_sequential)\n\nprint(f\"Highest value index: {highest_value_index_sequential_model_output} ({dog_names[highest_value_index_sequential_model_output]})\")\nprint(f\"Prediction probability: {highest_value_sequential_model_output}\")\n</pre> # Find the index with the highest value highest_value_index_sequential_model_output = np.argmax(single_image_output_sequential) highest_value_sequential_model_output = np.max(single_image_output_sequential)  print(f\"Highest value index: {highest_value_index_sequential_model_output} ({dog_names[highest_value_index_sequential_model_output]})\") print(f\"Prediction probability: {highest_value_sequential_model_output}\") <pre>Highest value index: 7 (basenji)\nPrediction probability: 0.023370817303657532\n</pre> <p>Note: these values may change every time due to the model/data being randomly initalized, don't worry too much about them being different, in machine learning randomness is a good thing.</p> <p>This prediction probability value is quite low.</p> <p>With the highest potential value being <code>1.0</code>, it means the model isn't very confident on its prediction.</p> <p>Let's check the original label value of our single image.</p> In\u00a0[87]: Copied! <pre># Check the original label value\nprint(f\"Predicted value: {highest_value_index_sequential_model_output}\")\nprint(f\"Actual value: {tf.argmax(label_batch[0]).numpy()}\")\n</pre> # Check the original label value print(f\"Predicted value: {highest_value_index_sequential_model_output}\") print(f\"Actual value: {tf.argmax(label_batch[0]).numpy()}\") <pre>Predicted value: 7\nActual value: 95\n</pre> <p>Oh no! Looks like our model predicted the wrong label (or if it got it right, it was by pure chance).</p> <p>This is to be expected.</p> <p>As although our model comes with pretrained parameters from ImageNet, the dense layer we added on the end is initialized with random parameters.</p> <p>So in essence, our model is randomly guessing what the label should be.</p> <p>How do we fix this?</p> <p>We can train the model to adjust its trainable parameters to better suit the data we're working with.</p> <p>For completeness let's check out the text-based label our model predicted versus the original label.</p> In\u00a0[88]: Copied! <pre># Index on class_names with our model's highest prediction probability\nsequential_model_predicted_label = class_names[tf.argmax(sequential_model(tf.expand_dims(image_batch[0], axis=0)), axis=1).numpy()[0]]\n\n# Get the truth label\nsingle_image_ground_truth_label = class_names[tf.argmax(label_batch[0])]\n\n# Print predicted and ground truth labels\nprint(f\"Sequential model predicted label: {sequential_model_predicted_label}\")\nprint(f\"Ground truth label: {single_image_ground_truth_label}\")\n</pre> # Index on class_names with our model's highest prediction probability sequential_model_predicted_label = class_names[tf.argmax(sequential_model(tf.expand_dims(image_batch[0], axis=0)), axis=1).numpy()[0]]  # Get the truth label single_image_ground_truth_label = class_names[tf.argmax(label_batch[0])]  # Print predicted and ground truth labels print(f\"Sequential model predicted label: {sequential_model_predicted_label}\") print(f\"Ground truth label: {single_image_ground_truth_label}\") <pre>Sequential model predicted label: basenji\nGround truth label: schipperke\n</pre> In\u00a0[89]: Copied! <pre># 1. Create input layer\ninputs = tf.keras.Input(shape=INPUT_SHAPE)\n\n# 2. Create hidden layer\nx = base_model(inputs, training=False)\n\n# 3. Create the output layer\noutputs = tf.keras.layers.Dense(units=len(class_names), # one output per class\n                                activation=\"softmax\",\n                                name=\"output_layer\")(x)\n\n# 4. Connect the inputs and outputs together\nfunctional_model = tf.keras.Model(inputs=inputs,\n                                  outputs=outputs,\n                                  name=\"functional_model\")\n\n# Get a model summary\nfunctional_model.summary()\n</pre> # 1. Create input layer inputs = tf.keras.Input(shape=INPUT_SHAPE)  # 2. Create hidden layer x = base_model(inputs, training=False)  # 3. Create the output layer outputs = tf.keras.layers.Dense(units=len(class_names), # one output per class                                 activation=\"softmax\",                                 name=\"output_layer\")(x)  # 4. Connect the inputs and outputs together functional_model = tf.keras.Model(inputs=inputs,                                   outputs=outputs,                                   name=\"functional_model\")  # Get a model summary functional_model.summary() <pre>Model: \"functional_model\"\n_________________________________________________________________\n Layer (type)                Output Shape              Param #   \n=================================================================\n input_4 (InputLayer)        [(None, 224, 224, 3)]     0         \n                                                                 \n efficientnetv2-b0 (Functio  (None, 1280)              5919312   \n nal)                                                            \n                                                                 \n output_layer (Dense)        (None, 120)               153720    \n                                                                 \n=================================================================\nTotal params: 6073032 (23.17 MB)\nTrainable params: 153720 (600.47 KB)\nNon-trainable params: 5919312 (22.58 MB)\n_________________________________________________________________\n</pre> <p>Functional model created!</p> <p>Let's try it out.</p> <p>It works in the same fashion as our <code>sequential_model</code>.</p> In\u00a0[90]: Copied! <pre># Pass a single image through our functional_model\nsingle_image_output_functional = functional_model(single_image_input)\n\n# Find the index with the highest value\nhighest_value_index_functional_model_output = np.argmax(single_image_output_functional)\nhighest_value_functional_model_output = np.max(single_image_output_functional)\n\nhighest_value_index_functional_model_output, highest_value_functional_model_output\n</pre> # Pass a single image through our functional_model single_image_output_functional = functional_model(single_image_input)  # Find the index with the highest value highest_value_index_functional_model_output = np.argmax(single_image_output_functional) highest_value_functional_model_output = np.max(single_image_output_functional)  highest_value_index_functional_model_output, highest_value_functional_model_output Out[90]: <pre>(69, 0.017855722)</pre> <p>Nice!</p> <p>Looks like we got a slightly different value to our <code>sequential_model</code> (or they may be the same if randomness wasn't so random).</p> <p>Why is this?</p> <p>Because our <code>functional_model</code> was initialized with a random <code>tf.keras.layers.Dense</code> layer as well.</p> <p>So the outputs of our <code>functional_model</code> are essentially random as well (neural networks start with random numbers and adjust them to better represent patterns in data).</p> <p>Not to fear, we'll fix this soon when we train our model.</p> <p>Right now we've created our model with a few scattered lines of code.</p> <p>How about we functionize the model creation so we can repeat it later on?</p> In\u00a0[91]: Copied! <pre>def create_model(include_top: bool = False,\n                 num_classes: int = 1000,\n                 input_shape: tuple[int, int, int] = (224, 224, 3),\n                 include_preprocessing: bool = True,\n                 trainable: bool = False,\n                 dropout: float = 0.2,\n                 model_name: str = \"model\") -&gt; tf.keras.Model:\n  \"\"\"\n  Create an EfficientNetV2 B0 feature extractor model with a custom classifier layer.\n\n  Args:\n      include_top (bool, optional): Whether to include the top (classifier) layers of the model.\n      num_classes (int, optional): Number of output classes for the classifier layer.\n      input_shape (tuple[int, int, int], optional): Input shape for the model's images (height, width, channels).\n      include_preprocessing (bool, optional): Whether to include preprocessing layers for image normalization.\n      trainable (bool, optional): Whether to make the base model trainable.\n      dropout (float, optional): Dropout rate for the global average pooling layer.\n      model_name (str, optional): Name for the created model.\n\n  Returns:\n      tf.keras.Model: A TensorFlow Keras model with the specified configuration.\n  \"\"\"\n  # Create base model\n  base_model = tf.keras.applications.efficientnet_v2.EfficientNetV2B0(\n    include_top=include_top,\n    weights=\"imagenet\",\n    input_shape=input_shape,\n    include_preprocessing=include_preprocessing,\n    pooling=\"avg\" # Can use this instead of adding tf.keras.layers.GlobalPooling2D() to the model\n    # pooling=\"max\" # Can use this instead of adding tf.keras.layers.MaxPooling2D() to the model\n  )\n\n  # Freeze the base model (if necessary)\n  base_model.trainable = trainable\n\n  # Create input layer\n  inputs = tf.keras.Input(shape=input_shape, name=\"input_layer\")\n\n  # Create model backbone (middle/hidden layers)\n  x = base_model(inputs, training=trainable)\n  # x = tf.keras.layers.GlobalAveragePooling2D()(x) # note: you should include pooling here if not using `pooling=\"avg\"`\n  # x = tf.keras.layers.Dropout(0.2)(x) # optional regularization layer (search \"dropout\" for more)\n\n  # Create output layer (also known as \"classifier\" layer)\n  outputs = tf.keras.layers.Dense(units=num_classes,\n                                  activation=\"softmax\",\n                                  name=\"output_layer\")(x)\n\n  # Connect input and output layer\n  model = tf.keras.Model(inputs=inputs,\n                         outputs=outputs,\n                         name=model_name)\n\n  return model\n</pre> def create_model(include_top: bool = False,                  num_classes: int = 1000,                  input_shape: tuple[int, int, int] = (224, 224, 3),                  include_preprocessing: bool = True,                  trainable: bool = False,                  dropout: float = 0.2,                  model_name: str = \"model\") -&gt; tf.keras.Model:   \"\"\"   Create an EfficientNetV2 B0 feature extractor model with a custom classifier layer.    Args:       include_top (bool, optional): Whether to include the top (classifier) layers of the model.       num_classes (int, optional): Number of output classes for the classifier layer.       input_shape (tuple[int, int, int], optional): Input shape for the model's images (height, width, channels).       include_preprocessing (bool, optional): Whether to include preprocessing layers for image normalization.       trainable (bool, optional): Whether to make the base model trainable.       dropout (float, optional): Dropout rate for the global average pooling layer.       model_name (str, optional): Name for the created model.    Returns:       tf.keras.Model: A TensorFlow Keras model with the specified configuration.   \"\"\"   # Create base model   base_model = tf.keras.applications.efficientnet_v2.EfficientNetV2B0(     include_top=include_top,     weights=\"imagenet\",     input_shape=input_shape,     include_preprocessing=include_preprocessing,     pooling=\"avg\" # Can use this instead of adding tf.keras.layers.GlobalPooling2D() to the model     # pooling=\"max\" # Can use this instead of adding tf.keras.layers.MaxPooling2D() to the model   )    # Freeze the base model (if necessary)   base_model.trainable = trainable    # Create input layer   inputs = tf.keras.Input(shape=input_shape, name=\"input_layer\")    # Create model backbone (middle/hidden layers)   x = base_model(inputs, training=trainable)   # x = tf.keras.layers.GlobalAveragePooling2D()(x) # note: you should include pooling here if not using `pooling=\"avg\"`   # x = tf.keras.layers.Dropout(0.2)(x) # optional regularization layer (search \"dropout\" for more)    # Create output layer (also known as \"classifier\" layer)   outputs = tf.keras.layers.Dense(units=num_classes,                                   activation=\"softmax\",                                   name=\"output_layer\")(x)    # Connect input and output layer   model = tf.keras.Model(inputs=inputs,                          outputs=outputs,                          name=model_name)    return model <p>What a beautiful function!</p> <p>Let's try it out.</p> In\u00a0[92]: Copied! <pre># Create a model\nmodel_0 = create_model(num_classes=len(class_names))\nmodel_0.summary()\n</pre> # Create a model model_0 = create_model(num_classes=len(class_names)) model_0.summary() <pre>Model: \"model\"\n_________________________________________________________________\n Layer (type)                Output Shape              Param #   \n=================================================================\n input_layer (InputLayer)    [(None, 224, 224, 3)]     0         \n                                                                 \n efficientnetv2-b0 (Functio  (None, 1280)              5919312   \n nal)                                                            \n                                                                 \n output_layer (Dense)        (None, 120)               153720    \n                                                                 \n=================================================================\nTotal params: 6073032 (23.17 MB)\nTrainable params: 153720 (600.47 KB)\nNon-trainable params: 5919312 (22.58 MB)\n_________________________________________________________________\n</pre> <p>Woohoo! Looks like it worked!</p> <p>Now how about we inspect each of the layers and whether they're trainable?</p> In\u00a0[93]: Copied! <pre>for layer in model_0.layers:\n  print(layer.name, layer.trainable)\n</pre> for layer in model_0.layers:   print(layer.name, layer.trainable) <pre>input_layer True\nefficientnetv2-b0 False\noutput_layer True\n</pre> <p>Nice, looks like our <code>base_model</code> (<code>efficientnetv2-b0</code>) is frozen (it's not trainable).</p> <p>And our <code>output_layer</code> is trainable.</p> <p>This means we'll be reusing the patterns learned in the <code>base_model</code> to feed into our <code>output_layer</code> and then customizing those parameters to suit our own problem.</p> In\u00a0[94]: Copied! <pre># 1. Create model\nmodel_0 = create_model(num_classes=len(class_names),\n                       model_name=\"model_0\")\n\nmodel_0.summary()\n</pre> # 1. Create model model_0 = create_model(num_classes=len(class_names),                        model_name=\"model_0\")  model_0.summary() <pre>Model: \"model_0\"\n_________________________________________________________________\n Layer (type)                Output Shape              Param #   \n=================================================================\n input_layer (InputLayer)    [(None, 224, 224, 3)]     0         \n                                                                 \n efficientnetv2-b0 (Functio  (None, 1280)              5919312   \n nal)                                                            \n                                                                 \n output_layer (Dense)        (None, 120)               153720    \n                                                                 \n=================================================================\nTotal params: 6073032 (23.17 MB)\nTrainable params: 153720 (600.47 KB)\nNon-trainable params: 5919312 (22.58 MB)\n_________________________________________________________________\n</pre> <p>Model created!</p> <p>How about we compile it?</p> In\u00a0[95]: Copied! <pre># Create optimizer (short version)\noptimizer = \"adam\"\n\n# The above line is the same as below\noptimizer = tf.keras.optimizers.Adam(learning_rate=0.001)\noptimizer\n</pre> # Create optimizer (short version) optimizer = \"adam\"  # The above line is the same as below optimizer = tf.keras.optimizers.Adam(learning_rate=0.001) optimizer Out[95]: <pre>&lt;keras.src.optimizers.adam.Adam at 0x7f3bb4107040&gt;</pre> In\u00a0[96]: Copied! <pre># Check that our labels are one-hot encoded\nlabel_batch[0]\n</pre> # Check that our labels are one-hot encoded label_batch[0] Out[96]: <pre>&lt;tf.Tensor: shape=(120,), dtype=float32, numpy=\narray([0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,\n       0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,\n       0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,\n       0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,\n       0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,\n       0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 1., 0., 0., 0., 0., 0., 0.,\n       0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,\n       0.], dtype=float32)&gt;</pre> <p>Excellent! Looks like our labels are indeed one-hot encoded.</p> <p>Now let's create our loss function as <code>tf.keras.losses.CategoricalCrossentropy(from_logits=False)</code> or <code>\"categorical_crossentropy\"</code> for short.</p> <p>We set <code>from_logits=False</code> (this is the default) because our model uses <code>activation=\"softmax\"</code> in the final layer so it's outputing prediction probabilities rather than logits (without <code>activation=\"softmax\"</code> the outputs of our model would be referred to as logits, I'll leave this for extra-curricula investigation).</p> In\u00a0[97]: Copied! <pre># Create our loss function\nloss = tf.keras.losses.CategoricalCrossentropy(from_logits=False) # use from_logits=False if using an activation function in final layer of model (default)\nloss\n</pre> # Create our loss function loss = tf.keras.losses.CategoricalCrossentropy(from_logits=False) # use from_logits=False if using an activation function in final layer of model (default) loss Out[97]: <pre>&lt;keras.src.losses.CategoricalCrossentropy at 0x7f3bb4107430&gt;</pre> In\u00a0[98]: Copied! <pre># Create list of evaluation metrics\nmetrics = [\"accuracy\"]\n</pre> # Create list of evaluation metrics metrics = [\"accuracy\"] In\u00a0[99]: Copied! <pre># Compile model with shortcuts (faster to write code but less customizable)\nmodel_0.compile(optimizer=\"adam\",\n                loss=\"categorical_crossentropy\",\n                metrics=[\"accuracy\"])\n\n# Compile model with classes (will do the same as above)\nmodel_0.compile(optimizer=tf.keras.optimizers.Adam(learning_rate=0.001),\n                loss=tf.keras.losses.CategoricalCrossentropy(from_logits=False),\n                metrics=[\"accuracy\"])\n</pre> # Compile model with shortcuts (faster to write code but less customizable) model_0.compile(optimizer=\"adam\",                 loss=\"categorical_crossentropy\",                 metrics=[\"accuracy\"])  # Compile model with classes (will do the same as above) model_0.compile(optimizer=tf.keras.optimizers.Adam(learning_rate=0.001),                 loss=tf.keras.losses.CategoricalCrossentropy(from_logits=False),                 metrics=[\"accuracy\"]) In\u00a0[100]: Copied! <pre># Fit model_0 for 5 epochs\nepochs = 5\nhistory_0 = model_0.fit(x=train_10_percent_ds,\n                        epochs=epochs,\n                        validation_data=test_ds)\n</pre> # Fit model_0 for 5 epochs epochs = 5 history_0 = model_0.fit(x=train_10_percent_ds,                         epochs=epochs,                         validation_data=test_ds) <pre>Epoch 1/5\n38/38 [==============================] - 27s 482ms/step - loss: 3.9758 - accuracy: 0.3000 - val_loss: 3.0500 - val_accuracy: 0.5415\nEpoch 2/5\n38/38 [==============================] - 14s 379ms/step - loss: 2.0531 - accuracy: 0.8008 - val_loss: 1.8650 - val_accuracy: 0.7041\nEpoch 3/5\n38/38 [==============================] - 14s 375ms/step - loss: 1.0491 - accuracy: 0.9025 - val_loss: 1.3060 - val_accuracy: 0.7548\nEpoch 4/5\n38/38 [==============================] - 14s 373ms/step - loss: 0.6138 - accuracy: 0.9483 - val_loss: 1.0317 - val_accuracy: 0.7910\nEpoch 5/5\n38/38 [==============================] - 14s 373ms/step - loss: 0.4157 - accuracy: 0.9683 - val_loss: 0.8927 - val_accuracy: 0.8044\n</pre> <p>Woah!!!</p> <p>Looks like our model performed outstandingly well!</p> <p>Achieving a validation accuracy of ~80% after just 5 epochs of training.</p> <p>That's far better than the original Stanford Dogs paper results of 22% accuracy.</p> <p>How?</p> <p>That's the power of transfer learning (and a series of modern updates to neural network architectures, hardware and training regimes)!</p> <p>But these are just numbers on a page.</p> <p>We'll get more in-depth on evaluations shortly.</p> <p>For now, let's do a recap on the 3 steps we've practiced: create, compile, fit.</p> In\u00a0[101]: Copied! <pre># 1. Create a model\nmodel_0 = create_model(num_classes=len(dog_names))\n\n# 2. Compile the model\nmodel_0.compile(optimizer=tf.keras.optimizers.Adam(learning_rate=0.001),\n                loss=\"categorical_crossentropy\",\n                metrics=[\"accuracy\"])\n\n# 3. Fit the model\nepochs = 5\nhistory_0 = model_0.fit(x=train_10_percent_ds,\n                        epochs=epochs,\n                        validation_data=test_ds)\n</pre> # 1. Create a model model_0 = create_model(num_classes=len(dog_names))  # 2. Compile the model model_0.compile(optimizer=tf.keras.optimizers.Adam(learning_rate=0.001),                 loss=\"categorical_crossentropy\",                 metrics=[\"accuracy\"])  # 3. Fit the model epochs = 5 history_0 = model_0.fit(x=train_10_percent_ds,                         epochs=epochs,                         validation_data=test_ds) <pre>Epoch 1/5\n38/38 [==============================] - 22s 418ms/step - loss: 3.9263 - accuracy: 0.3225 - val_loss: 2.9969 - val_accuracy: 0.5549\nEpoch 2/5\n38/38 [==============================] - 14s 379ms/step - loss: 1.9899 - accuracy: 0.7900 - val_loss: 1.8436 - val_accuracy: 0.7063\nEpoch 3/5\n38/38 [==============================] - 14s 380ms/step - loss: 1.0152 - accuracy: 0.9058 - val_loss: 1.2817 - val_accuracy: 0.7702\nEpoch 4/5\n38/38 [==============================] - 14s 376ms/step - loss: 0.5997 - accuracy: 0.9483 - val_loss: 1.0173 - val_accuracy: 0.7945\nEpoch 5/5\n38/38 [==============================] - 14s 374ms/step - loss: 0.4040 - accuracy: 0.9708 - val_loss: 0.8792 - val_accuracy: 0.8107\n</pre> <p>Nice! We just trained our second neural network!</p> <p>We practice these steps because they will be part of many of your future machine learning workflows.</p> <p>As an extension, you could create a function called <code>create_and_compile()</code> which does the first two steps in one hit.</p> <p>Now we've got a trained model, let's get to evaluating it.</p> In\u00a0[102]: Copied! <pre># Inspect History.history attribute for model_0\nhistory_0.history\n</pre> # Inspect History.history attribute for model_0 history_0.history Out[102]: <pre>{'loss': [3.926330089569092,\n  1.9898805618286133,\n  1.0152279138565063,\n  0.599678099155426,\n  0.4040333032608032],\n 'accuracy': [0.32249999046325684,\n  0.7900000214576721,\n  0.9058333039283752,\n  0.9483333230018616,\n  0.9708333611488342],\n 'val_loss': [2.996889591217041,\n  1.8436286449432373,\n  1.2817054986953735,\n  1.0173338651657104,\n  0.8792150616645813],\n 'val_accuracy': [0.5548951029777527,\n  0.7062937021255493,\n  0.7701631784439087,\n  0.7945221662521362,\n  0.8107225894927979]}</pre> <p>Wonderful!</p> <p>We've got a history of our model training over time.</p> <p>It looks like everything is moving in the right direction.</p> <p>Loss is going down whilst accuracy is going up.</p> <p>How about we adhere to the data explorer's motto and write a function to visualize, visualize, visualize!</p> <p>We'll call the function <code>plot_model_loss_curves()</code> and it'll take a <code>History.history</code> object as input and then plot loss and accuracy curves using <code>matplotlib</code>.</p> In\u00a0[103]: Copied! <pre>def plot_model_loss_curves(history: tf.keras.callbacks.History) -&gt; None:\n  \"\"\"Takes a History object and plots loss and accuracy curves.\"\"\"\n\n  # Get the accuracy values\n  acc = history.history[\"accuracy\"]\n  val_acc = history.history[\"val_accuracy\"]\n\n  # Get the loss values\n  loss = history.history[\"loss\"]\n  val_loss = history.history[\"val_loss\"]\n\n  # Get the number of epochs\n  epochs_range = range(len(acc))\n\n  # Create accuracy curves plot\n  plt.figure(figsize=(14, 7))\n  plt.subplot(1, 2, 1)\n  plt.plot(epochs_range, acc, label=\"Training Accuracy\")\n  plt.plot(epochs_range, val_acc, label=\"Validation Accuracy\")\n  plt.legend(loc=\"lower right\")\n  plt.title(\"Training and Validation Accuracy\")\n  plt.xlabel(\"Epoch\")\n  plt.ylabel(\"Accuracy\")\n\n  # Create loss curves plot\n  plt.subplot(1, 2, 2)\n  plt.plot(epochs_range, loss, label=\"Training Loss\")\n  plt.plot(epochs_range, val_loss, label=\"Validation Loss\")\n  plt.legend(loc=\"upper right\")\n  plt.title(\"Training and Validation Loss\")\n  plt.xlabel(\"Epoch\")\n  plt.ylabel(\"Loss\")\n\n  plt.show()\n\nplot_model_loss_curves(history=history_0)\n</pre> def plot_model_loss_curves(history: tf.keras.callbacks.History) -&gt; None:   \"\"\"Takes a History object and plots loss and accuracy curves.\"\"\"    # Get the accuracy values   acc = history.history[\"accuracy\"]   val_acc = history.history[\"val_accuracy\"]    # Get the loss values   loss = history.history[\"loss\"]   val_loss = history.history[\"val_loss\"]    # Get the number of epochs   epochs_range = range(len(acc))    # Create accuracy curves plot   plt.figure(figsize=(14, 7))   plt.subplot(1, 2, 1)   plt.plot(epochs_range, acc, label=\"Training Accuracy\")   plt.plot(epochs_range, val_acc, label=\"Validation Accuracy\")   plt.legend(loc=\"lower right\")   plt.title(\"Training and Validation Accuracy\")   plt.xlabel(\"Epoch\")   plt.ylabel(\"Accuracy\")    # Create loss curves plot   plt.subplot(1, 2, 2)   plt.plot(epochs_range, loss, label=\"Training Loss\")   plt.plot(epochs_range, val_loss, label=\"Validation Loss\")   plt.legend(loc=\"upper right\")   plt.title(\"Training and Validation Loss\")   plt.xlabel(\"Epoch\")   plt.ylabel(\"Loss\")    plt.show()  plot_model_loss_curves(history=history_0) <p>Woohoo! Now those are some nice looking curves.</p> <p>Our model is doing exactly what we'd like it to do.</p> <p>The accuracy is moving up while the loss is going down.</p> In\u00a0[104]: Copied! <pre># Evaluate model_0, see: https://www.tensorflow.org/api_docs/python/tf/keras/Model#evaluate\nmodel_0_results = model_0.evaluate(x=test_ds)\nmodel_0_results\n</pre> # Evaluate model_0, see: https://www.tensorflow.org/api_docs/python/tf/keras/Model#evaluate model_0_results = model_0.evaluate(x=test_ds) model_0_results <pre>269/269 [==============================] - 13s 47ms/step - loss: 0.8792 - accuracy: 0.8107\n</pre> Out[104]: <pre>[0.8792150616645813, 0.8107225894927979]</pre> <p>Beautiful!</p> <p>Evaluating our model on the test data shows it's performing at ~80% accuracy despite only seeing 10% of the training data.</p> <p>We can also get the metrics used by our model with the <code>metrics_names</code> attribute.</p> In\u00a0[105]: Copied! <pre># Get our model's metrics names\nmodel_0.metrics_names\n</pre> # Get our model's metrics names model_0.metrics_names Out[105]: <pre>['loss', 'accuracy']</pre> In\u00a0[106]: Copied! <pre># 1. Create model_1 (the next iteration of model_0)\nmodel_1 = create_model(num_classes=len(class_names),\n                       model_name=\"model_1\")\n\n# 2. Compile model\nmodel_1.compile(optimizer=tf.keras.optimizers.Adam(learning_rate=0.001),\n                loss=\"categorical_crossentropy\",\n                metrics=[\"accuracy\"])\n\n# 3. Fit model\nepochs=5\nhistory_1 = model_1.fit(x=train_ds,\n                        epochs=epochs,\n                        validation_data=test_ds)\n</pre> # 1. Create model_1 (the next iteration of model_0) model_1 = create_model(num_classes=len(class_names),                        model_name=\"model_1\")  # 2. Compile model model_1.compile(optimizer=tf.keras.optimizers.Adam(learning_rate=0.001),                 loss=\"categorical_crossentropy\",                 metrics=[\"accuracy\"])  # 3. Fit model epochs=5 history_1 = model_1.fit(x=train_ds,                         epochs=epochs,                         validation_data=test_ds) <pre>Epoch 1/5\n375/375 [==============================] - 43s 84ms/step - loss: 1.2725 - accuracy: 0.7607 - val_loss: 0.4849 - val_accuracy: 0.8756\nEpoch 2/5\n375/375 [==============================] - 30s 80ms/step - loss: 0.3667 - accuracy: 0.9013 - val_loss: 0.4041 - val_accuracy: 0.8770\nEpoch 3/5\n375/375 [==============================] - 30s 79ms/step - loss: 0.2641 - accuracy: 0.9287 - val_loss: 0.3731 - val_accuracy: 0.8832\nEpoch 4/5\n375/375 [==============================] - 30s 80ms/step - loss: 0.2043 - accuracy: 0.9483 - val_loss: 0.3708 - val_accuracy: 0.8819\nEpoch 5/5\n375/375 [==============================] - 30s 80ms/step - loss: 0.1606 - accuracy: 0.9633 - val_loss: 0.3753 - val_accuracy: 0.8767\n</pre> <p>Woah!</p> <p>Was your intuition correct?</p> <p>Did what you thought would happen actually happen?</p> <p>It looks like all that extra data helped our model quite a bit, it's now performing at close to ~90% accuracy on the test set!</p> Question: How many epochs should I fit for? <p>Generally with transfer learning you can get pretty good results quite quickly, however, you may want to look into training for longer (more epochs) as an experiment to see whether your model improves or not. What we've performed is a transfer learning technique called feature extraction, however, you may want to look further into fine-tuning (training the whole model to your own dataset) whole model and using callbacks (functions that take place during model training) such as Early Stopping to prevent the model from training so long its performance begins to degrade.</p> In\u00a0[107]: Copied! <pre># Plot model_1 loss curves\nplot_model_loss_curves(history=history_1)\n</pre> # Plot model_1 loss curves plot_model_loss_curves(history=history_1) <p>Hmm, looks like our model performed well, however the validation accuracy and loss seemed to flatten out.</p> <p>Whereas, the training accuracy and loss seemed to keep improving.</p> <p>This is a sign of overfitting (model performing much better on the training set than the validation/test set).</p> <p>However, since our model looks to be performing quite well I'll leave this overfitting problem as a research project for extra-curriculum.</p> <p>For now, let's evaluate our model on the test dataset using the <code>evaluate()</code> method.</p> In\u00a0[108]: Copied! <pre># Evaluate model_1\nmodel_1_results = model_1.evaluate(test_ds)\n</pre> # Evaluate model_1 model_1_results = model_1.evaluate(test_ds) <pre>269/269 [==============================] - 12s 46ms/step - loss: 0.3753 - accuracy: 0.8767\n</pre> <p>Nice!</p> <p>Looks like that extra data boosted our models performance from ~80% on the test set to ~90% on test set (note: exact numbers here may vary due to the inherit randomness in machine learning models).</p> Extension: Putting it all together <p>As a potential extension, you may want to try practicing putting all of the steps we've been through so far together. As in, loading the data, creating the model, compiling the model, fitting the model and evaluating the model. That's what I've found is one of the best ways to learn ML problems, replicating a system end to end. </p> In\u00a0[109]: Copied! <pre># This will output logits (as long as softmax activation isn't in the model)\ntest_preds = model_1.predict(test_ds)\n\n# Note: If not using activation=\"softmax\" in last layer of model, may need to turn them into prediction probabilities (easier to understand)\n# test_preds = tf.keras.activations.softmax(tf.constant(test_preds), axis=-1)\n</pre> # This will output logits (as long as softmax activation isn't in the model) test_preds = model_1.predict(test_ds)  # Note: If not using activation=\"softmax\" in last layer of model, may need to turn them into prediction probabilities (easier to understand) # test_preds = tf.keras.activations.softmax(tf.constant(test_preds), axis=-1) <pre>269/269 [==============================] - 13s 44ms/step\n</pre> <p>Let's inspect our <code>test_preds</code> by first checking its shape.</p> In\u00a0[110]: Copied! <pre>test_preds.shape\n</pre> test_preds.shape Out[110]: <pre>(8580, 120)</pre> <p>Okay, looks like our <code>test_pred</code> variable contains 8580 values (one for each test sample) with 120 elements (one value for each dog class).</p> <p>Let's inspect a single test prediction and see what it looks like.</p> In\u00a0[111]: Copied! <pre># Get a \"random\" variable between all of the test samples\nrandom.seed(42)\nrandom_test_index = random.randint(0, test_preds.shape[0] - 1)\nprint(f\"[INFO] Random test index: {random_test_index}\")\n\n# Inspect a single test prediction sample\nrandom_test_pred_sample = test_preds[random_test_index]\n\nprint(f\"[INFO] Random test pred sample shape: {random_test_pred_sample.shape}\")\nprint(f\"[INFO] Random test pred sample argmax: {tf.argmax(random_test_pred_sample)}\")\nprint(f\"[INFO] Random test pred sample label: {dog_names[tf.argmax(random_test_pred_sample)]}\")\nprint(f\"[INFO] Random test pred sample max prediction probability: {tf.reduce_max(random_test_pred_sample)}\")\nprint(f\"[INFO] Random test pred sample prediction probability values:\\n{random_test_pred_sample}\")\n</pre> # Get a \"random\" variable between all of the test samples random.seed(42) random_test_index = random.randint(0, test_preds.shape[0] - 1) print(f\"[INFO] Random test index: {random_test_index}\")  # Inspect a single test prediction sample random_test_pred_sample = test_preds[random_test_index]  print(f\"[INFO] Random test pred sample shape: {random_test_pred_sample.shape}\") print(f\"[INFO] Random test pred sample argmax: {tf.argmax(random_test_pred_sample)}\") print(f\"[INFO] Random test pred sample label: {dog_names[tf.argmax(random_test_pred_sample)]}\") print(f\"[INFO] Random test pred sample max prediction probability: {tf.reduce_max(random_test_pred_sample)}\") print(f\"[INFO] Random test pred sample prediction probability values:\\n{random_test_pred_sample}\") <pre>[INFO] Random test index: 1824\n[INFO] Random test pred sample shape: (120,)\n[INFO] Random test pred sample argmax: 24\n[INFO] Random test pred sample label: brittany_spaniel\n[INFO] Random test pred sample max prediction probability: 0.9248308539390564\n[INFO] Random test pred sample prediction probability values:\n[3.0155065e-06 4.2946940e-05 3.2878995e-06 3.1306336e-05 1.7298260e-06\n 1.3368123e-05 2.8498230e-06 6.8758955e-06 2.6828552e-06 4.6089318e-04\n 9.8374185e-06 1.9263330e-06 7.6487186e-07 6.1217276e-04 1.2198443e-06\n 5.9309714e-06 2.4797799e-05 2.5847612e-06 4.9912862e-05 3.1809162e-07\n 1.0326848e-06 2.7293386e-06 2.1035332e-06 5.2793930e-06 9.2483085e-01\n 2.6070888e-06 1.6410323e-06 1.4008251e-06 2.0515323e-05 2.1309786e-05\n 1.4602327e-06 3.8456672e-04 7.4974610e-05 4.4831428e-05 5.5091264e-06\n 2.1345174e-07 2.9732748e-06 5.5520386e-06 8.7954652e-07 1.6277906e-03\n 5.3978354e-02 9.6090174e-05 9.6672220e-06 4.4037843e-06 2.5557700e-05\n 6.3994042e-07 1.6738920e-06 4.6715216e-04 4.1448075e-06 6.4118845e-05\n 2.0398900e-06 3.6135450e-06 4.4963690e-05 2.8406910e-05 3.4689847e-07\n 6.2964758e-04 9.1336078e-05 5.2363583e-05 1.2731762e-06 2.4212743e-06\n 1.5872080e-06 6.3476455e-06 6.2880179e-07 6.6757898e-06 1.6635622e-06\n 4.3550008e-07 2.3698403e-05 1.4149221e-05 3.8156581e-05 1.0464001e-05\n 5.0107906e-06 1.7395665e-06 2.8848885e-07 4.2622072e-05 3.2712339e-07\n 1.8591476e-07 2.2874669e-05 7.9814470e-07 2.3121322e-05 1.6275973e-06\n 4.6186727e-07 7.6188849e-07 3.2468931e-06 3.1449999e-05 2.9600946e-05\n 3.8992380e-06 2.8564186e-06 4.1459539e-06 6.0877244e-07 2.5443229e-05\n 5.4467969e-06 5.4184858e-07 2.8361776e-04 9.0548929e-05 8.8840829e-07\n 9.1714105e-07 1.9990568e-07 1.7958368e-05 7.7042150e-06 2.4126435e-05\n 1.9759838e-05 8.2941342e-06 2.5857928e-05 6.1904398e-06 1.4601937e-06\n 1.5800337e-05 6.0928446e-06 5.0209674e-05 1.4067524e-05 2.3544631e-05\n 1.4134421e-06 9.8844721e-05 9.1535941e-05 2.4448002e-03 5.8540131e-06\n 1.2547853e-02 1.3779800e-05 8.0164841e-07 2.5093528e-05 3.7180773e-05]\n</pre> <p>Okay looks like each individual sample of our test predictions is a tensor of prediction probabilities.</p> <p>In essence, each element is a probability between 0 and 1 as to how confident our model is whether the prediction is correct or not.</p> <p>A prediction probability of 1 means the model is 100% confident the given sample belongs to that class.</p> <p>A prediction probability of 0 means the model isn't assigning any value value to that class at all.</p> <p>And then all the other values fill in between.</p> <p>Note: Just because a model's prediction probability for a particular sample is closer to 1 on a certain class (e.g. 0.9999) doesn't mean it is correct. A prediction can have a high probability but still be incorrect. We'll see this later on in the \"most wrong\" section.</p> <p>The maximum value of our prediction probabilities tensor is what the model considers is the most likely prediction given the specific sample.</p> <p>We take the index of the maximum value (using <code>tf.argmax</code>) and index on the list of dog names to get the predicted class name.</p> <p>Note: <code>tf.argmax</code> or \"argmax\" for short gets the index of where the maximum value occurs in a tensor along a specified dimension. We can use <code>tf.reduce_max</code> to get the maximum value itself.</p> <p>To make our predictions easier to compare to the test dataset, let's unbundle our <code>test_ds</code> object into two separate arrays called <code>test_ds_images</code> and <code>test_ds_labels</code>.</p> <p>We can do this by looping through the samples in our <code>test_ds</code> object and appending each to a list (we'll do this with a list comprehension).</p> <p>Then we can join those lists together into an array with <code>np.concatenate</code>.</p> In\u00a0[112]: Copied! <pre>import numpy as np\n\n# Extract test images and labels from test_ds\ntest_ds_images = np.concatenate([images for images, labels in test_ds], axis=0)\ntest_ds_labels = np.concatenate([labels for images, labels in test_ds], axis=0)\n\n# How many images and labels do we have?\nlen(test_ds_images), len(test_ds_labels)\n</pre> import numpy as np  # Extract test images and labels from test_ds test_ds_images = np.concatenate([images for images, labels in test_ds], axis=0) test_ds_labels = np.concatenate([labels for images, labels in test_ds], axis=0)  # How many images and labels do we have? len(test_ds_images), len(test_ds_labels) Out[112]: <pre>(8580, 8580)</pre> <p>Perfect!</p> <p>Now we've got a way to compare our predictions on a given image (in <code>test_ds_images</code>) to its appropriate label in <code>test_ds_labels</code>.</p> <p>This is one of the main reasons we didn't shuffle the test dataset.</p> <p>Because now our predictions tensor has the same indexes as our <code>test_ds_images</code> and <code>test_ds_labels</code> arrays.</p> <p>Meaning if we chose to compare sample number <code>42</code>, everything would line up.</p> <p>In fact, let's try just that.</p> In\u00a0[113]: Copied! <pre># Set target index\ntarget_index = 42 # try changing this to another value and seeing how the model performs on other samples\n\n# Get test image\ntest_image = test_ds_images[target_index]\n\n# Get truth label (index of max in test label)\ntest_image_truth_label = class_names[tf.argmax(test_ds_labels[target_index])]\n\n# Get prediction probabilities\ntest_image_pred_probs = test_preds[target_index]\n\n# Get index of class with highest prediction probability\ntest_image_pred_class = class_names[tf.argmax(test_image_pred_probs)]\n\n# Plot the image\nplt.figure(figsize=(5, 4))\nplt.imshow(test_image.astype(\"uint8\"))\n\n# Create sample title with prediction probability value\ntitle = f\"\"\"True: {test_image_truth_label}\nPred: {test_image_pred_class}\nProb: {np.max(test_image_pred_probs):.2f}\"\"\"\n\n# Colour the title based on correctness of pred\nplt.title(title,\n          color=\"green\" if test_image_truth_label == test_image_pred_class else \"red\")\nplt.axis(\"off\");\n</pre> # Set target index target_index = 42 # try changing this to another value and seeing how the model performs on other samples  # Get test image test_image = test_ds_images[target_index]  # Get truth label (index of max in test label) test_image_truth_label = class_names[tf.argmax(test_ds_labels[target_index])]  # Get prediction probabilities test_image_pred_probs = test_preds[target_index]  # Get index of class with highest prediction probability test_image_pred_class = class_names[tf.argmax(test_image_pred_probs)]  # Plot the image plt.figure(figsize=(5, 4)) plt.imshow(test_image.astype(\"uint8\"))  # Create sample title with prediction probability value title = f\"\"\"True: {test_image_truth_label} Pred: {test_image_pred_class} Prob: {np.max(test_image_pred_probs):.2f}\"\"\"  # Colour the title based on correctness of pred plt.title(title,           color=\"green\" if test_image_truth_label == test_image_pred_class else \"red\") plt.axis(\"off\"); <p>Woohoo!!! Look at that!</p> <p>Looks like our model got the prediction right, according to the test data, sample number <code>42</code> is in fact an Affenpinscher.</p> <p>Doing a quick search on Google for Affenpinscher seems to return similar looking dogs too.</p> <p>Our model is working!</p> <p>For sample <code>42</code> at least...</p> <p>As an exercise you could try to change the target index above, perhaps to your favourite number and see how the model goes.</p> <p>But we could also write some code to test a number of different samples at a time.</p> In\u00a0[114]: Copied! <pre># Choose a random 10 indexes from the test data and compare the values\nimport random\n\nrandom.seed(42) # try changing the random seed or commenting it out for different values\nrandom_indexes = random.sample(range(len(test_ds_images)), 10)\n\n# Create a plot with multiple subplots\nfig, axes = plt.subplots(2, 5, figsize=(15, 7))\n\n# Loop through the axes of the plot\nfor i, ax in enumerate(axes.flatten()):\n  target_index = random_indexes[i] # get a random index (this is another reason we didn't shuffle the test set)\n\n  # Get relevant target image, label, prediction and prediction probabilities\n  test_image = test_ds_images[target_index]\n  test_image_truth_label = class_names[tf.argmax(test_ds_labels[target_index])]\n  test_image_pred_probs = test_preds[target_index]\n  test_image_pred_class = class_names[tf.argmax(test_image_pred_probs)]\n\n  # Plot the image\n  ax.imshow(test_image.astype(\"uint8\"))\n\n  # Create sample title\n  title = f\"\"\"True: {test_image_truth_label}\n  Pred: {test_image_pred_class}\n  Prob: {np.max(test_image_pred_probs):.2f}\"\"\"\n\n  # Colour the title based on correctness of pred\n  ax.set_title(title,\n               color=\"green\" if test_image_truth_label == test_image_pred_class else \"red\")\n  ax.axis(\"off\")\n</pre> # Choose a random 10 indexes from the test data and compare the values import random  random.seed(42) # try changing the random seed or commenting it out for different values random_indexes = random.sample(range(len(test_ds_images)), 10)  # Create a plot with multiple subplots fig, axes = plt.subplots(2, 5, figsize=(15, 7))  # Loop through the axes of the plot for i, ax in enumerate(axes.flatten()):   target_index = random_indexes[i] # get a random index (this is another reason we didn't shuffle the test set)    # Get relevant target image, label, prediction and prediction probabilities   test_image = test_ds_images[target_index]   test_image_truth_label = class_names[tf.argmax(test_ds_labels[target_index])]   test_image_pred_probs = test_preds[target_index]   test_image_pred_class = class_names[tf.argmax(test_image_pred_probs)]    # Plot the image   ax.imshow(test_image.astype(\"uint8\"))    # Create sample title   title = f\"\"\"True: {test_image_truth_label}   Pred: {test_image_pred_class}   Prob: {np.max(test_image_pred_probs):.2f}\"\"\"    # Colour the title based on correctness of pred   ax.set_title(title,                color=\"green\" if test_image_truth_label == test_image_pred_class else \"red\")   ax.axis(\"off\") <p>Woah, looks like our model does quite well!</p> <p>Try commenting out the <code>random.seed()</code> line and inspecting a few more dog photos, you might notice that model doesn't get too many wrong!</p> In\u00a0[115]: Copied! <pre># Get argmax labels of test predictions and test ground truth\ntest_preds_labels = test_preds.argmax(axis=-1)\ntest_ds_labels_argmax = test_ds_labels.argmax(axis=-1)\n\n# Get highest prediction probability of test predictions\ntest_pred_probs_max = tf.reduce_max(test_preds, axis=-1).numpy() # extract NumPy since pandas doesn't handle TensorFlow Tensors\n\n# Create DataFram of test results\ntest_results_df = pd.DataFrame({\"test_pred_label\": test_preds_labels,\n                                \"test_pred_prob\": test_pred_probs_max,\n                                \"test_pred_class_name\": [class_names[test_pred_label] for test_pred_label in test_preds_labels],\n                                \"test_truth_label\": test_ds_labels_argmax,\n                                \"test_truth_class_name\": [class_names[test_truth_label] for test_truth_label in test_ds_labels_argmax]})\n\n# Create a column whether or not the prediction matches the label\ntest_results_df[\"correct\"] = test_results_df[\"test_pred_class_name\"] == test_results_df[\"test_truth_class_name\"]\n\ntest_results_df.head()\n</pre> # Get argmax labels of test predictions and test ground truth test_preds_labels = test_preds.argmax(axis=-1) test_ds_labels_argmax = test_ds_labels.argmax(axis=-1)  # Get highest prediction probability of test predictions test_pred_probs_max = tf.reduce_max(test_preds, axis=-1).numpy() # extract NumPy since pandas doesn't handle TensorFlow Tensors  # Create DataFram of test results test_results_df = pd.DataFrame({\"test_pred_label\": test_preds_labels,                                 \"test_pred_prob\": test_pred_probs_max,                                 \"test_pred_class_name\": [class_names[test_pred_label] for test_pred_label in test_preds_labels],                                 \"test_truth_label\": test_ds_labels_argmax,                                 \"test_truth_class_name\": [class_names[test_truth_label] for test_truth_label in test_ds_labels_argmax]})  # Create a column whether or not the prediction matches the label test_results_df[\"correct\"] = test_results_df[\"test_pred_class_name\"] == test_results_df[\"test_truth_class_name\"]  test_results_df.head() Out[115]: test_pred_label test_pred_prob test_pred_class_name test_truth_label test_truth_class_name correct 0 0 0.974350 affenpinscher 0 affenpinscher True 1 0 0.694450 affenpinscher 0 affenpinscher True 2 0 0.993829 affenpinscher 0 affenpinscher True 3 44 0.691742 flat_coated_retriever 0 affenpinscher False 4 0 0.989754 affenpinscher 0 affenpinscher True <p>What a cool looking DataFrame!</p> <p>Now we can perform some further analysis.</p> <p>Such as getting the accuracy per class.</p> <p>We can do so by grouping the <code>test_results_df</code> via the <code>\"test_truth_class_name\"</code> column and then taking the mean of the <code>\"correct\"</code> column.</p> <p>We can then create a new DataFrame based on this view and sort the values by correctness (e.g. the classes with the highest performance should be up the top).</p> In\u00a0[116]: Copied! <pre># Calculate accuracy per class\naccuracy_per_class = test_results_df.groupby(\"test_truth_class_name\")[\"correct\"].mean()\n\n# Create new DataFrame to sort classes by accuracy\naccuracy_per_class_df = pd.DataFrame(accuracy_per_class).reset_index().sort_values(\"correct\", ascending=False)\naccuracy_per_class_df.head()\n</pre> # Calculate accuracy per class accuracy_per_class = test_results_df.groupby(\"test_truth_class_name\")[\"correct\"].mean()  # Create new DataFrame to sort classes by accuracy accuracy_per_class_df = pd.DataFrame(accuracy_per_class).reset_index().sort_values(\"correct\", ascending=False) accuracy_per_class_df.head() Out[116]: test_truth_class_name correct 10 bedlington_terrier 1.000000 62 keeshond 1.000000 30 chow 0.989583 92 saint_bernard 0.985714 2 african_hunting_dog 0.985507 <p>Woah! Looks like we've got a fair few dog classes with close to (or exactly) 100% accuracy!</p> <p>That's outstanding!</p> <p>Now let's recreate the horizontal bar plot used on the original Stanford Dogs research paper page.</p> In\u00a0[117]: Copied! <pre># Let's create a horizontal bar chart to replicate a similar plot to the original Stanford Dogs page\nplt.figure(figsize=(10, 17))\nplt.barh(y=accuracy_per_class_df[\"test_truth_class_name\"],\n         width=accuracy_per_class_df[\"correct\"])\nplt.xlabel(\"Accuracy\")\nplt.ylabel(\"Class Name\")\nplt.title(\"Dog Vision Accuracy per Class\")\nplt.ylim(-0.5, len(accuracy_per_class_df[\"test_truth_class_name\"]) - 0.5)  # Adjust y-axis limits to reduce white space\nplt.gca().invert_yaxis()  # This will display the first class at the top\nplt.tight_layout()\nplt.show()\n</pre> # Let's create a horizontal bar chart to replicate a similar plot to the original Stanford Dogs page plt.figure(figsize=(10, 17)) plt.barh(y=accuracy_per_class_df[\"test_truth_class_name\"],          width=accuracy_per_class_df[\"correct\"]) plt.xlabel(\"Accuracy\") plt.ylabel(\"Class Name\") plt.title(\"Dog Vision Accuracy per Class\") plt.ylim(-0.5, len(accuracy_per_class_df[\"test_truth_class_name\"]) - 0.5)  # Adjust y-axis limits to reduce white space plt.gca().invert_yaxis()  # This will display the first class at the top plt.tight_layout() plt.show() <p>Goodness me!</p> <p>Looks like our model performs incredibly well across all the vast majority of classes.</p> <p>Comparing it to the original Stanford Dogs horizontal bar graph we can see that their best performing class got close to 60% accuracy.</p> <p>However, it's only when we take a look at our worst performing classes do we see a handful of classes just under 60% accuracy.</p> In\u00a0[118]: Copied! <pre># Inspecting our worst performing classes (note how only a couple of classes perform at ~55% accuracy or below)\naccuracy_per_class_df.tail()\n</pre> # Inspecting our worst performing classes (note how only a couple of classes perform at ~55% accuracy or below) accuracy_per_class_df.tail() Out[118]: test_truth_class_name correct 104 staffordshire_bullterrier 0.672727 76 miniature_poodle 0.654545 90 rhodesian_ridgeback 0.638889 71 malamute 0.615385 101 siberian_husky 0.271739 <p>What an awesome result!</p> <p>We've now replicated and even vastly improved a Stanford research paper.</p> <p>You should be proud!</p> <p>Now we've seen how well our model performs, how about we check where its performed poorly?</p> In\u00a0[119]: Copied! <pre># Get most wrong\ntop_100_most_wrong = test_results_df[test_results_df[\"correct\"] == 0].sort_values(\"test_pred_prob\", ascending=False)[:100]\ntop_100_most_wrong.head()\n</pre> # Get most wrong top_100_most_wrong = test_results_df[test_results_df[\"correct\"] == 0].sort_values(\"test_pred_prob\", ascending=False)[:100] top_100_most_wrong.head() Out[119]: test_pred_label test_pred_prob test_pred_class_name test_truth_label test_truth_class_name correct 2727 75 0.997043 miniature_pinscher 38 doberman False 5480 44 0.995325 flat_coated_retriever 78 newfoundland False 6884 54 0.994142 groenendael 95 schipperke False 4155 55 0.987126 ibizan_hound 60 italian_greyhound False 1715 85 0.984834 pekinese 22 brabancon_griffon False <p>One way would be to inspect these most wrong predictions would be to go through the different breeds one by one and see why the model would've confused them.</p> <p>Such as comparing <code>miniature_pinscher</code> to <code>doberman</code> (two quite similar looking dog breeds).</p> <p>Alternatively, we could get a random 10 samples and plot them to see what they look like.</p> <p>Let's do the latter!</p> In\u00a0[120]: Copied! <pre># Get 10 random indexes of \"most wrong\" predictions\ntop_100_most_wrong.sample(n=10).index\n</pre> # Get 10 random indexes of \"most wrong\" predictions top_100_most_wrong.sample(n=10).index Out[120]: <pre>Index([2001, 1715, 8112, 1642, 5480, 6383, 7363, 4155, 7895, 4105], dtype='int64')</pre> <p>How about we plot these indexes?</p> In\u00a0[121]: Copied! <pre># Choose a random 10 indexes from the test data and compare the values\nimport random\n\nrandom_most_wrong_indexes = top_100_most_wrong.sample(n=10).index\n\n# Iterate through test results and plot them\n# Note: This is why we don't shuffle the test data, so that it's in original order when we evaluate it.\nfig, axes = plt.subplots(2, 5, figsize=(15, 7))\nfor i, ax in enumerate(axes.flatten()):\n  target_index = random_most_wrong_indexes[i]\n\n  # Get relevant target image, label, prediction and prediction probabilities\n  test_image = test_ds_images[target_index]\n  test_image_truth_label = class_names[tf.argmax(test_ds_labels[target_index])]\n  test_image_pred_probs = test_preds[target_index]\n  test_image_pred_class = class_names[tf.argmax(test_image_pred_probs)]\n\n  # Plot the image\n  ax.imshow(test_image.astype(\"uint8\"))\n\n  # Create sample title\n  title = f\"\"\"True: {test_image_truth_label}\n  Pred: {test_image_pred_class}\n  Prob: {np.max(test_image_pred_probs):.2f}\"\"\"\n\n  # Colour the title based on correctness of pred\n  ax.set_title(title,\n               color=\"green\" if test_image_truth_label == test_image_pred_class else \"red\",\n               fontsize=10)\n  ax.axis(\"off\")\n</pre> # Choose a random 10 indexes from the test data and compare the values import random  random_most_wrong_indexes = top_100_most_wrong.sample(n=10).index  # Iterate through test results and plot them # Note: This is why we don't shuffle the test data, so that it's in original order when we evaluate it. fig, axes = plt.subplots(2, 5, figsize=(15, 7)) for i, ax in enumerate(axes.flatten()):   target_index = random_most_wrong_indexes[i]    # Get relevant target image, label, prediction and prediction probabilities   test_image = test_ds_images[target_index]   test_image_truth_label = class_names[tf.argmax(test_ds_labels[target_index])]   test_image_pred_probs = test_preds[target_index]   test_image_pred_class = class_names[tf.argmax(test_image_pred_probs)]    # Plot the image   ax.imshow(test_image.astype(\"uint8\"))    # Create sample title   title = f\"\"\"True: {test_image_truth_label}   Pred: {test_image_pred_class}   Prob: {np.max(test_image_pred_probs):.2f}\"\"\"    # Colour the title based on correctness of pred   ax.set_title(title,                color=\"green\" if test_image_truth_label == test_image_pred_class else \"red\",                fontsize=10)   ax.axis(\"off\") <p>Inspecting the \"most wrong\" examples, it's easy to see where the model got confused.</p> <p>These samples can show us where we might want to collect more data or correct our data's labels.</p> <p>Speaking of confused, how about we make a confusion matrix for further evaluation?</p> In\u00a0[122]: Copied! <pre>from sklearn.metrics import confusion_matrix, ConfusionMatrixDisplay\n\n# Create a confusion matrix\nconfusion_matrix_dog_preds = confusion_matrix(y_true=test_ds_labels_argmax, # requires all labels to be in same format (e.g. not one-hot)\n                                              y_pred=test_preds_labels)\n# Create a confusion matrix plot\nconfusion_matrix_display = ConfusionMatrixDisplay(confusion_matrix=confusion_matrix_dog_preds,\n                                                  display_labels=class_names)\nfig, ax = plt.subplots(figsize=(25, 25))\nax.set_title(\"Dog Vision Confusion Matrix\")\nconfusion_matrix_display.plot(xticks_rotation=\"vertical\",\n                              cmap=\"Blues\",\n                              colorbar=False,\n                              ax=ax);\n</pre> from sklearn.metrics import confusion_matrix, ConfusionMatrixDisplay  # Create a confusion matrix confusion_matrix_dog_preds = confusion_matrix(y_true=test_ds_labels_argmax, # requires all labels to be in same format (e.g. not one-hot)                                               y_pred=test_preds_labels) # Create a confusion matrix plot confusion_matrix_display = ConfusionMatrixDisplay(confusion_matrix=confusion_matrix_dog_preds,                                                   display_labels=class_names) fig, ax = plt.subplots(figsize=(25, 25)) ax.set_title(\"Dog Vision Confusion Matrix\") confusion_matrix_display.plot(xticks_rotation=\"vertical\",                               cmap=\"Blues\",                               colorbar=False,                               ax=ax); <p>Now that's one big confusion matrix!</p> <p>It looks like most of the darker blue boxes are down the middle diagonal (we we'd like them to be).</p> <p>But there are a few instances where the model confuses classes such as <code>scottish_deerhound</code> and <code>irish_wolfhound</code>.</p> <p>And looking up those two breeds we can see that they look visually similar.</p> In\u00a0[123]: Copied! <pre># Save the model to .keras\nmodel_save_path = \"dog_vision_model.keras\"\nmodel_1.save(filepath=model_save_path,\n             save_format=\"keras\")\n</pre> # Save the model to .keras model_save_path = \"dog_vision_model.keras\" model_1.save(filepath=model_save_path,              save_format=\"keras\") <p>Model saved!</p> <p>And we can load it back in using the <code>tf.keras.models.load_model()</code> method.</p> In\u00a0[124]: Copied! <pre># Load the model\nloaded_model = tf.keras.models.load_model(filepath=model_save_path)\n</pre> # Load the model loaded_model = tf.keras.models.load_model(filepath=model_save_path) <p>And now we can evaluate our <code>loaded_model</code> to make sure it performs well on the test dataset.</p> In\u00a0[125]: Copied! <pre># Evaluate the loaded model\nloaded_model_results = loaded_model.evaluate(test_ds)\n</pre> # Evaluate the loaded model loaded_model_results = loaded_model.evaluate(test_ds) <pre>269/269 [==============================] - 15s 47ms/step - loss: 0.3753 - accuracy: 0.8767\n</pre> <p>How about we check if the <code>loaded_model_results</code> are the same as the <code>model_1_results</code>?</p> In\u00a0[126]: Copied! <pre>assert model_1_results == loaded_model_results\n</pre> assert model_1_results == loaded_model_results <p>Our trained model and loaded model results are the same!</p> <p>We could now use our <code>dog_vision_model.keras</code> file in an application to predict a dog breed based on an image.</p> <p>Note: If you're using Google Colab, remember that after a period of time if you Google Colab instance gets disconnected, it will delete all local files. So if you want to keep your <code>dog_vision_model.keras</code> be sure to download it or copy it to Google Drive.</p> In\u00a0[127]: Copied! <pre># Download a set of custom images from GitHub and unzip them\n!wget -nc https://github.com/mrdbourke/zero-to-mastery-ml/raw/master/images/dog-photos.zip\n!unzip dog-photos.zip\n</pre> # Download a set of custom images from GitHub and unzip them !wget -nc https://github.com/mrdbourke/zero-to-mastery-ml/raw/master/images/dog-photos.zip !unzip dog-photos.zip <pre>--2024-04-26 01:43:26--  https://github.com/mrdbourke/zero-to-mastery-ml/raw/master/images/dog-photos.zip\nResolving github.com (github.com)... 140.82.113.4\nConnecting to github.com (github.com)|140.82.113.4|:443... connected.\nHTTP request sent, awaiting response... 302 Found\nLocation: https://raw.githubusercontent.com/mrdbourke/zero-to-mastery-ml/master/images/dog-photos.zip [following]\n--2024-04-26 01:43:26--  https://raw.githubusercontent.com/mrdbourke/zero-to-mastery-ml/master/images/dog-photos.zip\nResolving raw.githubusercontent.com (raw.githubusercontent.com)... 185.199.108.133, 185.199.109.133, 185.199.110.133, ...\nConnecting to raw.githubusercontent.com (raw.githubusercontent.com)|185.199.108.133|:443... connected.\nHTTP request sent, awaiting response... 200 OK\nLength: 1091355 (1.0M) [application/zip]\nSaving to: \u2018dog-photos.zip\u2019\n\ndog-photos.zip      100%[===================&gt;]   1.04M  --.-KB/s    in 0.05s   \n\n2024-04-26 01:43:27 (21.6 MB/s) - \u2018dog-photos.zip\u2019 saved [1091355/1091355]\n\nArchive:  dog-photos.zip\n  inflating: dog-photo-4.jpeg        \n  inflating: dog-photo-1.jpeg        \n  inflating: dog-photo-2.jpeg        \n  inflating: dog-photo-3.jpeg        \n</pre> <p>Wonderful! We can inspect our images in the file browser and see that they're under the name <code>dog-photo-*.jpeg</code>.</p> <p>How about we iterate through them and visualize each one?</p> In\u00a0[128]: Copied! <pre># Create list of paths for custom dog images\ncustom_image_paths = [\"dog-photo-1.jpeg\",\n                      \"dog-photo-2.jpeg\",\n                      \"dog-photo-3.jpeg\",\n                      \"dog-photo-4.jpeg\"]\n\n# Iterate through list of dog images and plot each one\nfig, axes = plt.subplots(1, 4, figsize=(15, 7))\nfor i, ax in enumerate(axes.flatten()):\n  ax.imshow(plt.imread(custom_image_paths[i]))\n  ax.axis(\"off\")\n  ax.set_title(custom_image_paths[i])\n</pre> # Create list of paths for custom dog images custom_image_paths = [\"dog-photo-1.jpeg\",                       \"dog-photo-2.jpeg\",                       \"dog-photo-3.jpeg\",                       \"dog-photo-4.jpeg\"]  # Iterate through list of dog images and plot each one fig, axes = plt.subplots(1, 4, figsize=(15, 7)) for i, ax in enumerate(axes.flatten()):   ax.imshow(plt.imread(custom_image_paths[i]))   ax.axis(\"off\")   ax.set_title(custom_image_paths[i]) <p>What?</p> <p>The first three photos look well and good but we can see <code>dog-photo-4.jpeg</code> is a photo of me in a black hoodie pulling a blue steel face.</p> <p>We'll see why this is later.</p> <p>For now, let's use our <code>loaded_model</code> to try and make a prediction on the first dog image (<code>dog-photo-1.jpeg</code>)!</p> <p>We can do so with the <code>predict()</code> method.</p> In\u00a0[129]: Copied! <pre># Try and make a prediction on the first dog image\nloaded_model.predict(\"dog-photo-1.jpeg\")\n</pre> # Try and make a prediction on the first dog image loaded_model.predict(\"dog-photo-1.jpeg\") <pre>\n---------------------------------------------------------------------------\nIndexError                                Traceback (most recent call last)\n&lt;ipython-input-129-336b90293288&gt; in &lt;cell line: 2&gt;()\n      1 # Try and make a prediction on the first dog image\n----&gt; 2 loaded_model.predict(\"dog-photo-1.jpeg\")\n\n/usr/local/lib/python3.10/dist-packages/keras/src/utils/traceback_utils.py in error_handler(*args, **kwargs)\n     68             # To get the full stack trace, call:\n     69             # `tf.debugging.disable_traceback_filtering()`\n---&gt; 70             raise e.with_traceback(filtered_tb) from None\n     71         finally:\n     72             del filtered_tb\n\n/usr/local/lib/python3.10/dist-packages/tensorflow/python/framework/tensor_shape.py in __getitem__(self, key)\n    960       else:\n    961         if self._v2_behavior:\n--&gt; 962           return self._dims[key]\n    963         else:\n    964           return self.dims[key]\n\nIndexError: tuple index out of range</pre> <p>Oh no!</p> <p>We get an error:</p> <p><code>IndexError: tuple index out of range</code></p> <p>This is a little hard to understand. But we can see the code is trying to get the shape of our image.</p> <p>However, we didn't pass an image to the <code>predict()</code> method.</p> <p>We only passed a filepath.</p> <p>Our model expects inputs in the same format it was trained on.</p> <p>So let's load our image and resize it.</p> <p>We can do so with <code>tf.keras.utils.load_img()</code>.</p> In\u00a0[130]: Copied! <pre># Load the image (into PIL format)\ncustom_image = tf.keras.utils.load_img(\n  path=\"dog-photo-1.jpeg\",\n  color_mode=\"rgb\",\n  target_size=IMG_SIZE, # (224, 224) or (img_height, img_width)\n)\n\ntype(custom_image), custom_image\n</pre> # Load the image (into PIL format) custom_image = tf.keras.utils.load_img(   path=\"dog-photo-1.jpeg\",   color_mode=\"rgb\",   target_size=IMG_SIZE, # (224, 224) or (img_height, img_width) )  type(custom_image), custom_image Out[130]: <pre>(PIL.Image.Image, &lt;PIL.Image.Image image mode=RGB size=224x224&gt;)</pre> <p>Excellent, we've loaded our first custom image.</p> <p>But now let's turn our image into a tensor (our model was trained on image tensors, so it expects image tensors as input).</p> <p>We can convert our image from PIL format to array format with <code>tf.keras.utils.img_to_array()</code>.</p> In\u00a0[131]: Copied! <pre># Turn the image into a tensor\ncustom_image_tensor = tf.keras.utils.img_to_array(custom_image)\ncustom_image_tensor.shape\n</pre> # Turn the image into a tensor custom_image_tensor = tf.keras.utils.img_to_array(custom_image) custom_image_tensor.shape Out[131]: <pre>(224, 224, 3)</pre> <p>Nice! We've got an image tensor of shape <code>(224, 224, 3)</code>.</p> <p>How about we make a prediction on it?</p> In\u00a0[132]: Copied! <pre># Make a prediction on our custom image tensor\nloaded_model.predict(custom_image_tensor)\n</pre> # Make a prediction on our custom image tensor loaded_model.predict(custom_image_tensor) <pre>\n---------------------------------------------------------------------------\nValueError                                Traceback (most recent call last)\n&lt;ipython-input-132-bd82d1e41fed&gt; in &lt;cell line: 2&gt;()\n      1 # Make a prediction on our custom image tensor\n----&gt; 2 loaded_model.predict(custom_image_tensor)\n\n/usr/local/lib/python3.10/dist-packages/keras/src/utils/traceback_utils.py in error_handler(*args, **kwargs)\n     68             # To get the full stack trace, call:\n     69             # `tf.debugging.disable_traceback_filtering()`\n---&gt; 70             raise e.with_traceback(filtered_tb) from None\n     71         finally:\n     72             del filtered_tb\n\n/usr/local/lib/python3.10/dist-packages/keras/src/engine/training.py in tf__predict_function(iterator)\n     13                 try:\n     14                     do_return = True\n---&gt; 15                     retval_ = ag__.converted_call(ag__.ld(step_function), (ag__.ld(self), ag__.ld(iterator)), None, fscope)\n     16                 except:\n     17                     do_return = False\n\nValueError: in user code:\n\n    File \"/usr/local/lib/python3.10/dist-packages/keras/src/engine/training.py\", line 2440, in predict_function  *\n        return step_function(self, iterator)\n    File \"/usr/local/lib/python3.10/dist-packages/keras/src/engine/training.py\", line 2425, in step_function  **\n        outputs = model.distribute_strategy.run(run_step, args=(data,))\n    File \"/usr/local/lib/python3.10/dist-packages/keras/src/engine/training.py\", line 2413, in run_step  **\n        outputs = model.predict_step(data)\n    File \"/usr/local/lib/python3.10/dist-packages/keras/src/engine/training.py\", line 2381, in predict_step\n        return self(x, training=False)\n    File \"/usr/local/lib/python3.10/dist-packages/keras/src/utils/traceback_utils.py\", line 70, in error_handler\n        raise e.with_traceback(filtered_tb) from None\n    File \"/usr/local/lib/python3.10/dist-packages/keras/src/engine/input_spec.py\", line 298, in assert_input_compatibility\n        raise ValueError(\n\n    ValueError: Input 0 of layer \"model_1\" is incompatible with the layer: expected shape=(None, 224, 224, 3), found shape=(32, 224, 3)\n</pre> <p>What?!?</p> <p>We get another error...</p> <p><code>ValueError: Input 0 of layer \"model_1\" is incompatible with the layer: expected shape=(None, 224, 224, 3), found shape=(32, 224, 3)</code></p> <p>Hmm.</p> <p>Looks like our model is expecting a batch size dimension on our input tensor.</p> <p>We can do this by either turning the input tensor into a single element array or by using <code>tf.expand_dims(input, axis=0)</code> to expand the dimenion of the tensor on 0th axis.</p> In\u00a0[133]: Copied! <pre># Option 1: Add batch dimension to custom_image_tensor\nprint(f\"Shape of custom image tensor: {np.array([custom_image_tensor]).shape}\")\nprint(f\"Shape of custom image tensor: {tf.expand_dims(custom_image_tensor, axis=0).shape}\")\n</pre> # Option 1: Add batch dimension to custom_image_tensor print(f\"Shape of custom image tensor: {np.array([custom_image_tensor]).shape}\") print(f\"Shape of custom image tensor: {tf.expand_dims(custom_image_tensor, axis=0).shape}\") <pre>Shape of custom image tensor: (1, 224, 224, 3)\nShape of custom image tensor: (1, 224, 224, 3)\n</pre> <p>Wonderful! We've now got a custom image tensor of shape <code>(1, 224, 224, 3)</code> (<code>(batch_size, img_height, img_width, colour_channels)</code>).</p> <p>Let's try and predict!</p> In\u00a0[134]: Copied! <pre># Get prediction probabilities from our mdoel\npred_probs = loaded_model.predict(tf.expand_dims(custom_image_tensor, axis=0))\npred_probs\n</pre> # Get prediction probabilities from our mdoel pred_probs = loaded_model.predict(tf.expand_dims(custom_image_tensor, axis=0)) pred_probs <pre>1/1 [==============================] - 2s 2s/step\n</pre> Out[134]: <pre>array([[1.83611644e-06, 3.09535017e-06, 3.86047805e-06, 3.19048486e-05,\n        1.66974694e-03, 1.27542022e-04, 7.03033629e-06, 1.19856362e-04,\n        1.01050091e-05, 3.87266744e-04, 6.44192414e-06, 1.67636438e-06,\n        8.94749770e-04, 5.01931618e-06, 1.60283549e-03, 9.41093604e-05,\n        4.67637838e-05, 8.51367513e-05, 5.67736897e-05, 6.14693909e-06,\n        2.67342989e-06, 1.47549901e-04, 4.17501433e-05, 3.90995192e-05,\n        9.50478498e-05, 1.47656752e-02, 3.08718845e-05, 1.58209339e-04,\n        8.39364156e-03, 1.17800606e-03, 2.69454729e-04, 1.02170045e-04,\n        7.42143384e-05, 8.22680071e-04, 1.73064705e-04, 8.98789040e-06,\n        6.77722392e-06, 2.46034167e-03, 1.21447938e-05, 3.06540052e-04,\n        1.12927992e-04, 1.30907722e-06, 1.19819895e-04, 3.28008295e-03,\n        4.22435085e-04, 2.56334723e-04, 6.35078293e-04, 6.96951101e-05,\n        1.82968670e-05, 6.66733533e-02, 1.65604251e-06, 4.85742465e-04,\n        3.82422912e-03, 4.36909148e-04, 1.34899176e-06, 4.04351122e-05,\n        2.30197293e-05, 7.29483800e-05, 1.31009811e-05, 1.30437169e-04,\n        1.27625071e-05, 3.21804691e-06, 6.78410470e-06, 3.72191658e-03,\n        9.23305777e-07, 4.05427454e-06, 1.32554891e-02, 8.34832132e-01,\n        1.84010264e-06, 5.39118366e-04, 2.44915718e-05, 1.35658804e-04,\n        9.53144918e-04, 3.80869096e-05, 3.43683018e-06, 3.57066506e-06,\n        2.41459438e-05, 2.93612948e-06, 1.27533756e-04, 2.15716864e-05,\n        3.21038242e-05, 7.87725276e-06, 1.70349504e-05, 4.27997729e-05,\n        5.72475437e-06, 1.81680916e-05, 1.28094471e-04, 7.12008550e-05,\n        8.24760180e-04, 6.14038622e-03, 4.27179504e-03, 3.55221750e-03,\n        1.20739173e-03, 4.15856484e-04, 1.61429329e-04, 1.58363022e-04,\n        3.78229856e-06, 1.03004022e-05, 2.00551622e-05, 1.21213234e-04,\n        2.68000053e-06, 1.00253812e-04, 4.04065868e-05, 9.84299404e-05,\n        1.29673525e-03, 3.07669543e-05, 1.62672077e-05, 1.17529435e-05,\n        3.74953932e-04, 4.74653389e-05, 1.00191637e-05, 1.36496616e-04,\n        3.76833777e-05, 1.55215133e-02, 2.33796614e-04, 1.01105807e-05,\n        8.56942424e-05, 1.37508148e-04, 3.79100857e-06, 1.04301716e-05]],\n      dtype=float32)</pre> <p>It worked!!!</p> <p>Our model output a tensor of prediction probabilities.</p> <p>We can find the predicted label by taking the argmax of the <code>pred_probs</code> tensor.</p> <p>And we get the predicted class name by indexing on the <code>class_names</code> list using the predicted label.</p> In\u00a0[135]: Copied! <pre># Get the predicted class label\npred_label = tf.argmax(pred_probs, axis=-1).numpy()[0]\n\n# Get the predicted class name\npred_class_name = class_names[pred_label]\n\nprint(f\"Predicted class label: {pred_label}\")\nprint(f\"Predicted class name: {pred_class_name}\")\n</pre> # Get the predicted class label pred_label = tf.argmax(pred_probs, axis=-1).numpy()[0]  # Get the predicted class name pred_class_name = class_names[pred_label]  print(f\"Predicted class label: {pred_label}\") print(f\"Predicted class name: {pred_class_name}\") <pre>Predicted class label: 67\nPredicted class name: labrador_retriever\n</pre> <p>Ho ho! That's looking good!</p> <p>In summary, a model wants to make predictions on data in the same shape and format it was trained on.</p> <p>So if you trained a model on image tensors with a certain shape and datatype, your model will want to make predictions on the same kind of image tensors with the same shape and datatype.</p> <p>How about we try make predictions on multiple images?</p> <p>To do so, let's make a function which replicates the workflow from above.</p> In\u00a0[136]: Copied! <pre>def pred_on_custom_image(image_path: str,  # Path to the image file\n                         model,  # Trained TensorFlow model for prediction\n                         target_size: tuple[int, int] = (224, 224),  # Desired size of the image for input to the model\n                         class_names: list = None,  # List of class names (optional for plotting)\n                         plot: bool = True): # Whether to plot the image and predicted class\n  \"\"\"\n  Loads an image, preprocesses it, makes a prediction using a provided model,\n  and optionally plots the image with the predicted class.\n\n  Args:\n      image_path (str): Path to the image file.\n      model: Trained TensorFlow model for prediction.\n      target_size (int, optional): Desired size of the image for input to the model. Defaults to 224.\n      class_names (list, optional): List of class names for plotting. Defaults to None.\n      plot (bool, optional): Whether to plot the image and predicted class. Defaults to True.\n\n  Returns:\n     str: The predicted class.\n  \"\"\"\n\n  # Prepare and load image\n  custom_image = tf.keras.utils.load_img(\n    path=image_path,\n    color_mode=\"rgb\",\n    target_size=target_size,\n  )\n\n  # Turn the image into a tensor\n  custom_image_tensor = tf.keras.utils.img_to_array(custom_image)\n\n  # Add a batch dimension to the target tensor (e.g. (224, 224, 3) -&gt; (1, 224, 224, 3))\n  custom_image_tensor = tf.expand_dims(custom_image_tensor, axis=0)\n\n  # Make a prediction with the target model\n  pred_probs = model.predict(custom_image_tensor)\n\n  # pred_probs = tf.keras.activations.softmax(tf.constant(pred_probs))\n  pred_class = class_names[tf.argmax(pred_probs, axis=-1).numpy()[0]]\n\n  # Plot if we want\n  if not plot:\n    return pred_class, pred_probs\n  else:\n    plt.figure(figsize=(5, 3))\n    plt.imshow(plt.imread(image_path))\n    plt.title(f\"pred: {pred_class}\\nprob: {tf.reduce_max(pred_probs):.3f}\")\n    plt.axis(\"off\")\n</pre> def pred_on_custom_image(image_path: str,  # Path to the image file                          model,  # Trained TensorFlow model for prediction                          target_size: tuple[int, int] = (224, 224),  # Desired size of the image for input to the model                          class_names: list = None,  # List of class names (optional for plotting)                          plot: bool = True): # Whether to plot the image and predicted class   \"\"\"   Loads an image, preprocesses it, makes a prediction using a provided model,   and optionally plots the image with the predicted class.    Args:       image_path (str): Path to the image file.       model: Trained TensorFlow model for prediction.       target_size (int, optional): Desired size of the image for input to the model. Defaults to 224.       class_names (list, optional): List of class names for plotting. Defaults to None.       plot (bool, optional): Whether to plot the image and predicted class. Defaults to True.    Returns:      str: The predicted class.   \"\"\"    # Prepare and load image   custom_image = tf.keras.utils.load_img(     path=image_path,     color_mode=\"rgb\",     target_size=target_size,   )    # Turn the image into a tensor   custom_image_tensor = tf.keras.utils.img_to_array(custom_image)    # Add a batch dimension to the target tensor (e.g. (224, 224, 3) -&gt; (1, 224, 224, 3))   custom_image_tensor = tf.expand_dims(custom_image_tensor, axis=0)    # Make a prediction with the target model   pred_probs = model.predict(custom_image_tensor)    # pred_probs = tf.keras.activations.softmax(tf.constant(pred_probs))   pred_class = class_names[tf.argmax(pred_probs, axis=-1).numpy()[0]]    # Plot if we want   if not plot:     return pred_class, pred_probs   else:     plt.figure(figsize=(5, 3))     plt.imshow(plt.imread(image_path))     plt.title(f\"pred: {pred_class}\\nprob: {tf.reduce_max(pred_probs):.3f}\")     plt.axis(\"off\") <p>What a good looking function!</p> <p>How about we try it out on <code>dog-photo-2.jpeg</code>?</p> In\u00a0[137]: Copied! <pre># Make prediction on custom dog photo 2\npred_on_custom_image(image_path=\"dog-photo-2.jpeg\",\n                     model=loaded_model,\n                     class_names=class_names)\n</pre> # Make prediction on custom dog photo 2 pred_on_custom_image(image_path=\"dog-photo-2.jpeg\",                      model=loaded_model,                      class_names=class_names) <pre>1/1 [==============================] - 0s 27ms/step\n</pre> <p>Woohoo!!! Our model got it right!</p> <p>Let's repeat the process for our other custom images.</p> In\u00a0[138]: Copied! <pre># Predict on multiple images\nfig, axes = plt.subplots(1, 4, figsize=(15, 7))\nfor i, ax in enumerate(axes.flatten()):\n  image_path = custom_image_paths[i]\n  pred_class, pred_probs = pred_on_custom_image(image_path=image_path,\n                                                model=loaded_model,\n                                                class_names=class_names,\n                                                plot=False)\n  ax.imshow(plt.imread(image_path))\n  ax.set_title(f\"pred: {pred_class}\\nprob: {tf.reduce_max(pred_probs):.3f}\")\n  ax.axis(\"off\");\n</pre> # Predict on multiple images fig, axes = plt.subplots(1, 4, figsize=(15, 7)) for i, ax in enumerate(axes.flatten()):   image_path = custom_image_paths[i]   pred_class, pred_probs = pred_on_custom_image(image_path=image_path,                                                 model=loaded_model,                                                 class_names=class_names,                                                 plot=False)   ax.imshow(plt.imread(image_path))   ax.set_title(f\"pred: {pred_class}\\nprob: {tf.reduce_max(pred_probs):.3f}\")   ax.axis(\"off\"); <pre>1/1 [==============================] - 0s 28ms/step\n1/1 [==============================] - 0s 26ms/step\n1/1 [==============================] - 0s 25ms/step\n1/1 [==============================] - 0s 28ms/step\n</pre> <p>Epic!!</p> <p>Our Dog Vision \ud83d\udc36\ud83d\udc41 model has come to life!</p> <p>Looks like our model got it right for 3/4 of our custom dog photos (my dogs Bella and Seven are labrador retrievers, with a potential mix of something else).</p> <p>But the model seemed to also think the photo of me was a <code>soft_coated_wheaten_terrier</code> (note: due to the randomness of machine learning, your result may be different here, if so, please let me know, I'd love to see what other kinds of dogs the model thinks I am :D).</p> <p>You might be wondering, why does it do this?</p> <p>It's because our model has been strictly trained to always predict a dog breed no matter what image it recieves.</p> <p>So no matter what image we pass to our model, it will always predict a certain dog breed.</p> <p>You can try this with your own images.</p> <p>How would you fix this?</p> <p>One way would be to train another model to predict whether the input image is of a dog or is not of a dog.</p> <p>And then only letting our Dog Vision \ud83d\udc36\ud83d\udc41 model predict on the images that are of dogs.</p> <p></p> <p>Example of combining multiple machine learning models to create a workflow. One model for detecting food (Food Not Food) and another model for identifying what food is in the image (FoodVision, similar to Dog Vision). If an app is designed to take photos of food, taking photos of objects that aren't food and having them identified as food can be a poor customer experience. Source: Nutrify.</p> <p>These are some of the workflows you'll have to think about when you eventually deploy your own machine learning models.</p> <p>Machine learning models are often very powerful.</p> <p>But they aren't perfect.</p> <p>Implementing guidelines and checks around them is still a very active area of research.</p> In\u00a0[139]: Copied! <pre>from tensorflow.keras import layers\n\n# Note: Could functionize all of this\n\n# Setup hyperparameters\nimg_size = 224\nnum_classes = 120\n\n# Create data augmentation layer\ndata_augmentation_layer = tf.keras.Sequential(\n    [\n        layers.RandomFlip(\"horizontal\"), # randomly flip image across horizontal axis\n        layers.RandomRotation(factor=0.2), # randomly rotate image\n        layers.RandomZoom(height_factor=0.2, width_factor=0.2) # randomly zoom into image\n        # More augmentation can go here\n    ],\n    name=\"data_augmentation\"\n)\n\n# Setup base model\nbase_model = tf.keras.applications.efficientnet_v2.EfficientNetV2B0(\n    include_top=False,\n    weights='imagenet',\n    input_shape=(img_size, img_size, 3),\n    include_preprocessing=True\n)\n\n# Freeze the base model\nbase_model.trainable = False\n\n# Create new model\ninputs = tf.keras.Input(shape=(224, 224, 3))\n\n# Create data augmentation\nx = data_augmentation_layer(inputs)\n\n# Craft model\nx = base_model(x, training=False)\nx = tf.keras.layers.GlobalAveragePooling2D()(x)\nx = tf.keras.layers.Dropout(0.2)(x)\noutputs = tf.keras.layers.Dense(num_classes,\n                                name=\"output_layer\",\n                                activation=\"softmax\")(x) # Note: If you have \"softmax\" activation, use from_logits=False in loss function\nmodel_2 = tf.keras.Model(inputs, outputs, name=\"model_2\")\n\n# Uncomment for full model summary with augmentation layers\n# model_2.summary()\n</pre> from tensorflow.keras import layers  # Note: Could functionize all of this  # Setup hyperparameters img_size = 224 num_classes = 120  # Create data augmentation layer data_augmentation_layer = tf.keras.Sequential(     [         layers.RandomFlip(\"horizontal\"), # randomly flip image across horizontal axis         layers.RandomRotation(factor=0.2), # randomly rotate image         layers.RandomZoom(height_factor=0.2, width_factor=0.2) # randomly zoom into image         # More augmentation can go here     ],     name=\"data_augmentation\" )  # Setup base model base_model = tf.keras.applications.efficientnet_v2.EfficientNetV2B0(     include_top=False,     weights='imagenet',     input_shape=(img_size, img_size, 3),     include_preprocessing=True )  # Freeze the base model base_model.trainable = False  # Create new model inputs = tf.keras.Input(shape=(224, 224, 3))  # Create data augmentation x = data_augmentation_layer(inputs)  # Craft model x = base_model(x, training=False) x = tf.keras.layers.GlobalAveragePooling2D()(x) x = tf.keras.layers.Dropout(0.2)(x) outputs = tf.keras.layers.Dense(num_classes,                                 name=\"output_layer\",                                 activation=\"softmax\")(x) # Note: If you have \"softmax\" activation, use from_logits=False in loss function model_2 = tf.keras.Model(inputs, outputs, name=\"model_2\")  # Uncomment for full model summary with augmentation layers # model_2.summary() In\u00a0[140]: Copied! <pre>!pip install -q gradio\nimport gradio as gr\n</pre> !pip install -q gradio import gradio as gr <pre>     \u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501 12.2/12.2 MB 34.0 MB/s eta 0:00:00\n     \u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501 91.9/91.9 kB 12.9 MB/s eta 0:00:00\n  Preparing metadata (setup.py) ... done\n     \u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501 314.4/314.4 kB 33.7 MB/s eta 0:00:00\n     \u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501 75.6/75.6 kB 10.1 MB/s eta 0:00:00\n     \u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501 141.1/141.1 kB 18.2 MB/s eta 0:00:00\n     \u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501 8.8/8.8 MB 91.6 MB/s eta 0:00:00\n     \u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501 47.2/47.2 kB 4.3 MB/s eta 0:00:00\n     \u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501 60.8/60.8 kB 8.8 MB/s eta 0:00:00\n     \u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501 129.9/129.9 kB 16.6 MB/s eta 0:00:00\n     \u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501 77.9/77.9 kB 9.8 MB/s eta 0:00:00\n     \u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501 58.3/58.3 kB 8.3 MB/s eta 0:00:00\n     \u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501 71.9/71.9 kB 9.7 MB/s eta 0:00:00\n  Building wheel for ffmpy (setup.py) ... done\nERROR: pip's dependency resolver does not currently take into account all the packages that are installed. This behaviour is the source of the following dependency conflicts.\nspacy 3.7.4 requires typer&lt;0.10.0,&gt;=0.3.0, but you have typer 0.12.3 which is incompatible.\nweasel 0.3.4 requires typer&lt;0.10.0,&gt;=0.3.0, but you have typer 0.12.3 which is incompatible.\n</pre> <p>Then we'll download the saved model (the same model we trained during the Dog Vision notebook) along with the assosciated labels.</p> <p>I've stored my saved model as well as the Stanford Dogs class names on Hugging Face.</p> <p>You can see my files at <code>huggingface.co/spaces/mrdbourke/dog_vision</code>.</p> In\u00a0[141]: Copied! <pre>import tensorflow as tf\n\n# Download saved model and labels from Hugging Face\n!wget -q https://huggingface.co/spaces/mrdbourke/dog_vision/resolve/main/dog_vision_model_demo.keras\n!wget -q https://huggingface.co/spaces/mrdbourke/dog_vision/resolve/main/stanford_dogs_class_names.txt\n\n# Load model\nmodel_save_path = \"dog_vision_model_demo.keras\"\nloaded_model_for_demo = tf.keras.models.load_model(model_save_path)\n\n# Load labels\nwith open(\"stanford_dogs_class_names.txt\", \"r\") as f:\n  class_names = [line.strip() for line in f.readlines()]\n</pre> import tensorflow as tf  # Download saved model and labels from Hugging Face !wget -q https://huggingface.co/spaces/mrdbourke/dog_vision/resolve/main/dog_vision_model_demo.keras !wget -q https://huggingface.co/spaces/mrdbourke/dog_vision/resolve/main/stanford_dogs_class_names.txt  # Load model model_save_path = \"dog_vision_model_demo.keras\" loaded_model_for_demo = tf.keras.models.load_model(model_save_path)  # Load labels with open(\"stanford_dogs_class_names.txt\", \"r\") as f:   class_names = [line.strip() for line in f.readlines()] <p>The prediction function should take in an image and return a dictionary of classes and their prediction probabilities.</p> In\u00a0[142]: Copied! <pre># Create prediction function\ndef pred_on_custom_image(image, # input image (preprocessed by Gradio's Image input to be numpy.array)\n                         model: tf.keras.Model = loaded_model_for_demo,  # Trained TensorFlow model for prediction\n                         target_size: int = 224,  # Desired size of the image for input to the model\n                         class_names: list = class_names): # List of class names\n  \"\"\"\n  Loads an image, preprocesses it, makes a prediction using a provided model,\n  and returns a dictionary of prediction probabilities per class name.\n\n  Args:\n      image: Input image.\n      model: Trained TensorFlow model for prediction.\n      target_size (int, optional): Desired size of the image for input to the model. Defaults to 224.\n      class_names (list, optional): List of class names for plotting. Defaults to None.\n\n  Returns:\n     Dict[str: float]: A dictionary of string class names and their respective prediction probability.\n  \"\"\"\n\n  # Note: gradio.inputs.Image handles opening the image\n  # # Prepare and load image\n  # custom_image = tf.keras.utils.load_img(\n  #   path=image_path,\n  #   color_mode=\"rgb\",\n  #   target_size=target_size,\n  # )\n\n  # Create resizing layer to resize the image\n  resize = tf.keras.layers.Resizing(height=target_size,\n                                    width=target_size)\n\n  # Turn the image into a tensor and resize it\n  custom_image_tensor = resize(tf.keras.utils.img_to_array(image))\n\n  # Add a batch dimension to the target tensor (e.g. (224, 224, 3) -&gt; (1, 224, 224, 3))\n  custom_image_tensor = tf.expand_dims(custom_image_tensor, axis=0)\n\n  # Make a prediction with the target model\n  pred_probs = model.predict(custom_image_tensor)[0]\n\n  # Predictions get returned as a dictionary of {label: pred_prob}\n  pred_probs_dict = {class_names[i]: float(pred_probs[i]) for i in range(len(class_names))}\n\n  return pred_probs_dict\n\ninterface_title = \"Dog Vision \ud83d\udc36\ud83d\udc41\ufe0f\"\ninterface_description = \"Identify different dogs in images with deep learning. Model trained with TensorFlow/Keras.\"\ninterface = gr.Interface(fn=pred_on_custom_image,\n                         inputs=gr.Image(),\n                         outputs=gr.Label(num_top_classes=3),\n                         examples=[\"dog-photo-1.jpeg\",\n                                    \"dog-photo-2.jpeg\",\n                                    \"dog-photo-3.jpeg\",\n                                    \"dog-photo-4.jpeg\"],\n                         title=interface_title,\n                         description=interface_description)\n\n# Uncomment to launch the interface directly in a notebook\n# interface.launch(debug=True)\n</pre> # Create prediction function def pred_on_custom_image(image, # input image (preprocessed by Gradio's Image input to be numpy.array)                          model: tf.keras.Model = loaded_model_for_demo,  # Trained TensorFlow model for prediction                          target_size: int = 224,  # Desired size of the image for input to the model                          class_names: list = class_names): # List of class names   \"\"\"   Loads an image, preprocesses it, makes a prediction using a provided model,   and returns a dictionary of prediction probabilities per class name.    Args:       image: Input image.       model: Trained TensorFlow model for prediction.       target_size (int, optional): Desired size of the image for input to the model. Defaults to 224.       class_names (list, optional): List of class names for plotting. Defaults to None.    Returns:      Dict[str: float]: A dictionary of string class names and their respective prediction probability.   \"\"\"    # Note: gradio.inputs.Image handles opening the image   # # Prepare and load image   # custom_image = tf.keras.utils.load_img(   #   path=image_path,   #   color_mode=\"rgb\",   #   target_size=target_size,   # )    # Create resizing layer to resize the image   resize = tf.keras.layers.Resizing(height=target_size,                                     width=target_size)    # Turn the image into a tensor and resize it   custom_image_tensor = resize(tf.keras.utils.img_to_array(image))    # Add a batch dimension to the target tensor (e.g. (224, 224, 3) -&gt; (1, 224, 224, 3))   custom_image_tensor = tf.expand_dims(custom_image_tensor, axis=0)    # Make a prediction with the target model   pred_probs = model.predict(custom_image_tensor)[0]    # Predictions get returned as a dictionary of {label: pred_prob}   pred_probs_dict = {class_names[i]: float(pred_probs[i]) for i in range(len(class_names))}    return pred_probs_dict  interface_title = \"Dog Vision \ud83d\udc36\ud83d\udc41\ufe0f\" interface_description = \"Identify different dogs in images with deep learning. Model trained with TensorFlow/Keras.\" interface = gr.Interface(fn=pred_on_custom_image,                          inputs=gr.Image(),                          outputs=gr.Label(num_top_classes=3),                          examples=[\"dog-photo-1.jpeg\",                                     \"dog-photo-2.jpeg\",                                     \"dog-photo-3.jpeg\",                                     \"dog-photo-4.jpeg\"],                          title=interface_title,                          description=interface_description)  # Uncomment to launch the interface directly in a notebook # interface.launch(debug=True) <p>Save the following code to an <code>app.py</code> file for running on Hugging Face spaces.</p> <p>Finally, you can see the running demo on Hugging Face.</p> <p>Try it out with your own images of dogs and see Dog Vision \ud83d\udc36\ud83d\udc41\ufe0f come to life!</p> In\u00a0[143]: Copied! <pre>from IPython.display import HTML\n\n# Embed the Hugging Face Space as an iframe\nhtml_string = \"\"\"\n&lt;iframe src=\"https://mrdbourke-dog-vision.hf.space\" frameborder=\"0\" width=\"850\" height=\"850\"&gt;&lt;/iframe&gt;\n\"\"\"\n\ndisplay(HTML(html_string))\n</pre> from IPython.display import HTML  # Embed the Hugging Face Space as an iframe html_string = \"\"\"  \"\"\"  display(HTML(html_string)) <p>The following will write the whole cell to a Python file called <code>app.py</code>, this can uploaded to Hugging Face and run as a Space. As long as all available files (e.g. model file and class names file) are available.</p> In\u00a0[144]: Copied! <pre># %%writefile app.py\n# import gradio as gr\n# import tensorflow as tf\n\n# # Load model\n# model_save_path = \"dog_vision_model_demo.keras\"\n# loaded_model_for_demo = tf.keras.models.load_model(model_save_path)\n\n# # Load labels\n# with open(\"stanford_dogs_class_names.txt\", \"r\") as f:\n#   class_names = [line.strip() for line in f.readlines()]\n\n# # Create prediction function\n# def pred_on_custom_image(image, # input image (preprocessed by Gradio's Image input to be numpy.array)\n#                          model: tf.keras.Model =loaded_model_for_demo,  # Trained TensorFlow model for prediction\n#                          target_size: int = 224,  # Desired size of the image for input to the model\n#                          class_names: list = class_names): # List of class names\n#   \"\"\"\n#   Loads an image, preprocesses it, makes a prediction using a provided model,\n#   and returns a dictionary of prediction probabilities per class name.\n\n#   Args:\n#       image: Input image.\n#       model: Trained TensorFlow model for prediction.\n#       target_size (int, optional): Desired size of the image for input to the model. Defaults to 224.\n#       class_names (list, optional): List of class names for plotting. Defaults to None.\n\n#   Returns:\n#      Dict[str: float]: A dictionary of string class names and their respective prediction probability.\n#   \"\"\"\n\n#   # Note: gradio.inputs.Image handles opening the image\n#   # # Prepare and load image\n#   # custom_image = tf.keras.utils.load_img(\n#   #   path=image_path,\n#   #   color_mode=\"rgb\",\n#   #   target_size=target_size,\n#   # )\n\n#   # Create resizing layer to resize the image\n#   resize = tf.keras.layers.Resizing(height=target_size,\n#                                     width=target_size)\n\n#   # Turn the image into a tensor and resize it\n#   custom_image_tensor = resize(tf.keras.utils.img_to_array(image))\n\n#   # Add a batch dimension to the target tensor (e.g. (224, 224, 3) -&gt; (1, 224, 224, 3))\n#   custom_image_tensor = tf.expand_dims(custom_image_tensor, axis=0)\n\n#   # Make a prediction with the target model\n#   pred_probs = model.predict(custom_image_tensor)[0]\n\n#   # Predictions get returned as a dictionary of {label: pred_prob}\n#   pred_probs_dict = {class_names[i]: float(pred_probs[i]) for i in range(len(class_names))}\n\n#   return pred_probs_dict\n\n# # Create Gradio interface\n# interface_title = \"Dog Vision \ud83d\udc36\ud83d\udc41\ufe0f\"\n# interface_description = \"Identify different dogs in images with deep learning. Model trained with TensorFlow/Keras.\"\n# interface = gr.Interface(fn=pred_on_custom_image,\n#                          inputs=gr.Image(),\n#                          outputs=gr.Label(num_top_classes=3),\n#                          examples=[\"dog-photo-1.jpeg\",\n#                                     \"dog-photo-2.jpeg\",\n#                                     \"dog-photo-3.jpeg\",\n#                                     \"dog-photo-4.jpeg\"],\n#                          title=interface_title,\n#                          description=interface_description)\n# interface.launch(debug=True)\n</pre> # %%writefile app.py # import gradio as gr # import tensorflow as tf  # # Load model # model_save_path = \"dog_vision_model_demo.keras\" # loaded_model_for_demo = tf.keras.models.load_model(model_save_path)  # # Load labels # with open(\"stanford_dogs_class_names.txt\", \"r\") as f: #   class_names = [line.strip() for line in f.readlines()]  # # Create prediction function # def pred_on_custom_image(image, # input image (preprocessed by Gradio's Image input to be numpy.array) #                          model: tf.keras.Model =loaded_model_for_demo,  # Trained TensorFlow model for prediction #                          target_size: int = 224,  # Desired size of the image for input to the model #                          class_names: list = class_names): # List of class names #   \"\"\" #   Loads an image, preprocesses it, makes a prediction using a provided model, #   and returns a dictionary of prediction probabilities per class name.  #   Args: #       image: Input image. #       model: Trained TensorFlow model for prediction. #       target_size (int, optional): Desired size of the image for input to the model. Defaults to 224. #       class_names (list, optional): List of class names for plotting. Defaults to None.  #   Returns: #      Dict[str: float]: A dictionary of string class names and their respective prediction probability. #   \"\"\"  #   # Note: gradio.inputs.Image handles opening the image #   # # Prepare and load image #   # custom_image = tf.keras.utils.load_img( #   #   path=image_path, #   #   color_mode=\"rgb\", #   #   target_size=target_size, #   # )  #   # Create resizing layer to resize the image #   resize = tf.keras.layers.Resizing(height=target_size, #                                     width=target_size)  #   # Turn the image into a tensor and resize it #   custom_image_tensor = resize(tf.keras.utils.img_to_array(image))  #   # Add a batch dimension to the target tensor (e.g. (224, 224, 3) -&gt; (1, 224, 224, 3)) #   custom_image_tensor = tf.expand_dims(custom_image_tensor, axis=0)  #   # Make a prediction with the target model #   pred_probs = model.predict(custom_image_tensor)[0]  #   # Predictions get returned as a dictionary of {label: pred_prob} #   pred_probs_dict = {class_names[i]: float(pred_probs[i]) for i in range(len(class_names))}  #   return pred_probs_dict  # # Create Gradio interface # interface_title = \"Dog Vision \ud83d\udc36\ud83d\udc41\ufe0f\" # interface_description = \"Identify different dogs in images with deep learning. Model trained with TensorFlow/Keras.\" # interface = gr.Interface(fn=pred_on_custom_image, #                          inputs=gr.Image(), #                          outputs=gr.Label(num_top_classes=3), #                          examples=[\"dog-photo-1.jpeg\", #                                     \"dog-photo-2.jpeg\", #                                     \"dog-photo-3.jpeg\", #                                     \"dog-photo-4.jpeg\"], #                          title=interface_title, #                          description=interface_description) # interface.launch(debug=True)"},{"location":"end-to-end-dog-vision-v2/#introduction-to-tensorflow-deep-learning-and-transfer-learning-work-in-progress","title":"Introduction to TensorFlow, Deep Learning and Transfer Learning (work in progress)\u00b6","text":"<ul> <li>Project: Dog Vision \ud83d\udc36\ud83d\udc41 - Using computer vision to classify dog photos into different breeds.</li> <li>Goals: Learn TensorFlow, deep learning and transfer learning, beat the original research paper results (22% accuracy).</li> <li>Domain: Computer vision.</li> <li>Data: Images of dogs from Stanford Dogs Dataset (120 dog breeds, 20,000+ images).</li> <li>Problem type: Multi-class classification (120 different classes).</li> <li>Runtime: This project is designed to run end-to-end in Google Colab (for free GPU access and easy setup). If you'd like to run it locally, it will require environment setup.</li> <li>Demo: See a demo of the trained model running on Hugging Face Spaces.</li> </ul> <p>Welcome, welcome!</p> <p>The focus of this notebook is to give a quick overview of deep learning with TensorFlow/Keras.</p> <p>How?</p> <p>We're going to go through the machine learning workflow steps and build a computer vision project to classify photos of dogs into their respective dog breed (a Predictive AI task, see below for more).</p> <p></p> <p>What we're going to build: Dog Vision \ud83d\udc36\ud83d\udc41\ufe0f, a neural network capable of identifying different dog breeds in images. All the way from dataset preparation to model building, training and evaluation.</p>"},{"location":"end-to-end-dog-vision-v2/#what-were-going-to-cover","title":"What we're going to cover\u00b6","text":"<p>In this project, we're going to be introduced to the power of deep learning and more specifically, transfer learning using TensorFlow/Keras.</p> <p>We'll go through each of these in the context of the 6 step machine learning framework:</p> <ol> <li>Problem defintion - Use computer vision to classify photos of dogs into different dog breeds.</li> <li>Data - 20,000+ images of dogs from 120 different dog breeds from the Stanford Dogs dataset.</li> <li>Evaluation - We'd like to beat the original paper's results (22% mean accuracy across all classes, tip: A good way to practice your skills is to find some results online and try to beat them).</li> <li>Features - Because we're using deep learning, our model will learn the features on its own.</li> <li>Modelling - We're going to use a pretrained convolutional neural network (CNN) and transfer learning.</li> <li>Experiments - We'll try different amounts of data with the same model to see the effects on our results.</li> </ol> <p>Note: It's okay not to know these exact steps ahead of time. When starting a new project, it's often the case you'll figure it out as you go. These steps are only filled out because I've had practice working on several machine learning projects. You'll pick up these ideas overtime.</p>"},{"location":"end-to-end-dog-vision-v2/#table-of-contents","title":"Table of contents\u00b6","text":"<ol> <li>Getting Setup</li> <li>Getting Data (dog images and their breeds)</li> <li>Exploring the data (exploratory data analysis)</li> <li>Creating training and test splits</li> <li>Turning our datasets into TensorFlow Dataset(s)</li> <li>Creating a neural network with TensorFlow</li> <li>Model 0 - Train a model on 10% of the training data</li> <li>Putting it all together: create, compile, fit</li> <li>Model 1 - Train a model on 100% of the training data</li> <li>Make and evaluate predictions of the best model</li> <li>Save and load the best model</li> <li>Make predictions on custom images with the best model (bringing Dog Vision \ud83d\udc36\ud83d\udc41\ufe0f to life!)</li> <li>Key takeaways</li> <li>Extensions &amp; exercises</li> </ol>"},{"location":"end-to-end-dog-vision-v2/#where-can-can-you-get-help","title":"Where can can you get help?\u00b6","text":"<p>All of the materials for this course are available on GitHub.</p> <p>If you run into trouble, you can ask a question on the course GitHub Discussions page there too.</p> <p>You can also:</p> <ul> <li>Search for questions online and end up at places such as Stack Overflow (a great resource of developer-focused Q&amp;A).</li> <li>Ask AI Assistants such as ChatGPT, Gemini and Claude for help with various coding problems and errors.</li> </ul>"},{"location":"end-to-end-dog-vision-v2/#quick-definitions","title":"Quick definitions\u00b6","text":"<p>Let's start by breaking down some of the most important topics we're going to go through.</p>"},{"location":"end-to-end-dog-vision-v2/#what-is-tensorflowkeras","title":"What is TensorFlow/Keras?\u00b6","text":"<p>TensorFlow is an open source machine learning and deep learning framework originally developed by Google. Inside TensorFlow, you can also use Keras which is another very helpful machine learning framework known for its ease of use.</p>"},{"location":"end-to-end-dog-vision-v2/#why-use-tensorflow","title":"Why use TensorFlow?\u00b6","text":"<p>TensorFlow allows you to manipulate data and write deep learning algorithms using Python code.</p> <p>It also has several built-in capabilities to leverage accelerated computing hardware (e.g. GPUs, Graphics Processing Units and TPUs, Tensor Processing Units).</p> <p>Many of world's largest companies power their machine learning workloads with TensorFlow.</p>"},{"location":"end-to-end-dog-vision-v2/#what-is-deep-learning","title":"What is deep learning?\u00b6","text":"<p>Deep learning is a form of machine learning where data passes through a series of progressive layers which all contribute to learning an overall representation of that data.</p> <p>Each layer performs a pre-defined operation.</p> <p>The series of progressive layers combine to form what's referred to as a neural network.</p> <p>For example, a photo may be turned into numbers (e.g. red, green and blue pixel values) and those numbers are then manipulated mathematically through each progressive layer to learn patterns in the photo.</p> <p>The \"deep\" in deep learning comes from the number of layers used in the neural network.</p> <p>So when someone says deep learning or (artificial neural networks), they're typically referring to same thing.</p> <p>Note: Artificial intelligence (AI), machine learning (ML) and deep learning are all broad terms. You can think of AI as the overall technology, machine learning as a type of AI, and deep learning as a type of machine learning. So if someone refers to AI, you can often assume they are often talking about machine learning or deep learning.</p>"},{"location":"end-to-end-dog-vision-v2/#what-can-deep-learning-be-used-for","title":"What can deep learning be used for?\u00b6","text":"<p>Deep learning is such a powerful technique that new use cases are being discovered everyday.</p> <p>Most of the modern forms of artifical intelligence (AI) applications you see, are powered by deep learning.</p> <p>Two of the most useful types of AI are predictive and generative.</p> <p>Predictive AI learns the relationship between data and labels such as photos of dog and their breeds (supervised learning). So that when it sees a new photo of a dog, it can predict its breed based on what its learned.</p> <p>Generative AI generates something new given an input such as creating new text given input text.</p> <p>Some examples of Predictive AI problems include:</p> <ul> <li>Tesla's self-driving cars use deep learning use object detection models to power their computer vision systems.</li> <li>Apple's Photos app uses deep learning to recognize faces in images and create Photo Memories.</li> <li>Siri and Google Assistant use deep learning to transcribe speech and understand voice commands.</li> <li>Nutrify (an app my brother and I build) uses predictive AI to recognize food in images.</li> <li>Magika uses deep learning to classify a file into what type it is (e.g. <code>.jpeg</code>, <code>.py</code>, <code>.txt</code>).</li> <li>Text classification models such as DeBERTa use deep learning to classify text into different categories such as \"positive\" and \"negative\" or \"spam\" or \"not spam\".</li> </ul> <p>Some examples of Generative AI problems include:</p> <ul> <li>Stable Diffusion uses generative AI to generate images given a text prompt.</li> <li>ChatGPT and other large language models (LLMs) such as Llama, Claude, Gemini and Mistral use deep learning to process text and return a response.</li> <li>GitHub Copilot uses generative AI to generate code snippets given surrounding context.</li> </ul> <p>All of these AI use cases are powered by deep learning.</p> <p>And more often than not, whenever you get started on a deep learning problem, you'll start with transfer learning.</p> <p></p> <p>Example of different every day problems where AI/machine learning gets used.</p>"},{"location":"end-to-end-dog-vision-v2/#what-is-transfer-learning","title":"What is transfer learning?\u00b6","text":"<p>Transfer learning is one of the most powerful and useful techniques in modern AI and machine learning.</p> <p>It involves taking what one model (or neural network) has learned in a similar domain and applying to your own.</p> <p>In our case, we're going to use transfer learning to take the patterns a neural network has learned from the 1 million+ images and over 1000 classes in ImageNet (a gold standard computer vision benchmark) and apply them to our own problem of recognizing dog breeds.</p> <p>However, this concept can be applied to many different domains.</p> <p>You could take a large language model (LLM) that has been pre-trained on most of the text on the internet and learned very well the patterns in naturual language and customize it for your own specific chat use-case.</p> <p>The biggest benefit of transfer learning is that it often allows you to get outstanding results with less data and time.</p> <p></p> <p>A transfer learning workflow. Many publicly available models have been pretrained on large datasets such as ImageNet (1 million+ images). These models can then be applied to similar tasks downstream. For example, we can take a model pretrained on ImageNet and apply it to our Dog Vision \ud83d\udc36\ud83d\udc41\ufe0f problem. This same process can be repeated for many different styles of data and problem.</p>"},{"location":"end-to-end-dog-vision-v2/#1-getting-setup","title":"1. Getting setup\u00b6","text":"<p>This notebook is designed to run in Google Colab, an online Jupyter Notebook that provides free access to GPUs (Graphics Processing Units, we'll hear more on these later).</p> <p>For a quick rundown on how to use Google Colab, see their introductory guide (it's quite similar to a Jupyter Notebook with a few different options).</p> <p>Google Colab also comes with many data science and machine learning libraries pre-installed, including TensorFlow/Keras.</p>"},{"location":"end-to-end-dog-vision-v2/#getting-a-gpu-on-google-colab","title":"Getting a GPU on Google Colab\u00b6","text":"<p>Before running any code, we'll make sure our Google Colab instance is connected to a GPU.</p> <p>You can do this via going to Runtime -&gt; Change runtime type -&gt; GPU (this may restart your existing runtime).</p> <p>Why use a GPU?</p> <p>Since neural networks perform a large amount of calculations behind the scenes (the main one being matrix multiplication), you need a computer chip that perform these calculations quickly, otherwise you'll be waiting all day for a model to train.</p> <p>And in short, GPUs are much faster at performing matrix multiplications than CPUs.</p> <p>Why this is the case is behind the scope of this project (you can search \"why are GPUs faster than CPUs for machine learning?\" for more).</p> <p>The main thing to remember is: generally, in deep learning, GPUs = faster than CPUs.</p> <p>Note: A good experiment would be to run the neural networks we're going to build later on with and without a GPU and see the difference in their training times.</p> <p>Ok, enough talking, let's start by importing TensorFlow!</p> <p>We'll do so using the common abbreviation <code>tf</code>.</p>"},{"location":"end-to-end-dog-vision-v2/#2-getting-data","title":"2. Getting Data\u00b6","text":"<p>All machine learning (and deep learning) projects start with data.</p> <p>If you have no data, you have no project.</p> <p>If you have no project, you have no cool models to show your friends or improve your business.</p> <p>Not to worry!</p> <p>There are several options and locations to get data for a deep learning project.</p> Resource Description Kaggle Datasets A collection of datasets across a wide range of topics. TensorFlow Datasets A collection of ready-to-use machine learning datasets ready for use under the <code>tf.data.Datasets</code> API. You can see a list of all available datasets in the TensorFlow documentation. Hugging Face Datasets A continually growing resource of datasets broken into several different kinds of topics. Google Dataset Search A search engine by Google specifically focused on searching online datasets. Original sources Datasets which are made available by researchers or companies with the release of a product or research paper (sources for these will vary, they could be a link on a website or a link to an application form). Custom datasets These are datasets comprised of your own custom source of data. You may build these from scratch on your own or have access to them from an existing product or service. For example, your entire photos library could be your own custom dataset or your entire notes and documents folder or your company's customer order history. <p>In our case, the dataset we're going to use is called the Stanford Dogs dataset (or ImageNet dogs, as the images are dogs separated from ImageNet).</p> <p>Because the Stanford Dogs dataset has been around for a while (since 2011, which as of writing this in 2024 is like a lifetime in deep learning), it's available from several resources:</p> <ul> <li>The original project website via link download.</li> <li>Inside TensorFlow datasets under <code>stanford_dogs</code>.</li> <li>On Kaggle as a downloadable dataset.</li> </ul> <p>The point here is that when you're starting out with practicing deep learning projects, there's no shortage of datasets available.</p> <p>However, when you start wanting to work on your own projects or within a company environment, you'll likely start to work on custom datasets (datasets you build yourself or aren't available publicly online).</p> <p>The main difference between existing datasets and custom datasets is that existing datasets often come preformatted and ready to use.</p> <p>Where as custom datasets often require some preprocessing before they're ready to use within a machine learning project.</p> <p>To practice formatting a dataset for a machine learning problem, we're going to download the Stanford Dogs dataset from the original website.</p> <p>Before we do so, the following code is an example of how we'd get the Stanford Dogs dataset from TensorFlow Datasets.</p>"},{"location":"end-to-end-dog-vision-v2/#download-data-directly-from-stanford-dogs-website","title":"Download data directly from Stanford Dogs website\u00b6","text":"<p>Our overall project goal is to build a computer vision model which performs better than the original Stanford Dogs paper (average of 22% accuracy per class across 120 classes).</p> <p>To do so, we need some data.</p> <p>Let's download the original Stanford Dogs dataset from the project website.</p> <p>The data comes in three main files:</p> <ol> <li>Images (757MB) - <code>images.tar</code></li> <li>Annotations (21MB) - <code>annotation.tar</code></li> <li>Lists with train/test splits (0.5MB) - <code>lists.tar</code></li> </ol> <p>Our goal is to get a file structure like this:</p> <p></p> <p>Note: If you're using Google Colab for this project, remember that any data uploaded to the Google Colab session gets deleted if the session disconnects. So to save us redownloading the data every time, we're going to download it once and save it to Google Drive.</p> <p>Resource: For a good guide on getting data in and out of Google Colab, see the Google Colab <code>io.ipynb</code> tutorial.</p> <p>To make sure we don't have to keep redownloading the data every time we leave and come back to Google Colab, we're going to:</p> <ol> <li>Download the data if it doesn't already exist on Google Drive.</li> <li>Copy it to Google Drive (because Google Colab connects nicely with Google Drive) if it isn't already there.</li> <li>If the data already exists on Google Drive (we've been through steps 1 &amp; 2), we'll import it instead.</li> </ol> <p>There are two main options to connect Google Colab instances to Google Drive:</p> <ol> <li>Click \"Mount Drive\" in \"Files\" menu on the left.</li> <li>Mount programmatically with <code>from google.colab import drive</code> -&gt; <code>drive.mount('/content/drive')</code>.</li> </ol> <p>More specifically, we're going to follow the following steps:</p> <ol> <li>Mount Google Drive.</li> <li>Setup constants such as our base directory to save files to, the target files we'd like to download and target URL we'd like to download from.</li> <li>Setup our target local path to save to.</li> <li>Check if the target files all exist in Google Drive and if they do, copy them locally.</li> <li>If the target files don't exist in Google Drive, download them from the target URL with the <code>!wget</code> command.</li> <li>Create a file on Google Drive to store the download files.</li> <li>Copy the downloaded files to Google Drive for use later if needed.</li> </ol> <p>A fair few steps, but nothing we can't handle!</p> <p>Plus, this is all good practice for dealing with and manipulating data, a very important skill in the machine learning engineers toolbox.</p> <p>Note: The following data download section is designed to run in Google Colab. If you are running locally, feel free to modify the code to save to a local directory instead of Google Drive.</p>"},{"location":"end-to-end-dog-vision-v2/#3-exploring-the-data","title":"3. Exploring the data\u00b6","text":"<p>Once you've got a dataset, before building a model, it's wise to explore it for a bit to see what kind of data you're working with.</p> <p>Exploring a dataset can mean many things.</p> <p>But a few rules of thumb when exploring new data:</p> <ul> <li>View at least 100+ random samples for a \"vibe check\". For example, if you have a large dataset of images, randomly sample 10 images at a time and view them. Or if you have a large dataset of texts, what do some of them say? The same with audio. It will often be impossible to view all samples in your dataset, but you can start to get a good idea of what's inside by randomly inspecting samples.</li> <li>Visualize, viuslaize, visualize! This is the data explorer's motto. Use it often. As in, it's good to get statistics about your dataset but it's often even better to view 100s of samples with your own eyes (see the point above).</li> <li>Check the distributions and other various statistics. How many samples are there? If you're dealing with classification, how many classes and labels per class are there? Which classes don't you understand? If you don't have labels, investigate clustering methods to put similar samples close together.</li> </ul> <p>As Abraham Lossfunction says...</p> <p></p> <p>A play on words of Abraham Lincoln's famous quote on sharpening an axe before cutting down a tree in theme of machine learning. Source: Daniel Bourke X/Twitter.</p>"},{"location":"end-to-end-dog-vision-v2/#our-target-data-format","title":"Our target data format\u00b6","text":"<p>Since our goal is to build a computer vision model to classify dog breeds, we need a way to tell our model what breed of dog is in what image.</p> <p>A common data format for a classification problem is to have samples stored in folders named after their class name.</p> <p>For example:</p> <p></p> <p>In the case of dog images, we'd put all of the images labelled \"chihuahua\" in a folder called <code>chihuahua/</code> (and so on for all the other classes and images).</p> <p>We could split these folders so that training images go in <code>train/chihuahua/</code> and testing images go in <code>test/chihuahua/</code>.</p> <p>This is what we'll be working towards creating.</p> <p>Note: This structure of folder format doesn't just work for only images, it can work for text, audio and other kind of classification data too.</p>"},{"location":"end-to-end-dog-vision-v2/#exploring-the-file-lists","title":"Exploring the file lists\u00b6","text":"<p>How about we check out the <code>train_list.mat</code>, <code>test_list.mat</code> and <code>full_list.mat</code> files?</p> <p>Searching online, for \"what is a .mat file?\", I found that it's a MATLAB file. Before Python became the default language for machine learning and deep learning, many models and datasets were built in MATLAB.</p> <p>Then I searched, \"how to open a .mat file with Python?\" and found an answer on Stack Overflow saying I could use the <code>scipy</code> library (a scientific computing library).</p> <p>The good news is, Google Colab comes with <code>scipy</code> preinstalled.</p> <p>We can use the <code>scipy.io.loadmat()</code> method to open a <code>.mat</code> file.</p>"},{"location":"end-to-end-dog-vision-v2/#exploring-the-annotation-folder","title":"Exploring the Annotation folder\u00b6","text":"<p>How about we look at the <code>Annotation</code> folder next?</p> <p>We can click the folder on the file explorer on the left to see what's inside.</p> <p>But we can also explore the contents of the folder with Python.</p> <p>Let's use <code>os.listdir()</code> to see what's inside.</p>"},{"location":"end-to-end-dog-vision-v2/#exploring-the-images-folder","title":"Exploring the Images folder\u00b6","text":"<p>We've explored the <code>Annotations</code> folder, now let's check out our <code>Images</code> folder.</p> <p>We know that the image file names come in the format <code>class_name/image_name</code>, for example, <code>n02085620-Chihuahua/n02085620_5927.jpg</code>.</p> <p>To make things a little simpler, let's create the following:</p> <ol> <li>A mapping from folder name -&gt; class name in dictionary form, for example, <code>{'n02113712-miniature_poodle': 'miniature_poodle',  'n02092339-Weimaraner': 'weimaraner',  'n02093991-Irish_terrier': 'irish_terrier'...}</code>. This will help us when visualizing our data from its original folder.</li> <li>A list of all unique dog class names with simple formatting, for example, <code>['affenpinscher',  'afghan_hound',  'african_hunting_dog',  'airedale',  'american_staffordshire_terrier'...]</code>.</li> </ol> <p>Let's start by getting a list of all the folders in the <code>Images</code> directory with <code>os.listdir()</code>.</p>"},{"location":"end-to-end-dog-vision-v2/#visualize-a-group-of-random-images","title":"Visualize a group of random images\u00b6","text":"<p>How about we follow the data explorers motto of visualize, visualize, visualize and view some random images?</p> <p>To help us visualize, let's create a function that takes in a list of image paths and then randomly selects 10 of those paths to display.</p> <p>The function will:</p> <ol> <li>Take in a select list of image paths.</li> <li>Create a grid of matplotlib plots (e.g. 2x5 = 10 plots to plot on).</li> <li>Randomly sample 10 image paths from the input image path list (using <code>random.sample()</code>).</li> <li>Iterate through the flattened axes via <code>axes.flat</code> which is a reference to the attribute <code>numpy.ndarray.flat</code>.</li> <li>Extract the sample path from the list of samples.</li> <li>Get the sample title from the parent folder of the path using <code>Path.parent.stem</code> and then extract the formatted dog breed name by indexing <code>folder_to_class_name_dict</code>.</li> <li>Read the image with <code>plt.imread()</code> and show it on the target <code>ax</code> with <code>ax.imshow()</code>.</li> <li>Set the title of the plot to the parent folder name with <code>ax.set_title()</code> and turn the axis marks of with <code>ax.axis(\"off\")</code> (this makes for pretty plots).</li> <li>Show the plot with <code>plt.show()</code>.</li> </ol> <p>Woah!</p> <p>A lot of steps! But nothing we can't handle, let's do it.</p>"},{"location":"end-to-end-dog-vision-v2/#exploring-the-distribution-of-our-data","title":"Exploring the distribution of our data\u00b6","text":"<p>After visualization, another valuable way to explore the data is by checking the data distribution.</p> <p>Distribution refers to the \"spread\" of data.</p> <p>In our case, how many images of dogs do we have per breed?</p> <p>A balanced distribution would mean having roughly the same number of images for each breed (e.g. 100 images per dog breed).</p> <p>Note: There's a deeper level of distribution than just images per dog breed. Ideally, the images for each different breed are well distributed as well. For example, we wouldn't want to have 100 of the same image per dog breed. Not only would we like a similar number of images per breed, we'd like the images of each particular breed to be in different scenarios, different lighting, different angles. We want this because we want to our model to be able to recognize the correct dog breed no matter what angle the photo is taken from.</p> <p>To figure out how many images we have per class, let's write a function count the number of images per subfolder in a given directory.</p> <p>Specifically, we'll want the function to:</p> <ol> <li>Take in a target directory/folder.</li> <li>Create a list of all the subdirectories/subfolders in the target folder.</li> <li>Create an empty list, <code>image_class_counts</code> to append subfolders and their counts to.</li> <li>Iterate through all of the subdirectories.</li> <li>Get the class name of the target folder as the name of the folder.</li> <li>Count the number of images in the target folder using the length of the list of image paths (we can get these with <code>Path().rglob(*.jpg)</code> where <code>*.jpg</code> means \"all files with the extension <code>.jpg</code>.</li> <li>Append a dictionary of <code>{\"class_name\": class_name, \"image_count\": image_count}</code> to the <code>image_class_counts</code> list (we create a list of dictionaries so we can turn this into a pandas DataFrame).</li> <li>Return the <code>image_class_counts</code> list.</li> </ol>"},{"location":"end-to-end-dog-vision-v2/#4-creating-training-and-test-data-split-directories","title":"4. Creating training and test data split directories\u00b6","text":"<p>After exploring the data, one of the next best things you can do is create experimental data splits.</p> <p>This includes:</p> Set Name Description Typical Percentage of Data Training Set A dataset for the model to learn on 70-80% Testing Set A dataset for the model to be evaluated on 20-30% (Optional) Validation Set A dataset to tune the model on 50% of the test data (Optional) Smaller Training Set A smaller size dataset to run quick experiments on 5-20% of the training set <p>Our dog dataset already comes with specified training and test set splits.</p> <p>So we'll stick with those.</p> <p>But we'll also create a smaller training set (a random 10% of the training data) so we can stick to the machine learning engineers motto of experiment, experiment, experiment! and run quicker experiments.</p> <p>Note: One of the most important things in machine learning is being able to experiment quickly. As in, try a new model, try a new set of hyperparameters or try a new training setup. When you start out, you want the time between your experiments to be as small as possible so you can quickly figure out what doesn't work so you can spend more time on and run larger experiments with what does work.</p> <p>As previously discussed, we're working towards a directory structure of:</p> <pre><code>images_split/\n\u251c\u2500\u2500 train/\n\u2502   \u251c\u2500\u2500 class_1/\n\u2502   \u2502   \u251c\u2500\u2500 train_image1.jpg\n\u2502   \u2502   \u251c\u2500\u2500 train_image2.jpg\n\u2502   \u2502   \u2514\u2500\u2500 ...\n\u2502   \u251c\u2500\u2500 class_2/\n\u2502   \u2502   \u251c\u2500\u2500 train_image1.jpg\n\u2502   \u2502   \u251c\u2500\u2500 train_image2.jpg\n\u2502   \u2502   \u2514\u2500\u2500 ...\n\u2514\u2500\u2500 test/\n    \u251c\u2500\u2500 class_1/\n    \u2502   \u251c\u2500\u2500 test_image1.jpg\n    \u2502   \u251c\u2500\u2500 test_image2.jpg\n    \u2502   \u2514\u2500\u2500 ...\n    \u251c\u2500\u2500 class_2/\n    \u2502   \u251c\u2500\u2500 test_image1.jpg\n    \u2502   \u251c\u2500\u2500 test_image2.jpg\n...\n</code></pre> <p>So let's write some code to create:</p> <ul> <li><code>images/train/</code> directory to hold all of the training images.</li> <li><code>images/test/</code> directory to hold all of the testing images.</li> <li>Make a directory inside each of <code>images/train/</code> and <code>images/test/</code> for each of the dog breed classes.</li> </ul> <p>We can make each of the directories we need using <code>Path.mkdir()</code>.</p> <p>For the dog breed directories, we'll loop through the list of <code>dog_names</code> and create a folder for each inside the <code>images/train/</code> and <code>images/test/</code> directories.</p>"},{"location":"end-to-end-dog-vision-v2/#making-a-10-training-dataset-split","title":"Making a 10% training dataset split\u00b6","text":"<p>We've already split the data into training and test sets, so why might we want to make another split?</p> <p>Well, remember the machine learners motto?</p> <p>Experiment, experiment, experiment!</p> <p>We're going to make another training split which contains a random 10% (approximately 1,200 images, since the original training set has 12,000 images) of the data from the original training split.</p> <p>Why?</p> <p>Because whilst machine learning models generally perform better with more data, having more data means longer computation times.</p> <p>And longer computation times means the time between our experiments gets longer.</p> <p>Which is not what we want in the beginning.</p> <p>In the beginning of any new machine learning project, your focus should be to reduce the amount of time between experiments as much as possible.</p> <p>Why?</p> <p>Because running more experiments means you can figure out what doesn't work.</p> <p>And if you figure out what doesn't work, you can start working closer towards what does.</p> <p>Once you find something that does work, you can start to scale up your experiments (more data, bigger models, longer training times - we'll see these later on).</p> <p>To make our 10% training dataset, let's copy a random 10% of the existing training set to a new folder called <code>images_split/train_10_percent</code>, so we've got the layout:</p> <pre><code>images_split/\n\u251c\u2500\u2500 train/\n\u2502   \u251c\u2500\u2500 class_1/\n\u2502   \u2502   \u251c\u2500\u2500 train_image1.jpg\n\u2502   \u2502   \u251c\u2500\u2500 train_image2.jpg\n\u2502   \u2502   \u2514\u2500\u2500 ...\n\u2502   \u251c\u2500\u2500 class_2/\n\u2502   \u2502   \u251c\u2500\u2500 train_image1.jpg\n\u2502   \u2502   \u251c\u2500\u2500 train_image2.jpg\n\u2502   \u2502   \u2514\u2500\u2500 ...\n\u251c\u2500\u2500 train_10_percent/ &lt;--- NEW!\n\u2502   \u251c\u2500\u2500 class_1/\n\u2502   \u2502   \u251c\u2500\u2500 random_train_image42.jpg\n\u2502   \u2502   \u2514\u2500\u2500 ...\n\u2502   \u251c\u2500\u2500 class_2/\n\u2502   \u2502   \u251c\u2500\u2500 random_train_image106.jpg\n\u2502   \u2502   \u2514\u2500\u2500 ...\n\u2514\u2500\u2500 test/\n    \u251c\u2500\u2500 class_1/\n    \u2502   \u251c\u2500\u2500 test_image1.jpg\n    \u2502   \u251c\u2500\u2500 test_image2.jpg\n    \u2502   \u2514\u2500\u2500 ...\n    \u251c\u2500\u2500 class_2/\n    \u2502   \u251c\u2500\u2500 test_image1.jpg\n    \u2502   \u251c\u2500\u2500 test_image2.jpg\n    \u2502   \u2514\u2500\u2500 ...\n</code></pre> <p>Let's start by creating that folder.</p>"},{"location":"end-to-end-dog-vision-v2/#5-turning-datasets-into-tensorflow-datasets","title":"5. Turning datasets into TensorFlow Dataset(s)\u00b6","text":"<p>Alright, we've spent a bunch of time getting our dog images into different folders.</p> <p>But how do we get the images from different folders into a machine learning model?</p> <p>Well, like the other machine learning models we've built throughout the course, we need a way to turn our images into numbers.</p> <p>Specifically, we're going to turn our images into tensors.</p> <p>That's where the \"Tensor\" comes from in \"TensorFlow\".</p> <p>A tensor is a way to numerically represent something (where something can be almost anything you can think of, text, images, audio, rows and columns).</p> <p>There are several different ways to load data into TensorFlow.</p> <p>But the formula is the same across data types, have data -&gt; use TensorFlow to turn it into tensors.</p> <p>The reason why we spent time getting our data into the standard image classification format (where the class name is the folder name) is because TensorFlow includes several utility functions to load data from this directory format.</p> Function Description <code>tf.keras.utils.image_dataset_from_directory()</code> Creates a <code>tf.data.Dataset</code> from image files in a directory. <code>tf.keras.utils.audio_dataset_from_directory()</code> Creates a <code>tf.data.Dataset</code> from audio files in a directory. <code>tf.keras.utils.text_dataset_from_directory()</code> Creates a <code>tf.data.Dataset</code> from text files in a directory. <code>tf.keras.utils.timeseries_dataset_from_array()</code> Creates a dataset of sliding windows over a timeseries provided as array. <p>What is a <code>tf.data.Dataset</code>?</p> <p>It's TensorFlow's efficient way to store a potentially large set of elements.</p> <p>As machine learning datasets can get quite large, you need an efficient way to store and load them.</p> <p>This is what the <code>tf.data.Dataset</code> API provides.</p> <p>And it's what we'd like to turn our dog images into.</p> <p>Since we're working with images, we can do so with <code>tf.keras.utils.image_dataset_from_directory()</code>.</p> <p>We'll pass in the following parameters:</p> <ul> <li><code>directory</code> = the target directory we'd like to turn into a <code>tf.data.Dataset</code>.</li> <li><code>label_mode</code> = the kind of labels we'd like to use, in our case it's <code>\"categorical\"</code> since we're dealing with a multi-class classification problem (we would use <code>\"binary\"</code> if we were working with binary classifcation problem).</li> <li><code>batch_size</code> = the number of images we'd like our model to see at a time (due to computation limitations, our model won't be able to look at every image at once so we split them into small batches and the model looks at each batch individually), generally 32 is a good value to start, this means our model will look at 32 images at a time (this number is flexible).</li> <li><code>image_size</code> = the size we'd like to shape our images to before we feed them to our model (height x width).</li> <li><code>shuffle</code> = whether we'd like our dataset to be shuffled to randomize the order.</li> <li><code>seed</code> = if we're shuffling the order in a random fashion, do we want that to be reproducible?</li> </ul> <p>Note: Values such as <code>batch_size</code> and <code>image_size</code> are known as hyperparameters, meaning they're values that you can decide what to set them as. As for the best value for a given hyperparameter, that depends highly on the data you're working with, problem space and compute capabilities you've got avaiable. Best to experiment!</p> <p>With all this being said, let's see it in practice!</p> <p>We'll make 3 <code>tf.data.Dataset</code>'s, <code>train_10_percent_ds</code>, <code>train_ds</code> and <code>test_ds</code>.</p>"},{"location":"end-to-end-dog-vision-v2/#visualizing-images-from-our-tensorflow-dataset","title":"Visualizing images from our TensorFlow Dataset\u00b6","text":"<p>Let's follow the data explorer's motto once again and visualize, visualize, visualize!</p> <p>How about we turn our single sample from tensor format to image format?</p> <p>We can do so by passing the single sample image tensor to matplotlib's <code>plt.imshow()</code> (we'll also need to convert its datatype from <code>float32</code> to <code>uint8</code> to avoid matplotlib colour range issues).</p>"},{"location":"end-to-end-dog-vision-v2/#getting-labels-from-our-tensorflow-dataset","title":"Getting labels from our TensorFlow Dataset\u00b6","text":"<p>Since our data is now in <code>tf.data.Dataset</code> format, there are a couple of important attributes we can pull from it if necessary.</p> <p>The first is the collection of filepaths asosciated with a <code>tf.data.Dataset</code>.</p> <p>These are accessible by the <code>.file_paths</code> attribute.</p> <p>Note: You can often a see a list of assosciated methods and attributes of a variable/class in Google Colab (or other IDEs) by pressing TAB afterwards (e.g type <code>variable_name.</code> + TAB).</p>"},{"location":"end-to-end-dog-vision-v2/#configuring-our-datasets-for-performance","title":"Configuring our datasets for performance\u00b6","text":"<p>There's one last step we're going to do before we build our first TensorFlow model.</p> <p>And that's configure our datasets for performance.</p> <p>More specifically, we're going to focus on following the TensorFlow guide for Better performance with the tf.data API.</p> <p>Why?</p> <p>Because data loading is one of the biggest bottlenecks in machine learning.</p> <p>Modern GPUs can perform calculations (matrix multiplications) to find patterns in data quite quickly.</p> <p>However, for the GPU to perform such calculations, the data needs to be there.</p> <p>Good news for us is that if we follow the TensorFlow <code>tf.data</code> best practices, TensorFlow will take care of all these optimizations and hardware acceleration for us.</p> <p>We're going to call three methods on our dataset to optimize it for performance:</p> <ul> <li><code>cache()</code> - Cache the elements in the dataset in memory or a target folder (speeds up loading.</li> <li><code>shuffle()</code> - Shuffle a set number of samples in preparation for loading (this will mean our samples and batches of samples will be shuffled), for example, setting <code>shuffle(buffer_size=1000)</code> will prepare and shuffle 1000 elements of data at a time.</li> <li><code>prefetch()</code> - Prefetch the next batch of data and prepare it for computation whilst the previous one is being computed on (can scale to multiple prefetches depending on hardware availability). TensorFlow can automatically configure how many elements/batches to prefetch by setting <code>prefetch(buffer_size=tf.data.AUTOTUNE)</code>.</li> </ul> <p>Resource: For more performance tips on loading dataset in TensorFlow, see the Datasets Performance tips guide.</p> <p>In our case, let's start by calling <code>cache()</code> on our datasets to save the loaded samples to memory.</p> <p>We'll then <code>shuffle()</code> the training splits with <code>buffer_size=10*BATCH_SIZE</code> for the training 10% split and <code>buffer_size=100*BATCH_SIZE</code> for the full training set.</p> <p>Why these numbers?</p> <p>That's how many I decided to use via experimentation, feel free to figure out a different number that may work better.</p> <p>Ideally if your dataset isn't too large, you would shuffle all possible samples (TensorFlow has a method of finding the number of samples in a dataset called <code>tf.data.Dataset.cardinality()</code>).</p> <p>We won't call <code>shuffle()</code> on the testing dataset since it isn't required.</p> <p>And we'll call <code>prefetch(buffer_size=tf.data.AUTOTUNE)</code> on each of our datasets to automatically load and prepare a number of data batches.</p>"},{"location":"end-to-end-dog-vision-v2/#6-creating-a-neural-network-with-tensorflow","title":"6. Creating a neural network with TensorFlow\u00b6","text":"<p>We've spent lots of time preparing the data.</p> <p>This is because it's often the largest part of a machine learning problem, getting your data ready for a machine learning model.</p> <p>Thanks to modern frameworks like TensorFlow, when you've got your data in order, building a deep learning model to find patterns in your data can be one of the easier steps of the process.</p> <p>When you hear people talk about deep learning, they're often referring to neural networks.</p> <p>Neural networks are one of the most flexible machine learning models there is.</p> <p>You can create a neural network to fit almost any kind of data.</p> <p>The \"deep\" in deep learning refers to the many layers that can be contained inside a neural network.</p> <p>A neural network often follows the structure of:</p> <p>Input layer -&gt; Middle layer(s) -&gt; Output layer.</p> <p></p> <p>General anatomy of a neural network. Neural networks are almost infinitely customisable. The main premise is that data goes in one end, gets manipulated by many small functions in an attempt to learn patterns/weights which represent the data to produce useful outputs. Note that \"patterns\" is an arbitrary term, you\u2019ll often hear \"embedding\", \"weights\", \"feature representation\", \"representation\" all referring to similar things.</p> <p>Where the input layer takes in the data, the middle layer(s) perform calculations on the data and (hopefully) learn patterns (also called weights/biases) to represent the data and the output layer performs a final transformation on the learned patterns to make them usable in human applications.</p> <p>What goes into the middle layer(s)?</p> <p>That's an excellent question.</p> <p>Because there are so many different options.</p> <p>But two of the most popular modern kinds of neural network are Convolutional Neural Networks (CNNs) and Transformers (the Transformer is the \"T\" in GPT, Generative Pretrained Transformer).</p> Architecture Description Example Layers Problem Examples Transformer) A combination of fully connected layers as well as attention-based layers. <code>tf.keras.layers.Attention</code>, <code>tf.keras.layers.Dense</code> NLP, Machine Translation, Computer Vision Convolutional Neural Network A combination of fully connected layers as well as convolutional-based layers. <code>tf.keras.layers.Conv2D</code>, <code>tf.keras.layers.Dense</code> Computer Vision, Audio Processing <p>Because our problem is in the computer space, we're going to use a CNN.</p> <p>And instead of crafting our own CNN from scratch, we're going to take an existing CNN model and apply it to our own problem, harnessing the wonderful superpower of transfer learning.</p> <p>Note: You can build and use working neural networks with TensorFlow without knowing the intricate details that's going on the behind the scenes (that's what we're focused on). For an idea of the mathematical operations that make neural networks work, I'd recommend going through 3Blue1Brown's YouTube series on Neural Networks.</p>"},{"location":"end-to-end-dog-vision-v2/#the-magic-of-transfer-learning","title":"The magic of transfer learning\u00b6","text":"<p>Transfer learning is the process of getting an existing working model and adjusting it to your own problem.</p> <p>This works particularly well for neural networks.</p> <p>The main benefit of transfer learning is being able to get better results in less time with less data.</p> <p>How?</p> <p>An existing model may have the following features:</p> <ul> <li>Trained on lots of data (in the case of computer vision, existing models are often pretrained on ImageNet, a dataset of 1M+ images, this means they've already learned patterns across many different kinds of images).</li> <li>Crafted by expert researchers (large universities and companies such as Google and Meta often open-source their best models for others to try and use).</li> <li>Trained of lots of computing hardware (the larger the model and the larger the dataset, the more compute power you need, not everyone has access to 10s, 100s or 1000s of GPUs).</li> <li>Proven to perform well on a given task through several studies (this means it has a good chance on performing well on your task if it's similar).</li> </ul> <p>You may be thinking, ok so, this all sounds incredible, where can I get pretrained models?</p> <p>And the good news is, there are plenty of places to find pretrained models!</p> Resource Description <code>tf.keras.applications</code> A module built-in to TensorFlow and Keras with a series of pretrained models ready to use. KerasNLP and KerasCV Two dedicated libraries for NLP (natural language processing) and CV (computer vision) each of which includes many modality-specific APIs and is capable of running with TensorFlow, JAX or PyTorch. Hugging Face Models Hub A large collection of pretrained models on a wide range on tasks, from computer vision to natural language processing to audio processing. Kaggle Models A huge collection of different pretrained models for many different tasks. <p></p> <p>Different locations to find pretrained models. This list is consistantly expanding as machine learning becomes more and more open-source.</p> <p>Note: For most new machine learning problems, if you're looking to get good results quickly, you should generally look for a pretrained model similar to your problem and use transfer learning to adapt it to your own domain.</p> <p>Since we're focused on TensorFlow/Keras, we're going to be using a pretrained model from <code>tf.keras.applications</code>.</p> <p>More specifically, we're going to take the <code>tf.keras.applications.efficientnet_v2.EfficientNetV2B0()</code> model from the 2021 machine learning paper EfficientNetV2: Smaller Models and Faster Training from Google Research and apply it to our own problem.</p> <p>This model has been trained on ImageNet1k (1M+ images across 1000 different diverse classes, there is a version called ImageNet22k with 14M+ images across 22,000 categories) so it has a good baseline understanding of patterns in images across a wide domain.</p> <p>We'll see if we can adjust those patterns slightly to our dog images.</p> <p>Let's create an instance of it and call it <code>base_model</code> (I'll explain why next).</p>"},{"location":"end-to-end-dog-vision-v2/#model-input-and-output-shapes","title":"Model input and output shapes\u00b6","text":"<p>One of the most important practical steps in using a deep learning model is input and output shapes.</p> <p>Two questions to ask:</p> <ul> <li>What is the shape of my input data?</li> <li>What is the ideal shape of my output data?</li> </ul> <p>We ask about shapes because in all deep learning models input and output data comes in the form of tensors.</p> <p>This goes for text, audio, images and more.</p> <p>The raw data gets converted to a numerical representation first before being passed to a model.</p> <p>In our case, our input data has the shape of <code>[(32, 224, 224, 3)]</code> or <code>[(batch_size, height, width, colour_channels)]</code>.</p> <p>And our ideal output shape will be <code>[(32, 120)]</code> or <code>[(batch_size, number_of_dog_classes)</code>.</p> <p>Your input and output shapes will differ depending on the problem and data you're working with.</p> <p>But as you get deeper into the world of machine learning (and deep learning), you'll find input and output shapes are one of the most common errors.</p> <p>We can check our model's input and output shapes with the <code>.input_shape</code> and <code>.output_shape</code> attributes.</p>"},{"location":"end-to-end-dog-vision-v2/#model-parameters","title":"Model parameters\u00b6","text":"<p>In traditional programming, you write a list of rules for inputs to go in, get manipulated in some predefined way and then outputs come out.</p> <p>However, as we've discussed, machine learning switches the order.</p> <p>Inputs and ideal outputs go in (for example, dog images and their corresponding labels) and rules come out.</p> <p>A model's parameters are the learned rules.</p> <p>And learned is the important point.</p> <p>In an ideal setup, we never tell the model what parameters to learn, it learns them itself by connecting input data to labels in supervised learning and by grouping together similar samples in unsupervised learning.</p> <p>Note: Parameters are values learned by a model where as hyperpameters (e.g. batch size) are values set by a human.</p> <p>Parameters also get referred to as \"weights\" or \"patterns\" or \"learned features\" or \"learned representations\".</p> <p>Generally, the more parameters a model has, the more capacity it has to learn.</p> <p>Each layer in a deep learning model will have a specific number of parameters (these vary depending on which layer you use).</p> <p>The benefit of using a preconstructed model and transfer learning is that someone else has done the hard work in finding what combination of layers leads to a good set of parameters (a big thank you to these wonderful people).</p> <p>We can count the number of parameters in a model/layer via the the <code>.count_params()</code> method.</p>"},{"location":"end-to-end-dog-vision-v2/#passing-data-through-our-model","title":"Passing data through our model\u00b6","text":"<p>We've spoken a couple of times how our <code>base_model</code> is a \"feature extractor\" or \"pattern extractor\".</p> <p>But what does this mean?</p> <p>It means that when a data sample goes through the <code>base_model</code>, its numbers get manipulated into a compressed set of features.</p> <p>In other words, the layers of the model will each perform a calculation on the sample eventually leading to an output tensor with patterns the model has deemed most important.</p> <p>This is often referred to a compressed feature space.</p> <p>That's one of the central ideas of deep learning.</p> <p>Take a large input (e.g. an image tensor of shape <code>[224, 224, 3]</code>) and compress it into a smaller output (e.g. a feature vector#Feature_vectors) of shape <code>[1280]</code>) that captures a useful representation of the input.</p> <p></p> <p>Example of how a model can take an input piece of data and compress its representation into a feature vector with much lower dimensionality than the original data.</p> <p>Note: A feature vector is also referred to as an embedding, a compressed representation of a data sample that makes it useful. The concept of embeddings is not limited to images either, the concept of embeddings stretches across all data types (text, images, video, audio + more).</p> <p>We can see this in action by passing a single image through our <code>base_model</code>.</p>"},{"location":"end-to-end-dog-vision-v2/#going-from-image-to-feature-vector-practice","title":"Going from image to feature vector (practice)\u00b6","text":"<p>We've covered a fair bit in the past few sections.</p> <p>So let's practice.</p> <p>The important takeaway is that one of the main goals of deep learning is to create a model that is able to take some kind of high dimensional data (e.g. an image tensor, a text tensor, an audio tensor) and extract meaningful patterns in it whilst compressing it to a lower dimensional form (e.g. a feature vector or embedding).</p> <p>We can then use this lower dimensional form for our specific use cases.</p> <p>And one of the most powerful ways to do this is with transfer learning.</p> <p>Taking an existing model from a similar domain to yours and applying it to your own problem.</p> <p>To practice turning a data sample into a feature vector, let's start by recreating a <code>base_model</code> instance.</p> <p>This time, we can add in a pooling layer automatically using <code>pooling=\"avg\"</code> or <code>pooling=\"max\"</code>.</p> <p>Note: I demonstrated the use of the <code>tf.keras.layers.GlobalAveragePooling2D()</code> layer because not all pretrained models have the functionality of a pooling layer being built-in.</p>"},{"location":"end-to-end-dog-vision-v2/#creating-a-custom-model-for-our-dog-vision-problem","title":"Creating a custom model for our dog vision problem\u00b6","text":"<p>The main steps when creating any kind of deep learning model from scratch are:</p> <ol> <li>Define the input layer(s).</li> <li>Define the middle layer(s).</li> <li>Define the output layer(s).</li> </ol> <p>These sound broad because they are. Deep learning models are almost infinitely customizable.</p> <p>Good news is, thanks to transfer learning, all of our middle layers are defined by <code>base_model</code> (you could argue the input layer is created too).</p> <p>So now it's up to us to define our input and output layers.</p> <p>TensorFlow/Keras have two main ways of connecting layers to form a model.</p> <ol> <li>The Sequential model (<code>tf.keras.Sequential</code>) - Useful for making simple models with one tensor in and one tensor out, not suited for complex models.</li> <li>The Functional API - Useful for making more complex and multi-step models but can also be used for simple models.</li> </ol> <p>Let's start with the Sequential model.</p> <p>It takes a list of layers and will pass data through them sequentially.</p> <p>Our <code>base_model</code> will be the input and middle layers and we'll use a <code>tf.keras.layers.Dense()</code> layer as the output (we'll discuss this shortly).</p>"},{"location":"end-to-end-dog-vision-v2/#creating-a-model-with-the-sequential-api","title":"Creating a model with the Sequential API\u00b6","text":"<p>The Sequential API is the most straightforward way to create a model.</p> <p>Your model comes in the form of a list of layers from input to middle layers to output.</p> <p>Each layer is executed sequentially.</p>"},{"location":"end-to-end-dog-vision-v2/#creating-a-model-with-the-functional-api","title":"Creating a model with the Functional API\u00b6","text":"<p>As mentioned before, the Keras Functional API is a way/design pattern for creating more complex models.</p> <p>It can include multiple different modelling steps.</p> <p>But it can also be used for simple models.</p> <p>And it's the way we'll construct our Dog Vision models going forward.</p> <p>Let's recreate our <code>sequential_model</code> using the Functional API.</p> <p>We'll follow the same process as mentioned before:</p> <ol> <li>Define the input layer(s).</li> <li>Define the middle/hidden layer(s).</li> <li>Define the output layer(s).</li> <li>Bonus: Connect the inputs and outputs within an instance of <code>tf.keras.Model()</code>.</li> </ol>"},{"location":"end-to-end-dog-vision-v2/#functionizing-model-creation","title":"Functionizing model creation\u00b6","text":"<p>We've created two different kinds of models so far.</p> <p>Each of which use the same layers.</p> <p>Except one was with the Keras Sequential API and the other was with the Keras Functional API.</p> <p>However, it would be quite tedious to rewrite that modelling code every time we wanted to create a new model.</p> <p>So let's create a function called <code>create_model()</code> to replicate the model creation step with the Functional API.</p> <p>Note: We're focused on the Functional API since it takes a bit more practice than the Sequential API.</p>"},{"location":"end-to-end-dog-vision-v2/#7-model-0-train-a-model-on-10-of-the-training-data","title":"7. Model 0 - Train a model on 10% of the training data\u00b6","text":"<p>We've seen our model make a couple of predictions on our data.</p> <p>And so far it hasn't done so well.</p> <p>This is expected though.</p> <p>Our model is essentially predicting random class values given an image.</p> <p>Let's change that.</p> <p>How?</p> <p>By training the final layer on our model to be customized to recognizing images of dogs.</p> <p>We can do so via five steps:</p> <ol> <li>Creating the model - We've done this \u2705.</li> <li>Compiling the model - Here's where we'll tell the model how to improve itself and how to measure its performance.</li> <li>Fitting the model - Here's where we'll show the model examples of what we'd like it to learn (e.g. batches of samples containing pairs of dog images and their breed).</li> <li>Evaluating the model - Once our model is trained on the training data, we can evaluate it on the testing data (data the model has never seen).</li> <li>Making a custom prediction - Finally, the best way to test a machine learning model is by seeing how it goes on custom data. This is where we'll try to make a prediction on our own custom images of dogs.</li> </ol> <p>We'll work through each of these over the next few sections.</p> <p>To begin, let's create a model.</p> <p>To do so, we can use our <code>create_model()</code> function that we made earlier.</p>"},{"location":"end-to-end-dog-vision-v2/#compiling-a-model","title":"Compiling a model\u00b6","text":"<p>After we've created a model, the next step is to compile it.</p> <p>If creating a model is putting together learning blocks, compiling a model is to getting those learning blocks ready to learn.</p> <p>We can compile our <code>model_0</code> using the <code>tf.keras.Model.compile()</code> method.</p> <p>There are many options we can pass to the <code>compile()</code> method, however, the main ones we'll be focused on are:</p> <ol> <li>The optimizer - this tells the model how to improve based on the loss value.</li> <li>The loss function - this measures how wrong the model is (e.g. how far off are its predictions from the truth, an ideal loss value is 0, meaning the model is perfectly predicting the data).</li> <li>The metric(s) - this is a human-readable value that shows how your model is performing, for example, accuracy is often used as an evaluation metric.</li> </ol> <p>These three settings work together to help improve a model.</p>"},{"location":"end-to-end-dog-vision-v2/#which-optimizer-should-i-use","title":"Which optimizer should I use?\u00b6","text":"<p>An optimizer tells a model how to improve its internal parameters (weights) to hopefully improve a loss value.</p> <p>In most cases, improving the loss means to minimize it (a loss value is a measure of how wrong your model's predictions are, a perfect model will have a loss value of 0).</p> <p>It does this through a process called gradient descent.</p> <p>The gradients needed for gradient descent are calculated through backpropagation, a method that computes the gradient of the loss function with respect to each weight in the model.</p> <p>Once the gradients have been calculated, the optimizer then tries to update the model weights so that they move in the opposite direction of the gradient (if you go down the gradient of a function, you reduce its value).</p> <p>If you've never heard of the above processes, that's okay.</p> <p>TensorFlow implements many of them behind the scenes.</p> <p>For now, the main takeaway is that neural networks learn in the following fashion:</p> <p>Start with random patterns/weights -&gt; Look at data (forward pass) -&gt; Try to predict data (with current weights) -&gt; Measure performance of predictions (loss function, backpropagation calculates gradients of loss with respect to weights) -&gt; Update patterns/weights (optimizer, gradient descent adjusts weights in the opposite direction of the gradients to minimize loss) -&gt; Look at data (forward pass) -&gt; Try to predict data (with updated weights) -&gt; Measure performance (loss function) -&gt; Update patterns/weights (optimizer) -&gt; Repeat  all of the above X times.</p> <p>Example of how a neural network learns (in brief). Note the cyclical nature of the learning. You can think of it as a big game of guess and check, where the guess (hopefully) get better over time.</p> <p>I'll leave the intricacies of gradient descent and backpropagation to your own extra-curricula research.</p> <p>We're going to focus on using the tools TensorFlow has to offer to implement this process.</p> <p>As for optimizer functions, there are two main options to get started:</p> Optimizer Code Stochastic Gradient Descent (SGD) <code>tf.keras.optimizers.SGD()</code> or <code>\"sgd\"</code> for short. Adam <code>tf.keras.optimizers.Adam()</code> or <code>\"adam\"</code> for short. <p>Why these two?</p> <p>Because they're the most often used in practice (you can see this via the number of machine learning papers referencing each one on paperswithcode.com).</p> <p>There are many more optimizers available in the <code>tf.keras.optimizers</code> module too.</p> <p>The good thing about using a premade optimizer from <code>tf.keras.optimizers</code> is that they usually come with good starting settings.</p> <p>One the main ones being the <code>learning_rate</code> value.</p> <p>The <code>learning_rate</code> is one of the most important hyperparameters to set in a neural network training setup.</p> <p>It determines how much of a step change the optimizer will adjust your models weights every iteration.</p> <p>Too low and the model won't learn.</p> <p>Too high and the model will try to take too big of steps.</p> <p>By default, TensorFlow sets the learning rate of the Adam optimizer to 0.001 (<code>tf.keras.optimizers.Adam(learning_rate=0.001)</code>) which is a good setting for many problems to get started with.</p> <p>We can also set this default with the shortcut <code>optimizer=\"adam\"</code>.</p> <p>For more on finding the optimal learning rate, try searching for \"finding the optimal learning rate for neural networks\".</p>"},{"location":"end-to-end-dog-vision-v2/#which-loss-function-should-i-use","title":"Which loss function should I use?\u00b6","text":"<p>A loss function measures how wrong your model's predictions are.</p> <p>A model with poor predictions in comparison to the truth data will have a high loss value.</p> <p>Where as a model with perfect predictions (e.g. it gets every prediction correct) will have a loss value of 0.</p> <p>Different problems have different loss functions.</p> <p>Some of the most common ones include:</p> Loss Function Problem Type Code Mean Absolute Error (MAE) Regression (predicting a number) <code>tf.keras.losses.MeanAbsoluteError</code> or <code>\"mae\"</code> for short Mean Squared Error (MSE) Regression (predicting a number) <code>tf.keras.losses.MeanSquaredError</code> Binary Cross Entropy (BCE) Binary classification <code>tf.keras.losses.BinaryCrossentropy</code> Categorical Cross Entropy Multi-class classification <code>tf.keras.losses.CategoricalCrossentropy</code> if your labels are one-hot encoded (e.g. <code>[0, 0, 0, 0, 1, 0...]</code>) or <code>tf.keras.losses.SparseCategoricalCrossentropy</code> if your labels are integers (e.g. <code>[[1], [23], [43], [16]...]</code>) <p>In our case, since we're working with multi-class classification (multiple different dog breeds) and our labels are one-hot encoded, we'll be using <code>tf.keras.losses.CategoricalCrossentropy</code>.</p> <p>We can leave all of the default parameters as they are as well.</p> <p>However, if we didn't have <code>activation=\"softmax\"</code> in the final layer of our model, we'd have to change <code>from_logits=False</code> to <code>from_logits=True</code> as the softmax activation function does this conversion for us.</p> <p>There are more loss functions than the ones we've discussed and you can see many of them on paperswithcode.com.</p> <p>TensorFlow also has many more loss function implementations available in <code>tf.keras.losses</code>.</p> <p>Let's check out a single sample of our labels to make sure they're one-hot encoded.</p>"},{"location":"end-to-end-dog-vision-v2/#which-mertics-should-i-use","title":"Which mertics should I use?\u00b6","text":"<p>The evaluation metric is a human-readable value which is used to see how well your model is performing.</p> <p>A slightly confusing concept is that the evaluation metric and loss function can be the same equation.</p> <p>However, the main difference between a loss function and an evaluation metric is that the loss function will typically be differentiable (there are some exceptions to the rule but in most cases, the loss function will be differentiable).</p> <p>Whereas, the evaluation metric does not have to be differtiable.</p> <p>In the case of regression (predicting a number), your loss function and evaluation metric could be mean squared error (MSE).</p> <p>Whereas in the case of classification, your loss function will generally be binary crossentropy (for two classes) or categorical crossentropy (for multiple classes) and your evalaution metric(s) could be accuracy, F1-score, precision and/or recall.</p> <p>TensorFlow provides many pre-built metrics in the <code>tf.keras.metrics</code> module.</p> Evaluation Metric Problem Type Code Accuracy Classification <code>tf.keras.metrics.Accuracy</code> or <code>\"accuracy\"</code> for short Precision Classification <code>tf.keras.metrics.Precision</code> Recall Classification <code>tf.keras.metrics.Recall</code> F1 Score Classification <code>tf.keras.metrics.F1Score</code> Mean Squared Error (MSE) Regression <code>tf.keras.metrics.MeanSquaredError</code> or <code>\"mse\"</code> for short Mean Absolute Error (MAE) Regression <code>tf.keras.metrics.MeanAbsoluteError</code> or <code>\"mae\"</code> Area Under the ROC Curve (AUC-ROC) Binary Classification <code>tf.keras.metrics.AUC</code> with <code>curve='ROC'</code> <p>The <code>tf.keras.Model.compile()</code> method expects the <code>metrics</code> parameter input as a list.</p> <p>Since we're working with a classification problem, let's setup our evaluation metric as accuracy.</p>"},{"location":"end-to-end-dog-vision-v2/#learn-more-on-how-a-model-learns","title":"Learn more on how a model learns\u00b6","text":"<p>We've breifly touched on optimizers, loss functions, gradient descent and backpropagation, the backbone of neural network learning, however, for a more in-depth look at each of these, I'd check out the following:</p> <ul> <li>3Blue1Brown's series on Neural Networks - a fantastic 4 part video series on how neural networks are built to how they learn through gradient descent and backpropagation.</li> <li>The Little Book of Deep Learning by Fran\u00e7ois Fleuret - a free ~150 page booklet on the ins and outs of deep learning. The notation may be intimidating at first but with practice you will begin to understand it.</li> </ul>"},{"location":"end-to-end-dog-vision-v2/#putting-it-all-together-and-compiling-our-model","title":"Putting it all together and compiling our model\u00b6","text":"<p>Phew!</p> <p>We've now been through all the main steps in compiling a model:</p> <ol> <li>Creating the optimizer.</li> <li>Creating the loss function.</li> <li>Creating the evaluation metrics.</li> </ol> <p>Now let's put everything we've done together and compile our <code>model_0</code>.</p> <p>First we'll do it with shortcuts (e.g. <code>\"accuracy\"</code>) then we'll do it with specific classes.</p>"},{"location":"end-to-end-dog-vision-v2/#fitting-a-model-on-the-data","title":"Fitting a model on the data\u00b6","text":"<p>Model created and compiled!</p> <p>Time to fit it to the data.</p> <p>This means we're going to pass all of the data we have (dog images and their assigned labels) through our model and ask it to try and learn the relationship between the images and the labels.</p> <p>Fitting the model is step 3 in our list:</p> <ol> <li>Creating the model - We've done this \u2705.</li> <li>Compiling the model - We've done this \u2705.</li> <li>Fitting the model - Here's where we'll show the model examples of what we'd like it to learn (e.g. the relationship between an image of a dog and its breed).</li> <li>Evaluating the model - Once our model is trained on the training data, we can evaluate it on the testing data (data the model has never seen).</li> <li>Making a custom prediction - Finally, the best way to test a machine learning model is by seeing how it goes on custom data. This is where we'll try to make a prediction on our own custom images of dogs.</li> </ol> <p>We can fit our <code>model_0</code> instance with the <code>tf.keras.Model.fit()</code> method.</p> <p>The main parameters of the <code>fit()</code> method we'll be paying attention to are:</p> <ul> <li><code>x</code> = What data do you want the model to train on?</li> <li><code>y</code> = What labels do you want your model to learn the patterns from your data to?</li> <li><code>batch_size</code> = The number of samples your model will look at per gradient update (e.g. 32 samples at a time before updating its internal patterns).</li> <li><code>epochs</code> = How many times do you want the model to go through all samples (e.g. <code>epochs=5</code> means looking at all of the data 5 times)?</li> <li><code>validation_data</code> = What data do you want to evaluate your model's learning on?</li> </ul> <p>There are plenty more options in the TensorFlow/Keras documentation for the <code>fit()</code> method.</p> <p>However, these options will be more than enough for us.</p> <p>In our case, let's keep our experiments quick and set the following:</p> <ul> <li><code>x=train_10_percent_ds</code> - Since we've crafted a <code>tf.data.Dataset</code>, our <code>x</code> and <code>y</code> values are combined into one. We'll also start by training on 10% of the data for quicker experimentation (if things work on a smaller subset of the data, we can always increase it).</li> <li><code>epochs=5</code> - The more epochs you do, the more opportunities your model has to learn patterns, however, it also prolongs training.</li> <li><code>validation_data=test_ds</code> - We'll evaluate the model's learning on the test dataset (samples its never seen before).</li> </ul> <p>Let's do it!</p> <p>Time to train our first neural network and bring Dog Vision \ud83d\udc36\ud83d\udc41\ufe0f to life!</p> <p>Note: If you don't have a GPU here, training will likely take a considerably long time. You can activate a GPU in Google Colab by going to Runtime -&gt; Change runtime type -&gt; Hardware accelerator -&gt; GPU. Note that changing a runtime type will mean you will have to restart your runtime and rerun all of the cells above.</p>"},{"location":"end-to-end-dog-vision-v2/#8-putting-it-all-together-create-compile-fit","title":"8. Putting it all together: create, compile, fit\u00b6","text":"<p>Let's practice what we've done so far to train our first neural network.</p> <p>Specifically, we're going to:</p> <ol> <li>Create a model (using our <code>create_model()</code>) function.</li> <li>Compile our model (selecting our optimizer, loss function and evaluation metric).</li> <li>Fit our model (get it to figure out the patterns bettwen images and labels).</li> </ol> <p>And later on, we'll get to the other steps of evaluation and making custom predictions.</p>"},{"location":"end-to-end-dog-vision-v2/#evaluate-model-0-on-the-test-data","title":"Evaluate Model 0 on the test data\u00b6","text":"<p>Alright, the next step in our journey is to evaluate our trained model.</p> <p>In fact, evaluating a model is just as important as training a model.</p> <p>There are several ways to evaluate a model:</p> <ul> <li>Look at the metrics (such as accuracy).</li> <li>Plot the loss curves.</li> <li>Make predictions on the test set and compare them to the truth labels.</li> <li>Make predictions on custom samples (not contained in the training or test sets).</li> </ul> <p>We've done the first one, as these metrics were the outputs of our model training.</p> <p>Now we're going to focus on the next two.</p> <p>Plotting loss curves and making predictions on the test set.</p> <p>We'll get to custom images later on.</p> <p>So what are loss curves?</p> <p>Loss curves are a visualization of how your model's loss value performs overtime.</p> <p>We say loss \"curves\" because you can have a loss curve for each dataset, training, validation and test.</p> <p>An ideal loss curve will start high and move towards zero (a perfect model will have a loss value of zero).</p> <p>How do we get a loss curve?</p> <p>We could manually plot the loss values output from our model training.</p> <p>Or we could programmatically get the values thanks to the <code>History</code> object.</p> <p>This object is returned by the <code>fit</code> method of <code>tf.keras.Model</code> instances.</p> <p>And we've already got one!</p> <p>It's saved to <code>history_0</code> (the model history for <code>model_0</code>).</p> <p>The <code>History.history</code> attribute contains a record of the training loss values and evaluation metrics for each epoch.</p> <p>Let's check it out.</p>"},{"location":"end-to-end-dog-vision-v2/#overfitting-and-underfitting-when-your-model-doesnt-perform-how-youd-like","title":"Overfitting and underfitting (when your model doesn't perform how you'd like)\u00b6","text":"<p>You may be wondering why there's a gap between the training and validation loss curves.</p> <p>Ideally, the two lines would closely follow each other.</p> <p>In our case, the validation loss doesn't decrease as low as the training loss.</p> <p>This is known as overfitting, a common problem in machine learning where a model learns the training data very well but doesn't generalize to other unseen data.</p> <p>You can think of this as a university student memorizing the course materials but failing to apply that knowledge to problems that aren't in the course materials (real-world problems).</p> <p>The reverse of overfitting is underfitting, which is when a model fails to learn anything useful. For example, it never manages to increase accuracy or decrease loss.</p> <p>Good news is, our model isn't underfitting (it's performing at ~80% accuracy on unseen data).</p> <p>I'll leave \"ways to fix overfitting\" as an extension.</p> <p>But one of the best ways is to use more data.</p> <p>And guess what?</p> <p>We've got plenty more!</p> <p>Reminder, these results were achieved using only 10% of the training data.</p> <p>Before we train a model with more data, there's another way to quickly evaluate our model on a given dataset.</p> <p>And that's using the <code>tf.keras.Model.evaluate()</code> method.</p> <p>How about we try it on our <code>model_0</code>?</p> <p>We'll save the outputs to a <code>model_0_results</code> variable so we can use them later.</p>"},{"location":"end-to-end-dog-vision-v2/#9-model-1-train-a-model-on-100-of-the-training-data","title":"9. Model 1 - Train a model on 100% of the training data\u00b6","text":"<p>Time to step it up a notch!</p> <p>We've trained a model on 10% of the training data (to see if it works and it did!), now let's train a model on 100% of the training data and see what happens.</p> <p>But before we do...</p> <p>What do you think will happen?</p> <p>If our model was able to perform well on only 10% of the data, how do you think it will go on 100% of the data?</p> <p>These types of questions are good to think about in the world of machine learning.</p> <p>After all, that's why the machine learner's motto is experiment, experiment, experiment!</p> <p>Let's follow our three steps from before:</p> <ol> <li>Create a model (using our <code>create_model()</code>) function.</li> <li>Compile our model (selecting our optimizer, loss function and evaluation metric).</li> <li>Fit our model (this time on 100% of the data for 5 epochs).</li> </ol> <p>Note: Fitting our model on such a large amount of data will take a long time without a GPU. If you're using Google Colab, you can access a GPU via Runtime -&gt; Change runtime type -&gt; Hardware accelerator -&gt; GPU.</p>"},{"location":"end-to-end-dog-vision-v2/#evaluate-model-1-on-the-test-data","title":"Evaluate Model 1 on the test data\u00b6","text":"<p>How about we evaluate our <code>model_1</code>?</p> <p>Let's first by plotting loss curves with the data contained within <code>history_1</code>.</p>"},{"location":"end-to-end-dog-vision-v2/#10-make-and-evaluate-predictions-of-the-best-model","title":"10. Make and evaluate predictions of the best model\u00b6","text":"<p>Now we've trained a model, it's time to make predictions with it!</p> <p>That's the whole goal of machine learning.</p> <p>Train a model on existing data, to make predictions on new data.</p> <p>Our test data is supposed to simulate new data, data our model has never seen before.</p> <p>We can make predictions with the <code>tf.keras.Model.predict()</code> method, passing it our <code>test_ds</code> (short for test dataset) variable.</p>"},{"location":"end-to-end-dog-vision-v2/#visualizing-predictions-from-our-best-trained-model","title":"Visualizing predictions from our best trained model\u00b6","text":"<p>We could sit there looking at single image predictions of dogs all day.</p> <p>Or we could write code to look at multiple at a time...</p> <p>Let's do the latter!</p>"},{"location":"end-to-end-dog-vision-v2/#finding-the-accruacy-per-class","title":"Finding the accruacy per class\u00b6","text":"<p>Our model's overall accuracy is ~90%.</p> <p>This is an outstanding result.</p> <p>But what about the accuracy per class?</p> <p>As in, how did the <code>boxer</code> class perform?</p> <p>Or the <code>australian_terrier</code>?</p> <p>You'll see on the original Stanford Dogs Dataset website that the authors reported the accuracy per class of each of the dog breeds. Their best performing class, <code>african_hunting_dog</code> achieved close to 60% accuracy (about ~58% if I'm reading the graph correctly).</p> <p></p> <p>Results from the original Stanford Dogs Dataset paper (2011). Let's see if the model we trained performs better than it.</p> <p>How about we try and replicate the same plot with our own results?</p> <p>First, let's create a DataFrame with information about our test predictions and test samples.</p> <p>We'll start by getting the argmax of the test predictions as well as the test labels.</p> <p>Then we'll get the maximum prediction probabilities for each sample.</p> <p>And then we'll put it all into a DataFrame!</p>"},{"location":"end-to-end-dog-vision-v2/#finding-the-most-wrong-examples","title":"Finding the most wrong examples\u00b6","text":"<p>A great way to inspect your models errors is to find the examples where the prediction had a high probability but the prediction was wrong.</p> <p>This is often called the \"most wrong\" samples.</p> <p>As in the model was very confident but wrong.</p> <p>Let's filter for the top 100 most wrong by sorting the incorrect predictions by the <code>\"test_pred_prob\"</code> column.</p>"},{"location":"end-to-end-dog-vision-v2/#create-a-confusion-matrix","title":"Create a confusion matrix\u00b6","text":"<p>A confusion matrix helps to visualize which classes a predicted compared to which classes it should've predicted (truth vs. predictions).</p> <p>We can create one using Scikit-Learn's <code>sklearn.metrics.confusion_matrix</code> and passing in our <code>y_true</code> and <code>y_pred</code> values.</p> <p>And then we can display it using <code>sklearn.metrics.ConfusionMatrixDisplay</code>.</p> <p>Note: Since we have 120 different classes, running the code bellow to show the confusion matrix plot may take a minute or so to load (it's quite a big plot!).</p>"},{"location":"end-to-end-dog-vision-v2/#11-save-and-load-the-best-model","title":"11. Save and load the best model\u00b6","text":"<p>We've covered a lot of ground from loading data to training and evaluating a model.</p> <p>But what if you wanted to use that model somewhere else?</p> <p>Such as on a website or in an application?</p> <p>The first step is saving it to file.</p> <p>We can save our model using the <code>tf.keras.Model.save()</code> method and specifying the <code>filepath</code> as well as the <code>save_format</code> parameters.</p> <p>We'll use <code>filepath=\"dog_vision_model.keras\"</code> as well as <code>save_format=\"keras'</code> to save our model to the new and versatile <code>.keras</code> format.</p> <p>Let's save our best performing <code>model_1</code>.</p> <p>Note: You may also see models being saved with the <code>SavedModel</code> format as well as <code>HDF5</code> formats, however, it's recommended to use the newer <code>.keras</code> format. See the TensorFlow documentation on saving and loading a model for more.</p>"},{"location":"end-to-end-dog-vision-v2/#12-make-predictions-on-custom-images-with-the-best-model","title":"12. Make predictions on custom images with the best model\u00b6","text":"<p>Now what fun would it be if we only made predictions on the test dataset?</p> <p>How about we see how our model goes on real world images?</p> <p>That's the whole goal of machine learning right? To see how your model goes in the real world?</p> <p>Well, let's make some predictions on custom images!</p> <p>Specifically, let's try our best model on images of my dogs (Bella \ud83d\udc36 and Seven 7\ufe0f\u20e3, yes, Seven is her actual name) and an extra wildcard image.</p> <p>We can download the photos from the course GitHub.</p>"},{"location":"end-to-end-dog-vision-v2/#13-key-takeaways","title":"13. Key Takeaways\u00b6","text":"<ul> <li>Data, data, data! In any machine learning problem, getting a dataset and preparing it so that it is in a usable format will likely be the first and often most important step (hence why we spent so much time getting the data ready). It will also be an ongoing process, as although we've worked with thousands of dog images, our models could still be improved. And as we saw going from training with 10% of the data to 100% of the data, one of the best ways to improve a model is with more data. Explore your data early and often.</li> <li>When starting out, use transfer learning where possible. For most new problems, you should generally look to see if a pretrained model exists and see if you can adapt it to your use case. Ask yourself: What format is my data in? What are my ideal inputs and outputs? Is there a pretrained model for my use case?</li> <li>TensorFlow and Keras provide building blocks for neural networks which are powerful machine learning models capable of learning patterns in a wide range of data from text to audio to images and more.</li> <li>Experiment, experiment, experiment! It's highly unlikely you'll ever get the best performing model on your first try. Machine learning is very experimental by nature. This includes experimenting on the data, the model, the training setup and the outputs (how does your model work in practice?). Always keep this front of mind in any machine learning project. Your results are never stationary and can often always be improved.</li> </ul>"},{"location":"end-to-end-dog-vision-v2/#extensions-exercises","title":"Extensions &amp; Exercises\u00b6","text":"<p>The following are a series of exercises and extensions which build on what we've covered throughout this module.</p> <p>I'd highly recommend going thorugh each one and spending time practicing what you've learned.</p> <p>This is where the real knowledge is built. Trying things out for yourself.</p> <ol> <li>Try a prediction with our trained model on your own images of dogs and see if the model is correct.</li> <li>Try training another model from <code>tf.keras.applications</code> (e.g. ConvNeXt) and see if it performs better than EfficientNetV2.</li> <li>Try training a model on your own images in different classes, for example, apple vs. banana vs. orange. You could download images from the internet and sort them into different folders and then load them how we've done in the data loading section. Or you could take photos of your own and build a model to differentiate between them.</li> <li>For more advanced model training, you may want to look into the concept of \"Callbacks\", these are functions which run during the model training. TensorFlow and Keras have a series of built-in callbacks which can be helpful for training. Have a read of the <code>tf.keras.callbacks.Callback</code> documentation and see which ones may be useful to you.</li> <li>We touched on the concept of overfitting when we trained our model. This is when a model performs far better on the training set than on the test set. The concept of trying to prevent overfitting is known as regularization. Spend 20-minutes researching \"ways to prevent overfitting\" and write a list of 2-3 techniques and how they might come into play with our model training. Tip: One of the most common regularization techniques in computer vision is data augmentation (also see the brief example below).</li> <li>One of the most important parts of machine learning is having good data. The next most important part is loading that data in a way that can used to train models as fast and efficiently as possible. For more on this, I'd highly recommend reading more about the <code>tf.data</code> API (this API is TensorFlow focused, however, the concepts can be bridged to other dataloading needs) as well as reviewing the <code>tf.data</code> best practices (better performance with the <code>tf.data</code> API).</li> <li>Right now our model works well, however, we have to write code to interact with it. You could turn it into a small machine learning app using Gradio so people can upload their own images of dogs and see what the model predicts. See the example for image classification with TensorFlow and Keras for an idea of what you could build. See an example of this below as well as a running demo of Dog Vision on Hugging Face.</li> </ol> <p>In this project we've only really scratched the surface of what's possible with TensorFlow/Keras and deep learning.</p> <p>For a more comprehensive overview of TensorFlow/Keras, see the following:</p> <ul> <li>14-hour TensorFlow Tutorial on YouTube (this is the first 14 hours of the ZTM TensorFlow course).</li> <li>Zero to Mastery TensorFlow for Deep Learning course (a 50+ hour course diving into many applications of TensorFlow and deep learning).</li> </ul>"},{"location":"end-to-end-dog-vision-v2/#extension-example-data-augmentation","title":"Extension example: data augmentation\u00b6","text":"<p>Data augmentation is a regularization technique to help prevent overfitting.</p> <p>It's designed to alter training images to artifically increase the diversity of the training dataset and hopefully help to generalize better to test images as well as real-life images.</p> <p>For example, we want our models to be able to identify the same breed of dog in an image regardless if the dog is facing left or right.</p> <p>So one simple data augmentation technique is to randomly flip the image horizontally so the model learns to recognize the same dog from different points of view.</p> <p>You can repeat this for many different types of image modifications such as rotation, zone, colour alterations and more.</p> <p>The following code is a brief example of how to incorporate a data augmentation layer into a model (note that in practice data augmentation is only applied during training time and not during testing/prediction time, this is set automatically within layers aimed at data augmentation).</p> <p>For more, see the TensorFlow guide on data augmentation.</p>"},{"location":"end-to-end-dog-vision-v2/#extension-example-gradio-app-demo","title":"Extension Example: Gradio App Demo\u00b6","text":"<p>This is a modified version of the Gradio Image Classification Tutorial with TensorFlow and Keras.</p> <p>You can see a guide on Hugging Face for how to host it on Hugging Face Spaces (a place where you can host and share your machine learning apps).</p> <p>First we'll install Gradio.</p>"},{"location":"end-to-end-heart-disease-classification/","title":"End-to-End Heart Disease Classification","text":"<p>View source code | Read notebook in online book format</p> In\u00a0[1]: Copied! <pre># Regular EDA and plotting libraries\nimport numpy as np # np is short for numpy\n\nimport pandas as pd # pandas is so commonly used, it's shortened to pd\n\nimport matplotlib\nimport matplotlib.pyplot as plt\n\nimport seaborn as sns # seaborn gets shortened to sns, TK - can seaborn be removed for matplotlib (simpler)?\n\n## Models\nimport sklearn \nfrom sklearn.linear_model import LogisticRegression\nfrom sklearn.neighbors import KNeighborsClassifier\nfrom sklearn.ensemble import RandomForestClassifier\n\n## Model evaluators\nfrom sklearn.model_selection import train_test_split, cross_val_score\nfrom sklearn.model_selection import RandomizedSearchCV, GridSearchCV\nfrom sklearn.metrics import confusion_matrix, classification_report\nfrom sklearn.metrics import precision_score, recall_score, f1_score\n# from sklearn.metrics import plot_roc_curve # note: this was changed in Scikit-Learn 1.2+ to be \"RocCurveDisplay\" (see below)\nfrom sklearn.metrics import RocCurveDisplay # new in Scikit-Learn 1.2+\n\n# Print last updated\nimport datetime\nprint(f\"Notebook last updated: {datetime.datetime.now()}\\n\")\n\n# Print versions of libraries we're using (as long as yours are equal or greater than these, your code should work)\nprint(f\"NumPy version: {np.__version__}\")\nprint(f\"pandas version: {pd.__version__}\")\nprint(f\"matplotlib version: {matplotlib.__version__}\")\nprint(f\"Scikit-Learn version: {sklearn.__version__}\")\n</pre> # Regular EDA and plotting libraries import numpy as np # np is short for numpy  import pandas as pd # pandas is so commonly used, it's shortened to pd  import matplotlib import matplotlib.pyplot as plt  import seaborn as sns # seaborn gets shortened to sns, TK - can seaborn be removed for matplotlib (simpler)?  ## Models import sklearn  from sklearn.linear_model import LogisticRegression from sklearn.neighbors import KNeighborsClassifier from sklearn.ensemble import RandomForestClassifier  ## Model evaluators from sklearn.model_selection import train_test_split, cross_val_score from sklearn.model_selection import RandomizedSearchCV, GridSearchCV from sklearn.metrics import confusion_matrix, classification_report from sklearn.metrics import precision_score, recall_score, f1_score # from sklearn.metrics import plot_roc_curve # note: this was changed in Scikit-Learn 1.2+ to be \"RocCurveDisplay\" (see below) from sklearn.metrics import RocCurveDisplay # new in Scikit-Learn 1.2+  # Print last updated import datetime print(f\"Notebook last updated: {datetime.datetime.now()}\\n\")  # Print versions of libraries we're using (as long as yours are equal or greater than these, your code should work) print(f\"NumPy version: {np.__version__}\") print(f\"pandas version: {pd.__version__}\") print(f\"matplotlib version: {matplotlib.__version__}\") print(f\"Scikit-Learn version: {sklearn.__version__}\") <pre>Notebook last updated: 2024-09-24 13:29:26.771285\n\nNumPy version: 2.1.1\npandas version: 2.2.2\nmatplotlib version: 3.9.2\nScikit-Learn version: 1.5.1\n</pre> In\u00a0[2]: Copied! <pre>df = pd.read_csv(\"https://raw.githubusercontent.com/mrdbourke/zero-to-mastery-ml/master/data/heart-disease.csv\")\n# df = pd.read_csv(\"../data/heart-disease.csv\") # Read from local directory, 'DataFrame' shortened to 'df'\ndf.shape # (rows, columns)\n</pre> df = pd.read_csv(\"https://raw.githubusercontent.com/mrdbourke/zero-to-mastery-ml/master/data/heart-disease.csv\") # df = pd.read_csv(\"../data/heart-disease.csv\") # Read from local directory, 'DataFrame' shortened to 'df' df.shape # (rows, columns) Out[2]: <pre>(303, 14)</pre> In\u00a0[3]: Copied! <pre># Check the head of our DataFrame\ndf.head()\n</pre> # Check the head of our DataFrame df.head() Out[3]: age sex cp trestbps chol fbs restecg thalach exang oldpeak slope ca thal target 0 63 1 3 145 233 1 0 150 0 2.3 0 0 1 1 1 37 1 2 130 250 0 1 187 0 3.5 0 0 2 1 2 41 0 1 130 204 0 0 172 0 1.4 2 0 2 1 3 56 1 1 120 236 0 1 178 0 0.8 2 0 2 1 4 57 0 0 120 354 0 1 163 1 0.6 2 0 2 1 <p>Wonderful! We've got some data to work with. Notice how all the column names reflect a field in our data dicitonary above.</p> In\u00a0[4]: Copied! <pre># Let's check the top 5 rows of our dataframe\ndf.head()\n</pre> # Let's check the top 5 rows of our dataframe df.head() Out[4]: age sex cp trestbps chol fbs restecg thalach exang oldpeak slope ca thal target 0 63 1 3 145 233 1 0 150 0 2.3 0 0 1 1 1 37 1 2 130 250 0 1 187 0 3.5 0 0 2 1 2 41 0 1 130 204 0 0 172 0 1.4 2 0 2 1 3 56 1 1 120 236 0 1 178 0 0.8 2 0 2 1 4 57 0 0 120 354 0 1 163 1 0.6 2 0 2 1 In\u00a0[5]: Copied! <pre># And the top 10\ndf.head(10)\n</pre> # And the top 10 df.head(10) Out[5]: age sex cp trestbps chol fbs restecg thalach exang oldpeak slope ca thal target 0 63 1 3 145 233 1 0 150 0 2.3 0 0 1 1 1 37 1 2 130 250 0 1 187 0 3.5 0 0 2 1 2 41 0 1 130 204 0 0 172 0 1.4 2 0 2 1 3 56 1 1 120 236 0 1 178 0 0.8 2 0 2 1 4 57 0 0 120 354 0 1 163 1 0.6 2 0 2 1 5 57 1 0 140 192 0 1 148 0 0.4 1 0 1 1 6 56 0 1 140 294 0 0 153 0 1.3 1 0 2 1 7 44 1 1 120 263 0 1 173 0 0.0 2 0 3 1 8 52 1 2 172 199 1 1 162 0 0.5 2 0 3 1 9 57 1 2 150 168 0 1 174 0 1.6 2 0 2 1 <p><code>value_counts()</code> allows you to show how many times each of the values of a categorical column appear.</p> In\u00a0[6]: Copied! <pre># Let's see how many positive (1) and negative (0) samples we have in our DataFrame\ndf.target.value_counts()\n</pre> # Let's see how many positive (1) and negative (0) samples we have in our DataFrame df.target.value_counts() Out[6]: <pre>target\n1    165\n0    138\nName: count, dtype: int64</pre> <p>Since these two values are close to even, our <code>target</code> column can be considered balanced.</p> <p>An unbalanced target column, meaning some classes have far more samples, can be harder to model than a balanced set.</p> <p>In an ideal world, all of your target classes have the same number of samples.</p> <p>If you'd prefer these values in percentages, <code>value_counts()</code> takes a parameter, <code>normalize</code> which can be set to true.</p> In\u00a0[7]: Copied! <pre># Normalized value counts\ndf.target.value_counts(normalize=True)\n</pre> # Normalized value counts df.target.value_counts(normalize=True) Out[7]: <pre>target\n1    0.544554\n0    0.455446\nName: proportion, dtype: float64</pre> <p>We can plot the target column value counts by calling the <code>plot()</code> function and telling it what kind of plot we'd like, in this case, bar is good.</p> In\u00a0[8]: Copied! <pre># Plot the value counts with a bar graph\ndf.target.value_counts().plot(kind=\"bar\", color=[\"salmon\", \"lightblue\"]);\n</pre> # Plot the value counts with a bar graph df.target.value_counts().plot(kind=\"bar\", color=[\"salmon\", \"lightblue\"]); <p><code>pd.DataFrame.info()</code> shows a quick insight into the number of missing values you have and what type of data you're working with.</p> <p>In our case, there are no missing values and all of our columns are numerical in nature.</p> In\u00a0[9]: Copied! <pre>df.info()\n</pre> df.info() <pre>&lt;class 'pandas.core.frame.DataFrame'&gt;\nRangeIndex: 303 entries, 0 to 302\nData columns (total 14 columns):\n #   Column    Non-Null Count  Dtype  \n---  ------    --------------  -----  \n 0   age       303 non-null    int64  \n 1   sex       303 non-null    int64  \n 2   cp        303 non-null    int64  \n 3   trestbps  303 non-null    int64  \n 4   chol      303 non-null    int64  \n 5   fbs       303 non-null    int64  \n 6   restecg   303 non-null    int64  \n 7   thalach   303 non-null    int64  \n 8   exang     303 non-null    int64  \n 9   oldpeak   303 non-null    float64\n 10  slope     303 non-null    int64  \n 11  ca        303 non-null    int64  \n 12  thal      303 non-null    int64  \n 13  target    303 non-null    int64  \ndtypes: float64(1), int64(13)\nmemory usage: 33.3 KB\n</pre> <p>Another way to get quick insights on your DataFrame is to use <code>pd.DataFrame.describe()</code>.</p> <p><code>describe()</code> shows a range of different metrics about your numerical columns such as mean, max and standard deviation.</p> In\u00a0[10]: Copied! <pre>df.describe()\n</pre> df.describe() Out[10]: age sex cp trestbps chol fbs restecg thalach exang oldpeak slope ca thal target count 303.000000 303.000000 303.000000 303.000000 303.000000 303.000000 303.000000 303.000000 303.000000 303.000000 303.000000 303.000000 303.000000 303.000000 mean 54.366337 0.683168 0.966997 131.623762 246.264026 0.148515 0.528053 149.646865 0.326733 1.039604 1.399340 0.729373 2.313531 0.544554 std 9.082101 0.466011 1.032052 17.538143 51.830751 0.356198 0.525860 22.905161 0.469794 1.161075 0.616226 1.022606 0.612277 0.498835 min 29.000000 0.000000 0.000000 94.000000 126.000000 0.000000 0.000000 71.000000 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000 25% 47.500000 0.000000 0.000000 120.000000 211.000000 0.000000 0.000000 133.500000 0.000000 0.000000 1.000000 0.000000 2.000000 0.000000 50% 55.000000 1.000000 1.000000 130.000000 240.000000 0.000000 1.000000 153.000000 0.000000 0.800000 1.000000 0.000000 2.000000 1.000000 75% 61.000000 1.000000 2.000000 140.000000 274.500000 0.000000 1.000000 166.000000 1.000000 1.600000 2.000000 1.000000 3.000000 1.000000 max 77.000000 1.000000 3.000000 200.000000 564.000000 1.000000 2.000000 202.000000 1.000000 6.200000 2.000000 4.000000 3.000000 1.000000 In\u00a0[11]: Copied! <pre>df.sex.value_counts()\n</pre> df.sex.value_counts() Out[11]: <pre>sex\n1    207\n0     96\nName: count, dtype: int64</pre> <p>There are 207 males and 96 females in our study.</p> <p>What if we compared the target column values with the sex column values?</p> In\u00a0[12]: Copied! <pre># Compare target column with sex column\npd.crosstab(index=df.target, columns=df.sex)\n</pre> # Compare target column with sex column pd.crosstab(index=df.target, columns=df.sex) Out[12]: sex 0 1 target 0 24 114 1 72 93 <p>What can we infer from this? Let's make a simple heuristic.</p> <p>Since there are about 100 women and 72 of them have a positive value of heart disease being present, we might infer, based on this one variable if the participant is a woman, there's a ~72% (72/96 women in our dataset are positive for heart disease) chance she has heart disease.</p> <p>As for males, there's about 200 total with around half (93/207) indicating a presence of heart disease.</p> <p>So we might predict, if the participant is male, 50% of the time he will have heart disease.</p> <p>Averaging these two values, we can assume, based on no other parameters, if there's a person, there's a 62.5% chance they have heart disease.</p> <p>This can be our very simple baseline, we'll try to beat it with machine learning.</p> <p>Note: A baseline is a simple model or estimate you start with and try to beat/confirm throughout your experiments. It can be as simple as looking at the data as we've done and creating a predictive heuristic to move forward.</p> In\u00a0[13]: Copied! <pre># Create a plot\npd.crosstab(df.target, df.sex).plot(kind=\"bar\", \n                                    figsize=(10,6), \n                                    color=[\"salmon\", \"lightblue\"]);\n</pre> # Create a plot pd.crosstab(df.target, df.sex).plot(kind=\"bar\",                                      figsize=(10,6),                                      color=[\"salmon\", \"lightblue\"]); <p>Nice! But our plot is looking pretty bare. Let's add some attributes.</p> <p>We'll create the plot again with <code>pd.crosstab()</code> and the <code>plot()</code> method.</p> <p>Then, since our plot is built with <code>matplotlib</code>, we can add some helpful labels to it with <code>plt.title()</code>, <code>plt.xlabel()</code>, <code>plt.legend()</code> and more.</p> In\u00a0[14]: Copied! <pre># Create a plot\npd.crosstab(df.target, df.sex).plot(kind=\"bar\", figsize=(10,6), color=[\"salmon\", \"lightblue\"])\n\n# Add some attributes to it\nplt.title(\"Heart Disease Frequency vs Sex\")\nplt.xlabel(\"0 = No Disease, 1 = Disease\")\nplt.ylabel(\"Amount\")\nplt.legend([\"Female\", \"Male\"])\nplt.xticks(rotation=0); # keep the labels on the x-axis vertical\n</pre> # Create a plot pd.crosstab(df.target, df.sex).plot(kind=\"bar\", figsize=(10,6), color=[\"salmon\", \"lightblue\"])  # Add some attributes to it plt.title(\"Heart Disease Frequency vs Sex\") plt.xlabel(\"0 = No Disease, 1 = Disease\") plt.ylabel(\"Amount\") plt.legend([\"Female\", \"Male\"]) plt.xticks(rotation=0); # keep the labels on the x-axis vertical In\u00a0[15]: Copied! <pre># Create another figure\nplt.figure(figsize=(10,6))\n\n# Start with positve examples\nplt.scatter(df.age[df.target==1], \n            df.thalach[df.target==1], \n            c=\"salmon\") # define it as a scatter figure\n\n# Now for negative examples, we want them on the same plot, so we call plt again\nplt.scatter(df.age[df.target==0], \n            df.thalach[df.target==0], \n            c=\"lightblue\") # axis always come as (x, y)\n\n# Add some helpful info\nplt.title(\"Heart Disease in function of Age and Max Heart Rate\")\nplt.xlabel(\"Age\")\nplt.legend([\"Disease\", \"No Disease\"])\nplt.ylabel(\"Max Heart Rate\");\n</pre> # Create another figure plt.figure(figsize=(10,6))  # Start with positve examples plt.scatter(df.age[df.target==1],              df.thalach[df.target==1],              c=\"salmon\") # define it as a scatter figure  # Now for negative examples, we want them on the same plot, so we call plt again plt.scatter(df.age[df.target==0],              df.thalach[df.target==0],              c=\"lightblue\") # axis always come as (x, y)  # Add some helpful info plt.title(\"Heart Disease in function of Age and Max Heart Rate\") plt.xlabel(\"Age\") plt.legend([\"Disease\", \"No Disease\"]) plt.ylabel(\"Max Heart Rate\"); <p>What can we infer from this?</p> <p>It seems the younger someone is, the higher their max heart rate (dots are higher on the left of the graph) and it seems there may be more heart disease in the younger population too (more orange dots).</p> <p>Both of these are observational of course, but this is what we're trying to do, build an understanding of the data.</p> <p>Let's check the age distribution.</p> <p>Note: Distribution can considered as the spread of data. As in, when viewed as a whole, what different values appear in the data?</p> In\u00a0[16]: Copied! <pre># Histograms are a great way to check the distribution of a variable\ndf.age.plot.hist();\n</pre> # Histograms are a great way to check the distribution of a variable df.age.plot.hist(); <p>We can see it's a normal distribution but slightly swaying to the right, which reflects in the scatter plot above.</p> <p>Let's keep going.</p> In\u00a0[17]: Copied! <pre>pd.crosstab(index=df.cp, columns=df.target)\n</pre> pd.crosstab(index=df.cp, columns=df.target) Out[17]: target 0 1 cp 0 104 39 1 9 41 2 18 69 3 7 16 In\u00a0[18]: Copied! <pre># Create a new crosstab and base plot\npd.crosstab(df.cp, df.target).plot(kind=\"bar\", \n                                   figsize=(10,6), \n                                   color=[\"lightblue\", \"salmon\"])\n\n# Add attributes to the plot to make it more readable\nplt.title(\"Heart Disease Frequency Per Chest Pain Type\")\nplt.xlabel(\"Chest Pain Type\")\nplt.ylabel(\"Frequency\")\nplt.legend([\"No Disease\", \"Disease\"])\nplt.xticks(rotation = 0);\n</pre> # Create a new crosstab and base plot pd.crosstab(df.cp, df.target).plot(kind=\"bar\",                                     figsize=(10,6),                                     color=[\"lightblue\", \"salmon\"])  # Add attributes to the plot to make it more readable plt.title(\"Heart Disease Frequency Per Chest Pain Type\") plt.xlabel(\"Chest Pain Type\") plt.ylabel(\"Frequency\") plt.legend([\"No Disease\", \"Disease\"]) plt.xticks(rotation = 0); <p>What can we infer from this?</p> <p>Remember from our data dictionary what the different levels of chest pain are.</p> Feature Description Example Values cp Chest pain type 0: Typical angina (chest pain), 1: Atypical angina (chest pain not related to heart), 2: Non-anginal pain (typically esophageal spasms (non heart related), 3: Asymptomatic (chest pain not showing signs of disease) <p>It's interesting that atypical angina (value 1) states it's not related to the heart but seems to have a higher ratio of participants with heart disease than not.</p> <p>Wait...?</p> <p>What does atypical agina even mean?</p> <p>At this point, it's important to remember, if your data dictionary doesn't supply you enough information, you may want to do further research on your values.</p> <p>This research may come in the form of asking a subject matter expert (such as a cardiologist or the person who gave you the data) or Googling to find out more.</p> <p>According to PubMed, it seems even some medical professionals are confused by the term.</p> <p>Today, 23 years later, \u201catypical chest pain\u201d is still popular in medical circles. Its meaning, however, remains unclear. A few articles have the term in their title, but do not define or discuss it in their text. In other articles, the term refers to noncardiac causes of chest pain.</p> <p>Although not conclusive, the plot above is a sign there may be a confusion of defintions being represented in data.</p> In\u00a0[19]: Copied! <pre># Find the correlation between our independent variables\ncorr_matrix = df.corr()\ncorr_matrix\n</pre> # Find the correlation between our independent variables corr_matrix = df.corr() corr_matrix  Out[19]: age sex cp trestbps chol fbs restecg thalach exang oldpeak slope ca thal target age 1.000000 -0.098447 -0.068653 0.279351 0.213678 0.121308 -0.116211 -0.398522 0.096801 0.210013 -0.168814 0.276326 0.068001 -0.225439 sex -0.098447 1.000000 -0.049353 -0.056769 -0.197912 0.045032 -0.058196 -0.044020 0.141664 0.096093 -0.030711 0.118261 0.210041 -0.280937 cp -0.068653 -0.049353 1.000000 0.047608 -0.076904 0.094444 0.044421 0.295762 -0.394280 -0.149230 0.119717 -0.181053 -0.161736 0.433798 trestbps 0.279351 -0.056769 0.047608 1.000000 0.123174 0.177531 -0.114103 -0.046698 0.067616 0.193216 -0.121475 0.101389 0.062210 -0.144931 chol 0.213678 -0.197912 -0.076904 0.123174 1.000000 0.013294 -0.151040 -0.009940 0.067023 0.053952 -0.004038 0.070511 0.098803 -0.085239 fbs 0.121308 0.045032 0.094444 0.177531 0.013294 1.000000 -0.084189 -0.008567 0.025665 0.005747 -0.059894 0.137979 -0.032019 -0.028046 restecg -0.116211 -0.058196 0.044421 -0.114103 -0.151040 -0.084189 1.000000 0.044123 -0.070733 -0.058770 0.093045 -0.072042 -0.011981 0.137230 thalach -0.398522 -0.044020 0.295762 -0.046698 -0.009940 -0.008567 0.044123 1.000000 -0.378812 -0.344187 0.386784 -0.213177 -0.096439 0.421741 exang 0.096801 0.141664 -0.394280 0.067616 0.067023 0.025665 -0.070733 -0.378812 1.000000 0.288223 -0.257748 0.115739 0.206754 -0.436757 oldpeak 0.210013 0.096093 -0.149230 0.193216 0.053952 0.005747 -0.058770 -0.344187 0.288223 1.000000 -0.577537 0.222682 0.210244 -0.430696 slope -0.168814 -0.030711 0.119717 -0.121475 -0.004038 -0.059894 0.093045 0.386784 -0.257748 -0.577537 1.000000 -0.080155 -0.104764 0.345877 ca 0.276326 0.118261 -0.181053 0.101389 0.070511 0.137979 -0.072042 -0.213177 0.115739 0.222682 -0.080155 1.000000 0.151832 -0.391724 thal 0.068001 0.210041 -0.161736 0.062210 0.098803 -0.032019 -0.011981 -0.096439 0.206754 0.210244 -0.104764 0.151832 1.000000 -0.344029 target -0.225439 -0.280937 0.433798 -0.144931 -0.085239 -0.028046 0.137230 0.421741 -0.436757 -0.430696 0.345877 -0.391724 -0.344029 1.000000 <p>Following the data explorer's motto of visualize, visualize, visualize!, let's plot this matrix.</p> In\u00a0[20]: Copied! <pre># Let's make it look a little prettier\ncorr_matrix = df.corr()\nplt.figure(figsize=(15, 10))\nsns.heatmap(corr_matrix, \n            annot=True, \n            linewidths=0.5, \n            fmt= \".2f\", \n            cmap=\"YlGnBu\");\n</pre> # Let's make it look a little prettier corr_matrix = df.corr() plt.figure(figsize=(15, 10)) sns.heatmap(corr_matrix,              annot=True,              linewidths=0.5,              fmt= \".2f\",              cmap=\"YlGnBu\"); <p>Much better. A higher positive value means a potential positive correlation (increase) and a higher negative value means a potential negative correlation (decrease).</p> In\u00a0[21]: Copied! <pre>df.head()\n</pre> df.head() Out[21]: age sex cp trestbps chol fbs restecg thalach exang oldpeak slope ca thal target 0 63 1 3 145 233 1 0 150 0 2.3 0 0 1 1 1 37 1 2 130 250 0 1 187 0 3.5 0 0 2 1 2 41 0 1 130 204 0 0 172 0 1.4 2 0 2 1 3 56 1 1 120 236 0 1 178 0 0.8 2 0 2 1 4 57 0 0 120 354 0 1 163 1 0.6 2 0 2 1 <p>We're trying to predict our target variable using all of the other variables.</p> <p>To do this, we'll split the target variable from the rest.</p> <p>We can do this by creating:</p> <ul> <li><code>X</code> - Our features (all variables except the <code>target</code> column) using <code>pd.DataFrame.drop(labels=\"target\")</code>.</li> <li><code>y</code> - Our target variable using <code>df.target.to_numpy()</code> (this will extract the <code>target</code> column as a NumPy array).</li> </ul> In\u00a0[22]: Copied! <pre># Everything except target variable\nX = df.drop(labels=\"target\", axis=1)\n\n# Target variable\ny = df.target.to_numpy()\n</pre> # Everything except target variable X = df.drop(labels=\"target\", axis=1)  # Target variable y = df.target.to_numpy() <p>Let's see our new variables.</p> In\u00a0[23]: Copied! <pre># Independent variables (no target column)\nX.head()\n</pre> # Independent variables (no target column) X.head() Out[23]: age sex cp trestbps chol fbs restecg thalach exang oldpeak slope ca thal 0 63 1 3 145 233 1 0 150 0 2.3 0 0 1 1 37 1 2 130 250 0 1 187 0 3.5 0 0 2 2 41 0 1 130 204 0 0 172 0 1.4 2 0 2 3 56 1 1 120 236 0 1 178 0 0.8 2 0 2 4 57 0 0 120 354 0 1 163 1 0.6 2 0 2 In\u00a0[24]: Copied! <pre># Targets (in the form of a NumPy array)\ny, type(y)\n</pre> # Targets (in the form of a NumPy array) y, type(y) Out[24]: <pre>(array([1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]),\n numpy.ndarray)</pre> In\u00a0[25]: Copied! <pre># Random seed for reproducibility (since train_test_split is random by default, setting the seed will create reproducible splits)\nnp.random.seed(42)\n\n# Split into train &amp; test set\nX_train, X_test, y_train, y_test = train_test_split(X, # independent variables \n                                                    y, # dependent variable\n                                                    test_size = 0.2) # percentage of data to use for test set\n</pre> # Random seed for reproducibility (since train_test_split is random by default, setting the seed will create reproducible splits) np.random.seed(42)  # Split into train &amp; test set X_train, X_test, y_train, y_test = train_test_split(X, # independent variables                                                      y, # dependent variable                                                     test_size = 0.2) # percentage of data to use for test set <p>The <code>test_size</code> parameter is used to tell the <code>train_test_split()</code> function how much of our data we want in the test set.</p> <p>A rule of thumb is to use 80% of your data to train on and the other 20% to test on.</p> <p>For our problem, a train and test set are enough. But for other problems, you could also use a validation (train/validation/test) set or cross-validation (we'll see this later on).</p> <p>But again, each problem will differ.</p> <p>To learn more about the importance of validation and test sets, I'd recommend reading:</p> <ul> <li>How (and why) to create a good validation set by Rachel Thomas.</li> <li>The importance of a test set by Daniel Bourke.</li> </ul> <p>Let's look at our training data.</p> In\u00a0[26]: Copied! <pre>X_train.head()\n</pre> X_train.head() Out[26]: age sex cp trestbps chol fbs restecg thalach exang oldpeak slope ca thal 132 42 1 1 120 295 0 1 162 0 0.0 2 0 2 202 58 1 0 150 270 0 0 111 1 0.8 2 0 3 196 46 1 2 150 231 0 1 147 0 3.6 1 0 2 75 55 0 1 135 250 0 0 161 0 1.4 1 0 2 176 60 1 0 117 230 1 1 160 1 1.4 2 2 3 In\u00a0[27]: Copied! <pre>y_train, len(y_train)\n</pre> y_train, len(y_train) Out[27]: <pre>(array([1, 0, 0, 1, 0, 1, 1, 1, 0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 1, 1, 0, 1,\n        1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0,\n        1, 1, 1, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1,\n        0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 0,\n        0, 1, 1, 1, 1, 0, 1, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0,\n        1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1,\n        1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 1, 1, 0, 1, 0, 0, 1, 1, 1,\n        1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0, 0, 1, 0,\n        0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 1, 1, 0, 1, 0, 0, 0, 1, 1, 1, 1, 1,\n        1, 0, 1, 1, 1, 0, 0, 1, 1, 0, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1,\n        1, 0, 0, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 0, 1]),\n 242)</pre> <p>Beautiful, we can see we're using 242 samples to train on.</p> <p>Let's look at our test data.</p> In\u00a0[28]: Copied! <pre>X_test.head()\n</pre> X_test.head() Out[28]: age sex cp trestbps chol fbs restecg thalach exang oldpeak slope ca thal 179 57 1 0 150 276 0 0 112 1 0.6 1 1 1 228 59 1 3 170 288 0 0 159 0 0.2 1 0 3 111 57 1 2 150 126 1 1 173 0 0.2 2 1 3 246 56 0 0 134 409 0 0 150 1 1.9 1 2 3 60 71 0 2 110 265 1 0 130 0 0.0 2 1 2 In\u00a0[29]: Copied! <pre>y_test, len(y_test)\n</pre> y_test, len(y_test) Out[29]: <pre>(array([0, 0, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 0, 1, 0,\n        0, 1, 1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1,\n        1, 0, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0]),\n 61)</pre> <p>And we've got 61 examples we'll test our model(s) on.</p> <p>Let's build some.</p> In\u00a0[30]: Copied! <pre># Put models in a dictionary\nmodels = {\"KNN\": KNeighborsClassifier(),\n          \"Logistic Regression\": LogisticRegression(max_iter=100), # Note: if you see a warning about \"convergence not reached\", you can increase `max_iter` until convergence is reached\n          \"Random Forest\": RandomForestClassifier()}\n\n# Create function to fit and score models\ndef fit_and_score(models, X_train, X_test, y_train, y_test):\n    \"\"\"\n    Fits and evaluates given machine learning models.\n    models : a dict of different Scikit-Learn machine learning models\n    X_train : training data\n    X_test : testing data\n    y_train : labels assosciated with training data\n    y_test : labels assosciated with test data\n    \"\"\"\n    # Random seed for reproducible results\n    np.random.seed(42)\n    # Make a list to keep model scores\n    model_scores = {}\n    # Loop through models\n    for name, model in models.items():\n        # Fit the model to the data\n        model.fit(X_train, y_train)\n        # Evaluate the model and append its score to model_scores\n        model_scores[name] = model.score(X_test, y_test)\n    return model_scores\n</pre> # Put models in a dictionary models = {\"KNN\": KNeighborsClassifier(),           \"Logistic Regression\": LogisticRegression(max_iter=100), # Note: if you see a warning about \"convergence not reached\", you can increase `max_iter` until convergence is reached           \"Random Forest\": RandomForestClassifier()}  # Create function to fit and score models def fit_and_score(models, X_train, X_test, y_train, y_test):     \"\"\"     Fits and evaluates given machine learning models.     models : a dict of different Scikit-Learn machine learning models     X_train : training data     X_test : testing data     y_train : labels assosciated with training data     y_test : labels assosciated with test data     \"\"\"     # Random seed for reproducible results     np.random.seed(42)     # Make a list to keep model scores     model_scores = {}     # Loop through models     for name, model in models.items():         # Fit the model to the data         model.fit(X_train, y_train)         # Evaluate the model and append its score to model_scores         model_scores[name] = model.score(X_test, y_test)     return model_scores <p>Function built!</p> <p>Now let's see how our collection of models go on our data.</p> In\u00a0[31]: Copied! <pre>model_scores = fit_and_score(models=models,\n                             X_train=X_train,\n                             X_test=X_test,\n                             y_train=y_train,\n                             y_test=y_test)\nmodel_scores\n</pre> model_scores = fit_and_score(models=models,                              X_train=X_train,                              X_test=X_test,                              y_train=y_train,                              y_test=y_test) model_scores <pre>/Users/daniel/miniforge3/envs/ai/lib/python3.11/site-packages/sklearn/linear_model/_logistic.py:469: ConvergenceWarning: lbfgs failed to converge (status=1):\nSTOP: TOTAL NO. of ITERATIONS REACHED LIMIT.\n\nIncrease the number of iterations (max_iter) or scale the data as shown in:\n    https://scikit-learn.org/stable/modules/preprocessing.html\nPlease also refer to the documentation for alternative solver options:\n    https://scikit-learn.org/stable/modules/linear_model.html#logistic-regression\n  n_iter_i = _check_optimize_result(\n</pre> Out[31]: <pre>{'KNN': 0.6885245901639344,\n 'Logistic Regression': 0.8852459016393442,\n 'Random Forest': 0.8360655737704918}</pre> <p>Beautiful!</p> <p>It looks like each of our models was able to fit our data without any errors.</p> <p>How about we compare them visually?</p> In\u00a0[32]: Copied! <pre>model_compare = pd.DataFrame(model_scores, index=['accuracy'])\nmodel_compare.T.plot.bar();\n</pre> model_compare = pd.DataFrame(model_scores, index=['accuracy']) model_compare.T.plot.bar(); <p>Beautiful!</p> <p>From the plot it looks like the <code>sklearn.linear_model.LogisticRegression()</code> model performs best.</p> <p>Now... since we've found the best model.</p> <p>Let's take it to the boss and show her what we've found!</p> In\u00a0[33]: Copied! <pre># Create a list of train scores\ntrain_scores = []\n\n# Create a list of test scores\ntest_scores = []\n\n# Create a list of different values for n_neighbors\nneighbors = range(1, 21) # 1 to 20\n\n# Setup algorithm\nknn = KNeighborsClassifier()\n\n# Loop through different neighbors values\nfor i in neighbors:\n    knn.set_params(n_neighbors = i) # set neighbors value\n    \n    # Fit the algorithm\n    knn.fit(X_train, y_train)\n    \n    # Update the training scores\n    train_scores.append(knn.score(X_train, y_train))\n    \n    # Update the test scores\n    test_scores.append(knn.score(X_test, y_test))\n</pre> # Create a list of train scores train_scores = []  # Create a list of test scores test_scores = []  # Create a list of different values for n_neighbors neighbors = range(1, 21) # 1 to 20  # Setup algorithm knn = KNeighborsClassifier()  # Loop through different neighbors values for i in neighbors:     knn.set_params(n_neighbors = i) # set neighbors value          # Fit the algorithm     knn.fit(X_train, y_train)          # Update the training scores     train_scores.append(knn.score(X_train, y_train))          # Update the test scores     test_scores.append(knn.score(X_test, y_test)) <p>That was quick!</p> <p>Now let's look at KNN's train scores.</p> In\u00a0[34]: Copied! <pre>train_scores\n</pre> train_scores Out[34]: <pre>[1.0,\n 0.8099173553719008,\n 0.7727272727272727,\n 0.743801652892562,\n 0.7603305785123967,\n 0.7520661157024794,\n 0.743801652892562,\n 0.7231404958677686,\n 0.71900826446281,\n 0.6942148760330579,\n 0.7272727272727273,\n 0.6983471074380165,\n 0.6900826446280992,\n 0.6942148760330579,\n 0.6859504132231405,\n 0.6735537190082644,\n 0.6859504132231405,\n 0.6652892561983471,\n 0.6818181818181818,\n 0.6694214876033058]</pre> <p>Ok, these are a bit hard to understand, so let's follow the data explorer's motto and visualize, visualize, visualize! In other words, let's plot them.</p> In\u00a0[35]: Copied! <pre>plt.plot(neighbors, train_scores, label=\"Train score\")\nplt.plot(neighbors, test_scores, label=\"Test score\")\nplt.xticks(np.arange(1, 21, 1))\nplt.xlabel(\"Number of neighbors\")\nplt.ylabel(\"Model score\")\nplt.legend()\n\nprint(f\"Maximum KNN score on the test data: {max(test_scores)*100:.2f}%\")\n</pre> plt.plot(neighbors, train_scores, label=\"Train score\") plt.plot(neighbors, test_scores, label=\"Test score\") plt.xticks(np.arange(1, 21, 1)) plt.xlabel(\"Number of neighbors\") plt.ylabel(\"Model score\") plt.legend()  print(f\"Maximum KNN score on the test data: {max(test_scores)*100:.2f}%\") <pre>Maximum KNN score on the test data: 75.41%\n</pre> <p>Looking at the graph, <code>n_neighbors = 11</code> seems best.</p> <p>Even knowing this, the <code>KNN</code>'s model performance didn't get near what <code>LogisticRegression</code> or the <code>RandomForestClassifier</code> did.</p> <p>Because of this, we'll discard <code>KNN</code> and focus on the other two.</p> <p>We've tuned <code>KNN</code> by hand but let's see how we can <code>LogisticsRegression</code> and <code>RandomForestClassifier</code> using <code>RandomizedSearchCV</code>.</p> <p>Instead of us having to manually try different hyperparameters by hand, <code>RandomizedSearchCV</code> tries a number of different combinations, evaluates them and saves the best.</p> In\u00a0[37]: Copied! <pre># Different LogisticRegression hyperparameters\nlog_reg_grid = {\"C\": np.logspace(-4, 4, 20),\n                \"solver\": [\"liblinear\"]}\n\n# Different RandomForestClassifier hyperparameters\nrf_grid = {\"n_estimators\": np.arange(10, 1000, 50),\n           \"max_depth\": [None, 3, 5, 10],\n           \"min_samples_split\": np.arange(2, 20, 2),\n           \"min_samples_leaf\": np.arange(1, 20, 2)}\n</pre> # Different LogisticRegression hyperparameters log_reg_grid = {\"C\": np.logspace(-4, 4, 20),                 \"solver\": [\"liblinear\"]}  # Different RandomForestClassifier hyperparameters rf_grid = {\"n_estimators\": np.arange(10, 1000, 50),            \"max_depth\": [None, 3, 5, 10],            \"min_samples_split\": np.arange(2, 20, 2),            \"min_samples_leaf\": np.arange(1, 20, 2)} <p>Now let's use <code>sklearn.model_selection.RandomizedSearchCV</code> to try and tune our <code>LogisticRegression</code> model.</p> <p>We'll pass it the different hyperparameters from <code>log_reg_grid</code> as well as set <code>n_iter=20</code>. This means, <code>RandomizedSearchCV</code> will try 20 different combinations of hyperparameters from <code>log_reg_grid</code> and save the best ones.</p> In\u00a0[38]: Copied! <pre>%%time\n\n# Setup random seed\nnp.random.seed(42)\n\n# Setup random hyperparameter search for LogisticRegression\nrs_log_reg = RandomizedSearchCV(LogisticRegression(),\n                                param_distributions=log_reg_grid,\n                                cv=5,\n                                n_iter=20,\n                                verbose=True)\n\n# Fit random hyperparameter search model\nrs_log_reg.fit(X_train, y_train);\n</pre> %%time  # Setup random seed np.random.seed(42)  # Setup random hyperparameter search for LogisticRegression rs_log_reg = RandomizedSearchCV(LogisticRegression(),                                 param_distributions=log_reg_grid,                                 cv=5,                                 n_iter=20,                                 verbose=True)  # Fit random hyperparameter search model rs_log_reg.fit(X_train, y_train); <pre>Fitting 5 folds for each of 20 candidates, totalling 100 fits\nCPU times: user 160 ms, sys: 7.51 ms, total: 168 ms\nWall time: 193 ms\n</pre> In\u00a0[39]: Copied! <pre>rs_log_reg.best_params_\n</pre> rs_log_reg.best_params_ Out[39]: <pre>{'solver': 'liblinear', 'C': np.float64(0.23357214690901212)}</pre> In\u00a0[40]: Copied! <pre>rs_log_reg.score(X_test, y_test)\n</pre> rs_log_reg.score(X_test, y_test) Out[40]: <pre>0.8852459016393442</pre> <p>Nice! That seems on par with the result we got before without any hyperparameter tuning.</p> <p>Note: Many of the algorithms in Scikit-Learn have pretty good default hyperparameter values so don't be surprised if they perform pretty good on your data straight out of the box. But don't take this as being true all the time. Just because the default hyperparameters perform pretty well on your data doesn't mean there aren't a better set of hyperparameter values out there.</p> <p>Now we've tuned <code>LogisticRegression</code> using <code>RandomizedSearchCV</code>, we'll do the same for <code>RandomForestClassifier</code>.</p> In\u00a0[41]: Copied! <pre>%%time \n\n# Setup random seed\nnp.random.seed(42)\n\n# Setup random hyperparameter search for RandomForestClassifier\nrs_rf = RandomizedSearchCV(RandomForestClassifier(),\n                           param_distributions=rf_grid,\n                           cv=5,\n                           n_iter=20,\n                           verbose=True)\n\n# Fit random hyperparameter search model\nrs_rf.fit(X_train, y_train);\n</pre> %%time   # Setup random seed np.random.seed(42)  # Setup random hyperparameter search for RandomForestClassifier rs_rf = RandomizedSearchCV(RandomForestClassifier(),                            param_distributions=rf_grid,                            cv=5,                            n_iter=20,                            verbose=True)  # Fit random hyperparameter search model rs_rf.fit(X_train, y_train); <pre>Fitting 5 folds for each of 20 candidates, totalling 100 fits\nCPU times: user 21.6 s, sys: 144 ms, total: 21.8 s\nWall time: 22.1 s\n</pre> In\u00a0[50]: Copied! <pre># Find the best parameters\nrs_rf.best_params_\n</pre> # Find the best parameters rs_rf.best_params_ Out[50]: <pre>{'n_estimators': np.int64(210),\n 'min_samples_split': np.int64(4),\n 'min_samples_leaf': np.int64(19),\n 'max_depth': 3}</pre> In\u00a0[42]: Copied! <pre># Evaluate the randomized search random forest model\nrs_rf.score(X_test, y_test)\n</pre> # Evaluate the randomized search random forest model rs_rf.score(X_test, y_test) Out[42]: <pre>0.8688524590163934</pre> <p>Excellent! Tuning the hyperparameters for each model saw a slight performance boost in both the <code>RandomForestClassifier</code> and <code>LogisticRegression</code>.</p> <p>This is akin to tuning the settings on your oven and getting it to cook your favourite dish just right.</p> <p>But since <code>LogisticRegression</code> is pulling out in front, we'll try tuning it further with <code>GridSearchCV</code>.</p> In\u00a0[43]: Copied! <pre>%%time\n\n# Different LogisticRegression hyperparameters\nlog_reg_grid = {\"C\": np.logspace(-4, 4, 20),\n                \"solver\": [\"liblinear\"]}\n\n# Setup grid hyperparameter search for LogisticRegression\ngs_log_reg = GridSearchCV(LogisticRegression(),\n                          param_grid=log_reg_grid,\n                          cv=5,\n                          verbose=True)\n\n# Fit grid hyperparameter search model\ngs_log_reg.fit(X_train, y_train);\n</pre> %%time  # Different LogisticRegression hyperparameters log_reg_grid = {\"C\": np.logspace(-4, 4, 20),                 \"solver\": [\"liblinear\"]}  # Setup grid hyperparameter search for LogisticRegression gs_log_reg = GridSearchCV(LogisticRegression(),                           param_grid=log_reg_grid,                           cv=5,                           verbose=True)  # Fit grid hyperparameter search model gs_log_reg.fit(X_train, y_train); <pre>Fitting 5 folds for each of 20 candidates, totalling 100 fits\nCPU times: user 161 ms, sys: 2.41 ms, total: 163 ms\nWall time: 212 ms\n</pre> In\u00a0[44]: Copied! <pre># Check the best parameters\ngs_log_reg.best_params_\n</pre> # Check the best parameters gs_log_reg.best_params_ Out[44]: <pre>{'C': np.float64(0.23357214690901212), 'solver': 'liblinear'}</pre> In\u00a0[45]: Copied! <pre># Evaluate the model\ngs_log_reg.score(X_test, y_test)\n</pre> # Evaluate the model gs_log_reg.score(X_test, y_test) Out[45]: <pre>0.8852459016393442</pre> <p>In this case, we get the same results as before since our grid only has a maximum of 20 different hyperparameter combinations.</p> <p>Note: If there are a large number of hyperparameter combinations in your grid, <code>GridSearchCV</code> may take a long time to try them all out. This is why it's a good idea to start with <code>RandomizedSearchCV</code>, try a certain amount of combinations and then use <code>GridSearchCV</code> to refine them.</p> In\u00a0[46]: Copied! <pre># Make preidctions on test data\ny_preds = gs_log_reg.predict(X_test)\n</pre> # Make preidctions on test data y_preds = gs_log_reg.predict(X_test) <p>Let's see them.</p> In\u00a0[47]: Copied! <pre>y_preds\n</pre> y_preds Out[47]: <pre>array([0, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1, 0, 1, 0, 1, 1, 1, 0, 0, 0, 1, 0,\n       0, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1,\n       1, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0])</pre> <p>They look like our original test data labels, except different where the model has predicred wrong.</p> In\u00a0[48]: Copied! <pre>y_test\n</pre> y_test Out[48]: <pre>array([0, 0, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 0, 1, 0,\n       0, 1, 1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1,\n       1, 0, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0])</pre> <p>Since we've got our prediction values we can find the metrics we want.</p> <p>Let's start with the ROC curve and AUC scores.</p> In\u00a0[49]: Copied! <pre># Before Scikit-Learn 1.2.0 (will error with versions 1.2+)\n# from sklearn.metrics import plot_roc_curve \n# plot_roc_curve(gs_log_reg, X_test, y_test);\n\n# Scikit-Learn 1.2.0 or later\nfrom sklearn.metrics import RocCurveDisplay \n\n# from_estimator() = use a model to plot ROC curve on data\nRocCurveDisplay.from_estimator(estimator=gs_log_reg, \n                               X=X_test, \n                               y=y_test);\n</pre> # Before Scikit-Learn 1.2.0 (will error with versions 1.2+) # from sklearn.metrics import plot_roc_curve  # plot_roc_curve(gs_log_reg, X_test, y_test);  # Scikit-Learn 1.2.0 or later from sklearn.metrics import RocCurveDisplay   # from_estimator() = use a model to plot ROC curve on data RocCurveDisplay.from_estimator(estimator=gs_log_reg,                                 X=X_test,                                 y=y_test);  <p>This is great, our model does far better than guessing which would be a line going from the bottom left corner to the top right corner, AUC = 0.5.</p> <p>But a perfect model would achieve an AUC score of 1.0, so there's still room for improvement.</p> <p>Let's move on to the next evaluation request, a confusion matrix.</p> In\u00a0[50]: Copied! <pre># Display confusion matrix\nprint(confusion_matrix(y_test, y_preds))\n</pre> # Display confusion matrix print(confusion_matrix(y_test, y_preds)) <pre>[[25  4]\n [ 3 29]]\n</pre> <p>As you can see, Scikit-Learn's built-in confusion matrix is a bit bland. For a presentation you'd probably want to make it visual.</p> <p>Let's create a function which uses Seaborn's <code>heatmap()</code> for doing so.</p> In\u00a0[51]: Copied! <pre># Import Seaborn\nimport seaborn as sns\nsns.set(font_scale=1.5) # Increase font size\n\ndef plot_conf_mat(y_test, y_preds):\n    \"\"\"\n    Plots a confusion matrix using Seaborn's heatmap().\n    \"\"\"\n    fig, ax = plt.subplots(figsize=(3, 3))\n    ax = sns.heatmap(confusion_matrix(y_test, y_preds),\n                     annot=True, # Annotate the boxes\n                     cbar=False)\n    plt.xlabel(\"true label\")\n    plt.ylabel(\"predicted label\")\n    \nplot_conf_mat(y_test, y_preds)\n</pre> # Import Seaborn import seaborn as sns sns.set(font_scale=1.5) # Increase font size  def plot_conf_mat(y_test, y_preds):     \"\"\"     Plots a confusion matrix using Seaborn's heatmap().     \"\"\"     fig, ax = plt.subplots(figsize=(3, 3))     ax = sns.heatmap(confusion_matrix(y_test, y_preds),                      annot=True, # Annotate the boxes                      cbar=False)     plt.xlabel(\"true label\")     plt.ylabel(\"predicted label\")      plot_conf_mat(y_test, y_preds) <p>Beautiful! That looks much better.</p> <p>You can see the model gets confused (predicts the wrong label) relatively the same across both classes.</p> <p>In essence, there are 4 occasaions where the model predicted 0 when it should've been 1 (false negative) and 3 occasions where the model predicted 1 instead of 0 (false positive).</p> <p>As further evaluation, we could look into these samples and see why this may be the case.</p> In\u00a0[68]: Copied! <pre># Show classification report\nprint(classification_report(y_test, y_preds))\n</pre> # Show classification report print(classification_report(y_test, y_preds)) <pre>              precision    recall  f1-score   support\n\n           0       0.89      0.86      0.88        29\n           1       0.88      0.91      0.89        32\n\n    accuracy                           0.89        61\n   macro avg       0.89      0.88      0.88        61\nweighted avg       0.89      0.89      0.89        61\n\n</pre> <p>What's going on here?</p> <p>Let's refresh ourselves on of the above metrics.</p> Metric/metadata Explanation Precision Indicates the proportion of positive identifications (model predicted class 1) which were actually correct. A model which produces no false positives has a precision of 1.0. Recall Indicates the proportion of actual positives which were correctly classified. A model which produces no false negatives has a recall of 1.0. F1 score A combination of precision and recall. A perfect model achieves an F1 score of 1.0. Support The number of samples each metric was calculated on. Accuracy The accuracy of the model in decimal form. Perfect accuracy is equal to 1.0. Macro avg Short for macro average, the average precision, recall and F1 score between classes. Macro avg doesn\u2019t class imbalance into effort, so if you do have class imbalances, pay attention to this metric. Weighted avg Short for weighted average, the weighted average precision, recall and F1 score between classes. Weighted means each metric is calculated with respect to how many samples there are in each class. This metric will favour the majority class (e.g. will give a high value when one class out performs another due to having more samples). <p>Ok, now we've got a few deeper insights on our model.</p> <p>But these were all calculated using a single training and test set.</p> <p>What we'll do to make them more solid is calculate them using cross-validation.</p> <p>How?</p> <p>We'll take the best model along with the best hyperparameters and use <code>cross_val_score()</code> along with various <code>scoring</code> parameter values.</p> <p><code>cross_val_score()</code> works by taking an estimator (machine learning model) along with data and labels.</p> <p>It then evaluates the machine learning model on the data and labels using cross-validation across <code>cv=5</code> (the default number of splits) splits and a defined <code>scoring</code> parameter.</p> <p>Let's remind ourselves of the best hyperparameters and then see them in action.</p> In\u00a0[52]: Copied! <pre># Check best hyperparameters\ngs_log_reg.best_params_\n</pre> # Check best hyperparameters gs_log_reg.best_params_ Out[52]: <pre>{'C': np.float64(0.23357214690901212), 'solver': 'liblinear'}</pre> In\u00a0[53]: Copied! <pre># Import cross_val_score\nfrom sklearn.model_selection import cross_val_score\n\n# Instantiate best model with best hyperparameters (found with GridSearchCV)\nclf = LogisticRegression(C=0.23357214690901212,\n                         solver=\"liblinear\")\n</pre> # Import cross_val_score from sklearn.model_selection import cross_val_score  # Instantiate best model with best hyperparameters (found with GridSearchCV) clf = LogisticRegression(C=0.23357214690901212,                          solver=\"liblinear\") <p>Now we've got an instantiated classifier, let's find some cross-validated metrics.</p> In\u00a0[54]: Copied! <pre>%%time\n\n# Cross-validated accuracy score\ncv_acc = cross_val_score(clf,\n                         X,\n                         y,\n                         cv=5, # 5-fold cross-validation, this is the default\n                         scoring=\"accuracy\") # accuracy as scoring\ncv_acc\n</pre> %%time  # Cross-validated accuracy score cv_acc = cross_val_score(clf,                          X,                          y,                          cv=5, # 5-fold cross-validation, this is the default                          scoring=\"accuracy\") # accuracy as scoring cv_acc <pre>CPU times: user 9.91 ms, sys: 1.35 ms, total: 11.3 ms\nWall time: 9.75 ms\n</pre> Out[54]: <pre>array([0.81967213, 0.90163934, 0.8852459 , 0.88333333, 0.75      ])</pre> <p>Woah!</p> <p>The output from <code>cross_val_score()</code> shows 5 different metrics across different splits of the data.</p> <p>This goes to show the power of cross-validation.</p> <p>If we had have only chosen to go with the results of one data split, we might be thinking our model is under performing or over performing.</p> <p>Since there are 5 metrics here, we'll take the average.</p> In\u00a0[55]: Copied! <pre>cv_acc = np.mean(cv_acc)\ncv_acc\n</pre> cv_acc = np.mean(cv_acc) cv_acc Out[55]: <pre>np.float64(0.8479781420765027)</pre> <p>Now we'll do the same for other classification metrics.</p> In\u00a0[56]: Copied! <pre># Cross-validated precision score\ncv_precision = np.mean(cross_val_score(clf,\n                                       X,\n                                       y,\n                                       cv=5, # 5-fold cross-validation\n                                       scoring=\"precision\")) # precision as scoring\ncv_precision\n</pre> # Cross-validated precision score cv_precision = np.mean(cross_val_score(clf,                                        X,                                        y,                                        cv=5, # 5-fold cross-validation                                        scoring=\"precision\")) # precision as scoring cv_precision Out[56]: <pre>np.float64(0.8215873015873015)</pre> In\u00a0[57]: Copied! <pre># Cross-validated recall score\ncv_recall = np.mean(cross_val_score(clf,\n                                    X,\n                                    y,\n                                    cv=5, # 5-fold cross-validation\n                                    scoring=\"recall\")) # recall as scoring\ncv_recall\n</pre> # Cross-validated recall score cv_recall = np.mean(cross_val_score(clf,                                     X,                                     y,                                     cv=5, # 5-fold cross-validation                                     scoring=\"recall\")) # recall as scoring cv_recall Out[57]: <pre>np.float64(0.9272727272727274)</pre> In\u00a0[58]: Copied! <pre># Cross-validated F1 score\ncv_f1 = np.mean(cross_val_score(clf,\n                                X,\n                                y,\n                                cv=5, # 5-fold cross-validation\n                                scoring=\"f1\")) # f1 as scoring\ncv_f1\n</pre> # Cross-validated F1 score cv_f1 = np.mean(cross_val_score(clf,                                 X,                                 y,                                 cv=5, # 5-fold cross-validation                                 scoring=\"f1\")) # f1 as scoring cv_f1 Out[58]: <pre>np.float64(0.8705403543192143)</pre> <p>Okay, we've got cross validated metrics, now what?</p> <p>Let's visualize them.</p> In\u00a0[59]: Copied! <pre># Visualizing cross-validated metrics\ncv_metrics = pd.DataFrame({\"Accuracy\": cv_acc,\n                            \"Precision\": cv_precision,\n                            \"Recall\": cv_recall,\n                            \"F1\": cv_f1},\n                          index=[0])\ncv_metrics.T.plot.bar(title=\"Cross-Validated Metrics\", legend=False);\n</pre> # Visualizing cross-validated metrics cv_metrics = pd.DataFrame({\"Accuracy\": cv_acc,                             \"Precision\": cv_precision,                             \"Recall\": cv_recall,                             \"F1\": cv_f1},                           index=[0]) cv_metrics.T.plot.bar(title=\"Cross-Validated Metrics\", legend=False); <p>Great! This looks like something we could share. An extension might be adding the metrics on top of each bar so someone can quickly tell what they were.</p> <p>What now?</p> <p>The final thing to check off the list of our model evaluation techniques is feature importance.</p> In\u00a0[60]: Copied! <pre># Fit an instance of LogisticRegression (taken from above)\nclf.fit(X_train, y_train);\n</pre> # Fit an instance of LogisticRegression (taken from above) clf.fit(X_train, y_train); In\u00a0[61]: Copied! <pre># Check coef_\nclf.coef_\n</pre> # Check coef_ clf.coef_ Out[61]: <pre>array([[ 0.00369922, -0.90424094,  0.67472825, -0.0116134 , -0.00170364,\n         0.04787688,  0.33490202,  0.02472938, -0.6312041 , -0.57590972,\n         0.47095153, -0.65165346, -0.69984212]])</pre> <p>Looking at this it might not make much sense. But these values are how much each feature contributes to how a model makes a decision on whether patterns in a sample of patients health data leans more towards having heart disease or not.</p> <p>Even knowing this, in it's current form, this <code>coef_</code> array still doesn't mean much. But it will if we combine it with the columns (features) of our dataframe.</p> In\u00a0[62]: Copied! <pre># Match features to columns\nfeatures_dict = dict(zip(df.columns, list(clf.coef_[0])))\nfeatures_dict\n</pre> # Match features to columns features_dict = dict(zip(df.columns, list(clf.coef_[0]))) features_dict Out[62]: <pre>{'age': np.float64(0.0036992219987868977),\n 'sex': np.float64(-0.9042409356586161),\n 'cp': np.float64(0.6747282473934053),\n 'trestbps': np.float64(-0.011613399733807518),\n 'chol': np.float64(-0.0017036437157196944),\n 'fbs': np.float64(0.0478768767697894),\n 'restecg': np.float64(0.3349020243959257),\n 'thalach': np.float64(0.02472938207178759),\n 'exang': np.float64(-0.6312040952883138),\n 'oldpeak': np.float64(-0.575909718275565),\n 'slope': np.float64(0.4709515257844554),\n 'ca': np.float64(-0.6516534575992304),\n 'thal': np.float64(-0.6998421177365038)}</pre> <p>Now we've match the feature coefficients to different features, let's visualize them.</p> In\u00a0[63]: Copied! <pre># Visualize feature importance\nfeatures_df = pd.DataFrame(features_dict, index=[0])\nfeatures_df.T.plot.bar(title=\"Feature Importance\", legend=False);\n</pre> # Visualize feature importance features_df = pd.DataFrame(features_dict, index=[0]) features_df.T.plot.bar(title=\"Feature Importance\", legend=False); <p>You'll notice some are negative and some are positive.</p> <p>The larger the value (bigger bar), the more the feature contributes to the models decision.</p> <p>If the value is negative, it means there's a negative correlation. And vice versa for positive values.</p> <p>For example, the <code>sex</code> attribute has a negative value of -0.904, which means as the value for <code>sex</code> increases, the <code>target</code> value decreases.</p> <p>We can see this by comparing the <code>sex</code> column to the <code>target</code> column.</p> In\u00a0[81]: Copied! <pre>pd.crosstab(df[\"sex\"], df[\"target\"])\n</pre> pd.crosstab(df[\"sex\"], df[\"target\"]) Out[81]: target 0 1 sex 0 24 72 1 114 93 <p>You can see, when <code>sex</code> is 0 (female), there are almost 3 times as many (72 vs. 24) people with heart disease (<code>target</code> = 1) than without.</p> <p>And then as <code>sex</code> increases to 1 (male), the ratio goes down to almost 1 to 1 (114 vs. 93) of people who have heart disease and who don't.</p> <p>What does this mean?</p> <p>It means the model has found a pattern which reflects the data. Looking at these figures and this specific dataset, it seems if the patient is female, they're more likely to have heart disease.</p> <p>How about a positive correlation?</p> In\u00a0[82]: Copied! <pre># Contrast slope (positive coefficient) with target\npd.crosstab(df[\"slope\"], df[\"target\"])\n</pre> # Contrast slope (positive coefficient) with target pd.crosstab(df[\"slope\"], df[\"target\"]) Out[82]: target 0 1 slope 0 12 9 1 91 49 2 35 107 <p>Looking back the data dictionary, we see <code>slope</code> is the \"slope of the peak exercise ST segment\" where:</p> <ul> <li>0: Upsloping: better heart rate with excercise (uncommon)</li> <li>1: Flatsloping: minimal change (typical healthy heart)</li> <li>2: Downslopins: signs of unhealthy heart</li> </ul> <p>According to the model, there's a positive correlation of 0.470, not as strong as <code>sex</code> and <code>target</code> but still more than 0.</p> <p>This positive correlation means our model is picking up the pattern that as <code>slope</code> increases, so does the <code>target</code> value.</p> <p>Is this true?</p> <p>When you look at the contrast (<code>pd.crosstab(df[\"slope\"], df[\"target\"]</code>) it is. As <code>slope</code> goes up, so does <code>target</code>.</p> <p>What can you do with this information?</p> <p>This is something you might want to talk to a subject matter expert about.</p> <p>They may be interested in seeing where machine learning model is finding the most patterns (highest correlation) as well as where it's not (lowest correlation).</p> <p>Doing this has a few benefits:</p> <ol> <li>Finding out more - If some of the correlations and feature importances are confusing, a subject matter expert may be able to shed some light on the situation and help you figure out more.</li> <li>Redirecting efforts - If some features offer far more value than others, this may change how you collect data for different problems. See point 3.</li> <li>Less but better - Similar to above, if some features are offering far more value than others, you could reduce the number of features your model tries to find patterns in as well as improve the ones which offer the most. This could potentially lead to saving on computation, by having a model find patterns across less features, whilst still achieving the same performance levels.</li> </ol>"},{"location":"end-to-end-heart-disease-classification/#predicting-heart-disease-using-machine-learning","title":"Predicting Heart Disease using Machine Learning\u00b6","text":"<p>This notebook will introduce some foundation machine learning and data science concepts by exploring the problem of heart disease classification.</p> <p>For example, given a person's health characteristics, we're going to build a model to predict whether or not they have heart disease.</p> <p>It is intended to be an end-to-end example of what a data science and machine learning proof of concept might look like.</p>"},{"location":"end-to-end-heart-disease-classification/#what-is-classification","title":"What is classification?\u00b6","text":"<p>Classification involves deciding whether a sample is part of one class or another (binary classification).</p> <p>If there are multiple class options, it's referred to as multi-class classification.</p>"},{"location":"end-to-end-heart-disease-classification/#what-well-end-up-with","title":"What we'll end up with\u00b6","text":"<p>We'll start with the heart disease dataset we've worked on in previous modules and we'll approach the problem following the machine learning modelling framework.</p> 6 Step Machine Learning Modelling Framework <p>More specifically, we'll look at the following topics.</p> Step What we'll cover Exploratory data analysis (EDA) The process of going through a dataset and discovering more about it. Model training Create model(s) to learn to predict a target variable based on other variables. Model evaluation Evaluating a model's predictions using problem-specific evaluation metrics. Model comparison Comparing several different models to find the best one. Model hyperparameter tuning Once we've found a good model, can we tweak its hyperparameters to improve it? Feature importance Since we're predicting the presence of heart disease, are there some features/characteristics that are more important for prediction? Cross-validation If we do build a good model, can we be sure it will work on unseen data? Reporting what we've found If we had to present our work, what would we show someone? <p>To work through these topics, we'll use pandas, Matplotlib and NumPy for data anaylsis, as well as, Scikit-Learn for machine learning and modelling tasks.</p> Tools which can be used for each step of the machine learning modelling process. <p>We'll work through each step and by the end of the notebook, we'll have a handful of models, all which can predict whether or not a person has heart disease based on a number of different parameters at a considerable accuracy.</p> <p>You'll also be able to describe which parameters are more indicative than others, for example, sex may be more important than age.</p>"},{"location":"end-to-end-heart-disease-classification/#1-going-through-the-6-step-ml-framework","title":"1. Going through the 6 step ML framework\u00b6","text":""},{"location":"end-to-end-heart-disease-classification/#11-problem-definition","title":"1.1 Problem Definition\u00b6","text":"<p>In our case, the problem we will be exploring is binary classification (a sample can only be one of two things).</p> <p>This is because we're going to be using a number of differnet features (pieces of information such as health characteristics) about a person to predict whether they have heart disease or not.</p> <p>In a statement,</p> <p>Given clinical parameters about a patient, can we predict whether or not they have heart disease?</p>"},{"location":"end-to-end-heart-disease-classification/#12-what-data-are-we-using","title":"1.2 What data are we using?\u00b6","text":"<p>What you'll want to do here is dive into the data your problem definition is based on.</p> <p>This may involve, sourcing data (if it doesn't already exist), defining different parameters, talking to experts about it and finding out what you should expect.</p> <p>The original data came from the Cleveland database from UCI Machine Learning Repository.</p> <p>Howevever, we've downloaded it in a formatted way from Kaggle.</p> <p>The original database contains 76 attributes, but here only 14 attributes will be used. Attributes (also called features) are the variables what we'll use to predict our target variable.</p> <p>Attributes and features are also referred to as independent variables and a target variable can be referred to as a dependent variable.</p> <p>Note: We use the independent variable(s)to predict our dependent variable(s).</p> <p>In our case, the independent variables are a patient's different medical attributes and the dependent variable is whether or not they have heart disease.</p>"},{"location":"end-to-end-heart-disease-classification/#13-how-will-we-evaluate-our-model","title":"1.3 How will we evaluate our model?\u00b6","text":"<p>An evaluation metric is something you usually define at the start of a project.</p> <p>However, since machine learning is very experimental, it can change over time.</p> <p>But to begin a project, you might say something like:</p> <p>If we can reach 95% accuracy at predicting whether or not a patient has heart disease during the proof of concept, we'll pursure this project.</p> <p>The reason this is helpful is it provides a rough goal for a machine learning engineer or data scientist to work towards.</p> <p>Of course, as the project progresses and gets tested in the real world, you may have to adjust this goal/threshold.</p>"},{"location":"end-to-end-heart-disease-classification/#14-which-features-of-the-data-will-be-important-to-us","title":"1.4 Which features of the data will be important to us?\u00b6","text":"<p>Features are different parts and characteristics of the data.</p> <p>During this step, you'll want to start exploring what each portion of the data relates to and then create a reference you can use to look up later on.</p> <p>One of the most common ways to do this is to create a data dictionary.</p>"},{"location":"end-to-end-heart-disease-classification/#heart-disease-data-dictionary","title":"Heart Disease Data Dictionary\u00b6","text":"<p>A data dictionary describes the data you're dealing with.</p> <p>Not all datasets come with them so this is where you may have to do your research or ask a subject matter expert (someone who knows about the data) for more.</p> <p>The following are the features we'll use to predict our target variable (heart disease or no heart disease).</p> Feature Description Example Values age Age in years 29, 45, 60 sex 1 = male; 0 = female 0, 1 cp Chest pain type 0: Typical angina (chest pain), 1: Atypical angina (chest pain not related to heart), 2: Non-anginal pain (typically esophageal spasms (non heart related), 3: Asymptomatic (chest pain not showing signs of disease) trestbps Resting blood pressure (in mm Hg on admission to the hospital) 120, 140, 150 chol Serum cholesterol in mg/dl 180, 220, 250 fbs Fasting blood sugar &gt; 120 mg/dl (1 = true; 0 = false) 0, 1 restecg Resting electrocardiographic results 0: Nothing to note, 1: ST-T Wave abnormality, 2: Left ventricular hypertrophy thalach Maximum heart rate achieved 160, 180, 190 exang Exercise induced angina (1 = yes; 0 = no) 0, 1 oldpeak ST depression (heart potentially not getting enough oxygen) induced by exercise relative to rest 0.5, 1.0, 2.0 slope The slope of the peak exercise ST segment 0: Upsloping, 1: Flatsloping, 2: Downsloping ca Number of major vessels (0-3) colored by fluoroscopy 0, 1, 2, 3 thal Thalium stress result 1: Normal, 3: Normal, 6: Fixed defect, 7: Reversible defect target Have disease or not (1 = yes; 0 = no) 0, 1 <p>Note: No personal identifiable information (PPI) can be found in the dataset.</p> <p>It's a good idea to save these to a Python dictionary or in an external file, so we can look at them later without coming back here.</p>"},{"location":"end-to-end-heart-disease-classification/#2-preparing-the-tools","title":"2. Preparing the tools\u00b6","text":"<p>At the start of any project, it's custom to see the required libraries imported in a big chunk (as you can see in the code cell below).</p> <p>However, in practice, when starting on new projects you may import libraries as you go (because you don't know what you need ahead of time).</p> <p>After you've spent a couple of hours working on your problem, you'll probably want to do some tidying up.</p> <p>This is where you may want to consolidate every library you've used at the top of your notebook.</p> <p>The libraries you use will differ from project to project. But there are a few which will you'll likely take advantage of during almost every structured data project.</p> <ul> <li>pandas for data analysis.</li> <li>NumPy for numerical operations.</li> <li>Matplotlib/seaborn for plotting or data visualization.</li> <li>Scikit-Learn for machine learning modelling and evaluation.</li> </ul>"},{"location":"end-to-end-heart-disease-classification/#3-loading-data","title":"3. Loading Data\u00b6","text":"<p>There are many different ways to store data.</p> <p>One typical way of storing tabular data, data similar to what you'd see in an Excel file is in <code>.csv</code> format or CSV format.</p> <p>CSV stands for comma-separated values.</p> <p>Other common formats include JSON, SQL and parquet.</p> <p>Pandas has a built-in function to read <code>.csv</code> files called <code>read_csv()</code> which takes the file pathname of your <code>.csv</code> file. You'll likely use this a lot.</p> <p>Note: CSV format is good for smaller datasets but can face some speed issues when working with larger datasets. For more on different data formats pandas is compatible with, I'd check out the pandas guide on reading and writing data.</p> <p>And there are many more read functions for different data formats in the Input/Output section of the pandas documentation.</p>"},{"location":"end-to-end-heart-disease-classification/#4-data-exploration-exploratory-data-analysis-or-eda","title":"4. Data Exploration (exploratory data analysis or EDA)\u00b6","text":"<p>Once you've imported a dataset, the next step is to explore.</p> <p>Or in formal terms, perform an Exploratory Data Analysis (EDA).</p> <p>There's no set way of doing this.</p> <p>But what you should be trying to do is become more and more familiar with the dataset.</p> <p>Compare different columns to each other, compare them to the target variable.</p> <p>Refer back to your data dictionary and remind yourself of what different columns mean.</p> <p>One of my favourites is viewing 10-100 random samples of the data.</p> <p>Our goal here is to become a subject matter expert on the dataset you're working with.</p> <p>So if someone asks you a question about it, you can give them an explanation and when you start building models, you can sound check them to make sure they're not performing too well (overfitting and memorizing the data rather than learning generalizable patterns) or why they might be performing poorly (underfitting or not learning patterns in the data).</p> <p>Since EDA has no real set methodolgy, the following is a short check list you might want to walk through:</p> <ol> <li>What question(s) are you trying to solve (or prove wrong)?</li> <li>What kind of data do you have and how do you treat different types?</li> <li>What\u2019s missing from the data and how do you deal with it?</li> <li>Where are the outliers and why should you care about them?</li> <li>How can you add, change or remove features to get more out of your data?</li> </ol> <p>Once of the quickest and easiest ways to check your data is with the <code>head()</code> function.</p> <p>Calling it on any dataframe will print the top 5 rows, <code>tail()</code> calls the bottom 5. You can also pass a number to them like <code>head(10)</code> to show the top 10 rows.</p>"},{"location":"end-to-end-heart-disease-classification/#41-comparing-one-feature-to-another","title":"4.1 Comparing one feature to another\u00b6","text":"<p>If you want to compare two columns to each other, you can use the function <code>pd.crosstab(index, columns)</code>.</p> <p>This is helpful if you want to start gaining an intuition about how your independent variables interact with your dependent variables.</p> <p>Let's compare our target column with the sex column.</p> <p>Remember from our data dictionary, for the target column, 1 = heart disease present, 0 = no heart disease.</p> <p>And for sex, 1 = male, 0 = female.</p>"},{"location":"end-to-end-heart-disease-classification/#42-making-our-comparison-visual","title":"4.2 Making our comparison visual\u00b6","text":"<p>I'm going to introduce you to a motto I remind myself of whenever I'm exploring data.</p> <p>Visualize, visualize, visualize! - The data explorer's motto.</p> <p>This is because it's very helpful whenever you're dealing with a new dataset to visualize as much as you can to build up an idea of the dataset in your head.</p> <p>And one of the best ways to create visualizations is to make plots (graphical representations of our data).</p> <p>We can plot our <code>pd.crosstab</code> comparison by calling the <code>plot()</code> method and passing it a few parameters:</p> <ul> <li><code>kind</code>- The type of plot you want (e.g. <code>\"bar\"</code> for a bar plot).</li> <li><code>figsize=(length, width)</code> - How big you want it to be.</li> <li><code>color=[colour_1, colour_2]</code> - The different colours you'd like to use.</li> </ul> <p>Different metrics are represented best with different kinds of plots.</p> <p>In our case, a bar graph is great. We'll see examples of more later. And with a bit of practice, you'll gain an intuition of which plot to use with different variables.</p>"},{"location":"end-to-end-heart-disease-classification/#43-comparing-age-and-maximum-heart-rate","title":"4.3 Comparing age and maximum heart rate\u00b6","text":"<p>Let's try combining a couple of independent variables, such as, <code>age</code> and <code>thalach</code> (maximum heart rate) and then comparing them to our target variable <code>heart disease</code>.</p> <p>Because there are so many different values for <code>age</code> and <code>thalach</code>, we'll use a scatter plot.</p>"},{"location":"end-to-end-heart-disease-classification/#44-comparing-heart-disease-frequency-and-chest-pain-type","title":"4.4 Comparing heart disease frequency and chest pain type\u00b6","text":"<p>Let's try comparing another independent variable with our target variable.</p> <p>This time, we'll use <code>cp</code> (chest pain) as the independent variable.</p> <p>We'll use the same process as we did before with <code>sex</code>.</p>"},{"location":"end-to-end-heart-disease-classification/#45-correlation-between-independent-variables","title":"4.5 Correlation between independent variables\u00b6","text":"<p>Finally, we'll compare all of the independent variables in one hit.</p> <p>Why?</p> <p>Because this may give an idea of which independent variables may or may not have an impact on our target variable.</p> <p>We can do this using <code>pd.DataFrame.corr()</code> which will create a correlation matrix for us, in other words, a big table of numbers telling us how related each variable is the other.</p>"},{"location":"end-to-end-heart-disease-classification/#46-enough-eda-lets-model","title":"4.6 Enough EDA, let's model\u00b6","text":"<p>Remember, we do exploratory data analysis (EDA) to start building an intuition of the dataset.</p> <p>What have we learned so far?</p> <p>Aside from our baseline estimate using <code>sex</code>, the rest of the data seems to require a bit more exploration before we draw any conclusions.</p> <p>So what we'll do next is model driven EDA, meaning, we'll use machine learning models to drive our next questions.</p> <p>A few extra things to remember:</p> <ul> <li>Not every EDA will look the same, what we've seen here is an example of what you could do for structured, tabular dataset.</li> <li>You don't necessarily have to do the same plots as we've done here, there are many more ways to visualize data, I encourage you to look at more.</li> <li>Quite often, we'll want to find:<ul> <li>Distributions - What's the spread of the data? We can do this with <code>pd.DataFrame.hist(column=\"target_column\")</code>.</li> <li>Missing values - Is our data missing anything? Why might this be the case and will this affect us going forward? We can do this with <code>pd.DataFrame.info()</code> or <code>pd.isnull()</code>.</li> <li>Outliers - Are there any samples that lay quite far outside the rest of our data's distributions? How might these affect the data going forward?</li> </ul> </li> </ul> <p>With this being said, let's build some models!</p>"},{"location":"end-to-end-heart-disease-classification/#5-modeling","title":"5. Modeling\u00b6","text":"<p>We've explored the data, now we'll try to build a machine learning model to be able to predict our target variable based on the 13 independent variables.</p> <p>Remember our problem?</p> <p>Given clinical parameters about a patient, can we predict whether or not they have heart disease?</p> <p>That's what we'll be trying to answer.</p> <p>And remember our evaluation metric?</p> <p>If we can reach 95% accuracy at predicting whether or not a patient has heart disease during the proof of concept, we'll pursure this project.</p> <p>That's what we'll be aiming for.</p> <p>But before we build a model, we have to get our dataset ready.</p> <p>Let's look at it again.</p>"},{"location":"end-to-end-heart-disease-classification/#51-creating-a-training-and-test-split","title":"5.1 Creating a training and test split\u00b6","text":"<p>Now comes one of the most important concepts in machine learning, creating a training/test split.</p> <p>This is where we'll split our data into a training set and a test set.</p> <p>We'll use our training set to train our model and our test set to evaluate it.</p> <p>All the samples in the training set must be separate from those in the test set (and vice versa).</p> <p>In short:</p> <ul> <li>Training set (often 70-80% of total data) - Model learns patterns on this dataset to hopefully be able to predict on similar but unseen samples.</li> <li>Testing set (often 20-30% of total data) - Trained model gets evaluated on these unseen samples to see how the patterns learned from the training set may perform on future unseen samples (e.g. when used in an application or production setting). However, performance on the test set is not guaranteed in the real world.</li> </ul>"},{"location":"end-to-end-heart-disease-classification/#why-not-use-all-the-data-to-train-a-model","title":"Why not use all the data to train a model?\u00b6","text":"<p>Let's say you wanted to take your model into the hospital and start using it on patients.</p> <p>How would you know how well your model goes on a new patient not included in the original full dataset you had?</p> <p>This is where the test set comes in.</p> <p>It's used to mimic taking your model to a real environment as much as possible.</p> <p>And it's why it's important to never let your model learn from the test set, it should only be evaluated on it.</p> <p>To split our data into a training and test set, we can use Scikit-Learn's <code>sklearn.model_selection.train_test_split()</code> and feed it our independent and dependent variables (<code>X</code> &amp; <code>y</code>).</p>"},{"location":"end-to-end-heart-disease-classification/#52-choosing-a-model","title":"5.2 Choosing a model\u00b6","text":"<p>Now we've got our data prepared, we can start to fit models.</p> <p>In the modern world of machine learning, there are many potential models we can choose from.</p> <p>Rather than trying every potential model, it's often good practice to try a handful and see how they go.</p> <p>We'll start by trying the following models and comparing their results.</p> <ol> <li>Logistic Regression - <code>sklearn.linear_model.LogisticRegression()</code></li> <li>K-Nearest Neighbors - <code>sklearn.neighbors.KNeighboursClassifier()</code></li> <li>RandomForest - <code>sklearn.ensemble.RandomForestClassifier()</code></li> </ol>"},{"location":"end-to-end-heart-disease-classification/#why-these","title":"Why these?\u00b6","text":"<p>If we look at the Scikit-Learn algorithm machine learning model map, we can see we're working on a classification problem and these are the algorithms it suggests (plus a few more).</p> An example path we can take using the Scikit-Learn Machine Learning Map <p>\"Wait, I don't see Logistic Regression and why not use LinearSVC?\"</p> <p>Good questions.</p> <p>I was confused too when I didn't see Logistic Regression listed as well because when you read the Scikit-Learn documentation on it, you can see it's a model for classification.</p> <p>And as for <code>sklearn.svm.LinearSVC</code>, let's pretend we've tried it (you can try it for yourself if you like), and it doesn't work, so we're following other options in the map.</p> <p>For now, knowing each of these algorithms inside and out is not essential (however, this would be a fantastic extension to this project).</p> <p>Machine learning and data science is an iterative practice.</p> <p>These algorithms are tools in your toolbox.</p> <p>In the beginning, on your way to becoming a practitioner, it's more important to understand your problem (such as, classification versus regression) and what tools you can use to solve it.</p> <p>Since our dataset is relatively small, we can run some quick experiments to see which algorithm performs best and iteratively try to improve it.</p> <p>Many of the algorithms in the Scikit-Learn library have similar APIs (Application Programming Interfaces).</p> <p>For example, for training a model you can use <code>model.fit(X_train, y_train)</code>.</p> <p>And for scoring a model <code>model.score(X_test, y_test)</code> (scoring a model compares predictions to the ground truth labels).</p> <p>For classification models, calling <code>score()</code> usually defaults to returning the ratio (accuracy) of correct predictions (1.0 = 100% correct).</p> <p>Since the algorithms we've chosen implement the same methods for fitting them to the data as well as evaluating them, let's put them in a dictionary and create a which fits and scores them.</p>"},{"location":"end-to-end-heart-disease-classification/#53-comparing-the-results-of-several-models","title":"5.3 Comparing the results of several models\u00b6","text":"<p>Since we've saved our models scores to a dictionary, we can plot them by first converting them to a DataFrame.</p>"},{"location":"end-to-end-heart-disease-classification/#54-taking-our-best-model-to-the-boss-and-learning-about-a-few-new-terms","title":"5.4 Taking our best model to the boss (and learning about a few new terms)\u00b6","text":"<p>A conversation with the boss/senior engineer begins...</p> <p>You: I've found it!</p> <p>Her: Nice one! What did you find?</p> <p>You: The best algorithm for predicting heart disease is a Logistic Regression!</p> <p>Her: Excellent. I'm surprised the hyperparameter tuning is finished by now.</p> <p>You: wonders what hyperparameter tuning is</p> <p>You: Ummm yeah, me too, it went pretty quick.</p> <p>Her: I'm very proud, how about you put together a classification report to show the team, and be sure to include a confusion matrix, and the cross-validated precision, recall and F1 scores. I'd also be curious to see what features are most important. Oh and don't forget to include a ROC curve.</p> <p>You: asks self, \"what are those???\"</p> <p>You: Of course! I'll have to you by tomorrow.</p> <p>Alright, there were a few words in there that could sound made up to someone who's not a budding data scientist like us.</p> <p>But being the budding data scientist we are, we also know data scientists make up words all the time.</p> <p>Let's briefly go through each before we see them in action.</p> Term Definition Hyperparameter tuning Many machine learning models have a series of settings/dials you can turn to dictate how they perform. Changing these values may increase or decrease model performance. The practice of figuring out the best settings for a model is called hyperparameter tuning. Feature importance If there are a large amount of features we're using to make predictions, do some have more importance than others? For example, for predicting heart disease, which is more important, sex or age? Confusion matrix Compares the predicted values with the true values in a tabular way, if 100% correct, all values in the matrix will be top left to bottom right (diagnol line). Cross-validation Splits your dataset into multiple versions of training and test sets and trains/evaluations your model on each different version. This ensures that your evaluation metrics are across several different splits of data rather than a single split (if it was only a single split, you might get lucky and get better than usual results, the same for the reverse, if you get a poor split, you might find your metrics lower than they should be). Precision A common classification evaluation metric. Measures the proportion of true positives over total number of samples. Higher precision leads to fewer false positives. <p>Recall | A common classification evaluation metric. Measures the proportion of true positives over total number of true positives and false negatives. Higher recall leads to fewer false negatives. | | F1 score | Combines precision and recall into one metric. 1 is best, 0 is worst. | | Classification report | Sklearn has a built-in function called <code>classification_report()</code> which returns some of the main classification metrics such as precision, recall and f1-score. | | ROC Curve | Receiver Operating Characterisitc is a plot of true positive rate versus false positive rate. A perfect curve will follow the left and top border of a plot. | | Area Under Curve (AUC) | The area underneath the ROC curve. A perfect model achieves a score of 1.0. |</p> <p>Woah!</p> <p>There are a fair few things going on here but nothing we can't handle.</p> <p>We'll explore each of these further throughout the rest of the notebook.</p> <p>In the meantime, feel free to read more at the linked resources.</p>"},{"location":"end-to-end-heart-disease-classification/#6-hyperparameter-tuning-and-cross-validation","title":"6. Hyperparameter tuning and cross-validation\u00b6","text":"<p>To cook your favourite dish, you know to set the oven to 180 degrees and turn the grill on.</p> <p>But when your roommate cooks their favourite dish, they use 200 degrees and the fan-forced mode.</p> <p>Same oven, different settings, different outcomes.</p> <p>The same can be done for machine learning algorithms. You can use the same algorithms but change the settings (hyperparameters) and get different results.</p> <p>But just like turning the oven up too high can burn your food, the same can happen for machine learning algorithms.</p> <p>You change the settings and it works so well, it overfits (does too well) the data.</p> <p>We're looking for the Goldilocks model.</p> <p>One which does well on our training dataset but also on unseen examples like in the testing dataset/real world.</p> <p>To test different hyperparameters, you could use a validation set but since we don't have much data, we'll use cross-validation.</p> <p>Note: A validation set is a third player in the training/test split game. It's designed to be used in between a training and test set. You can think of it as the practice exam before the final exam. As in, the training set is the course material to learn on, the validation set is the practice exam to practice and tweak your skills on and the test set is the final exam to push your skills. In machine learning, the model learns patterns on the training set and then you can tweak hyperparameters to improve results on the validation set before finally testing your model on the testing set. All samples in the training, validation and test sets should be kept exclusive of each other.</p> <p>The most common type of cross-validation is k-fold.</p> <p>It involves splitting your data into k-fold's or k-different splits of the data and then training and testing a model on each split.</p> <p>For example, let's say we had 5 folds (k = 5).</p> <p>This is what it might look like.</p> Normal train and test split versus 5-fold cross-validation <p>You have 5 different versions of train and test splits.</p> <p>This means you'll be able to train and test 5 different versions of your model on different data splits and calculate the average performance.</p> <p>Why do this?</p> <p>This prevents us from focusing too much on the metrics from one data split (imagine the data split we do contains all the easy samples and the performance metrics we use say that the model performs better than it does).</p> <p>We'll be using this setup to tune the hyperparameters of some of our models and then evaluate them.</p> <p>We'll also get a few more metrics like precision, recall, F1-score and ROC at the same time.</p> <p>Here's the plan:</p> <ol> <li>Tune model hyperparameters, and see which performs best</li> <li>Perform cross-validation</li> <li>Plot ROC curves</li> <li>Make a confusion matrix</li> <li>Get precision, recall and F1-score metrics</li> <li>Find the most important model features</li> </ol>"},{"location":"end-to-end-heart-disease-classification/#61-tune-kneighborsclassifier-k-nearest-neighbors-or-knn-by-hand","title":"6.1 Tune KNeighborsClassifier (K-Nearest Neighbors or KNN) by hand\u00b6","text":"<p>There are several hyperparameters we can tune for the K-Nearest Neighbors (KNN) algorithm (or <code>sklearn.neighbors.KNeighborsClassifier</code>).</p> <p>But for now, let's start with one, the number of neighbors.</p> <p>The default is 5 (<code>n_neigbors=5</code>).</p> <p>What are neighbours?</p> <p>Well, imagine all our different samples on one graph like the scatter graph several cells above.</p> <p>KNN works by assuming dots which are closer together belong to the same class.</p> <p>If <code>n_neighbors=5</code> then it assume a dot with the 5 closest dots around it are in the same class.</p> <p>We've left out some details here like what defines close or how distance is calculated but I encourage you to research them by going through the documentation.</p> <p>For now, let's try a few different values of <code>n_neighbors</code> and test how the results go.</p>"},{"location":"end-to-end-heart-disease-classification/#62-tuning-models-with-with-randomizedsearchcv","title":"6.2 Tuning models with with <code>RandomizedSearchCV</code>\u00b6","text":"<p>Reading the Scikit-Learn documentation for <code>LogisticRegression</code>, we find there's a number of different hyperparameters we can tune.</p> <p>The same for <code>RandomForestClassifier</code>.</p> <p>Let's create a hyperparameter grid (a dictionary of different hyperparameters) for each and then test them out.</p> <p>Note: Be careful creating a hyperparameter dictionary for tuning as if there are typos in the keys of the dictionary, you will find that your code hyperparameter tuning code will produce errors.</p>"},{"location":"end-to-end-heart-disease-classification/#63-tuning-a-model-with-gridsearchcv","title":"6.3 Tuning a model with <code>GridSearchCV</code>\u00b6","text":"<p>The difference between <code>RandomizedSearchCV</code> and <code>GridSearchCV</code> is:</p> <ul> <li><code>sklearn.model_selection.RandomizedSearchCV</code> searches over a grid of hyperparameters performing <code>n_iter</code> combinations (e.g. will explore random combinations of the hyperparameters for a defined number of iterations).</li> <li><code>sklearn.model_selection.GridSearchCV</code> will test every single possible combination of hyperparameters in the grid (this is a thorough test but can take quite a long time).</li> </ul> <p>Each class will save the best model at the end of testing.</p> <p>Let's see it in action.</p>"},{"location":"end-to-end-heart-disease-classification/#7-evaluating-a-classification-model-beyond-accuracy","title":"7. Evaluating a classification model, beyond accuracy\u00b6","text":"<p>Now we've got a tuned model, let's get some of the metrics we discussed before.</p> <p>We want:</p> Metric/Evaluation Technique Scikit-Learn method/documentation ROC curve and AUC score <code>sklearn.metrics.RocCurveDisplay()</code>, Note: This was previously <code>sklearn.metrics.plot_roc_curve()</code>, as of Scikit-Learn version 1.2+, it is <code>sklearn.metrics.RocCurveDisplay()</code>. Confusion matrix <code>sklearn.metrics.confusion_matrix()</code> Classification report <code>sklearn.metrics.classification_report()</code> Precision <code>sklearn.metrics.precision_score()</code> Recall <code>sklearn.metrics.recall_score()</code> F1-score <code>sklearn.metrics.f1_score()</code> <p>Luckily, Scikit-Learn has these all built-in.</p> <p>What many evaluation metrics have in common is that they compare model predictions to ground truth data.</p> <p>So we'll need some model predictions!</p> <p>To access them, we'll have to use our model to make predictions on the test set.</p> <p>We can make predictions by calling <code>predict()</code> on a trained model and passing it the data you'd like to predict on.</p> <p>We'll make predictions on the test data.</p> <p>Note: When making predictions with a trained model, the data you're trying to predict on must be in the same format your model was trained on. For example, if a model was trained with data formatted in a certain way, it's important to make future predictions on data formatted in that same way.</p>"},{"location":"end-to-end-heart-disease-classification/#71-roc-curve-and-auc-scores","title":"7.1 ROC Curve and AUC Scores\u00b6","text":"<p>What's a ROC curve?</p> <p>It's a way of understanding how your model is performing by comparing the true positive rate to the false positive rate.</p> <p>In our case...</p> <p>To get an appropriate example in a real-world problem, consider a diagnostic test that seeks to determine whether a person has a certain disease. A false positive in this case occurs when the person tests positive, but does not actually have the disease. A false negative, on the other hand, occurs when the person tests negative, suggesting they are healthy, when they actually do have the disease.</p> <p>Scikit-Learn implements a function <code>RocCurveDisplay</code> (previously called <code>plot_roc_curve</code> in Scikit-Learn versions &lt; 1.2) which can help us create a ROC curve as well as calculate the area under the curve (AUC) metric.</p> <p>Reading the documentation on the <code>RocCurveDisplay</code> function we can see it has a class method called <code>from_estimator(estimator, X, y)</code> as inputs.</p> <p>Where <code>estimator</code> is a fitted machine learning model and <code>X</code> and <code>y</code> are the data you'd like to test it on.</p> <p>In our case, we'll use the GridSearchCV version of our <code>LogisticRegression</code> estimator, <code>gs_log_reg</code> as well as the test data, <code>X_test</code> and <code>y_test</code>.</p>"},{"location":"end-to-end-heart-disease-classification/#72-creating-a-confusion-matrix","title":"7.2 Creating a confusion matrix\u00b6","text":"<p>A confusion matrix is a visual way to show where your model made the right predictions and where it made the wrong predictions (or in other words, got confused).</p> <p>Scikit-Learn allows us to create a confusion matrix using <code>sklearn.metrics.confusion_matrix()</code> and passing it the true labels and predicted labels.</p>"},{"location":"end-to-end-heart-disease-classification/#73-classification-report","title":"7.3 Classification report\u00b6","text":"<p>A classification report is a collection of different metrics and other details.</p> <p>We can make a classification report using <code>sklearn.metrics.classification_report(y_true, y_pred)</code> and passing it the true labels as well as our models predicted labels.</p> <p>A classification report will also give us information on the precision and recall of our model for each class.</p>"},{"location":"end-to-end-heart-disease-classification/#8-feature-importance","title":"8. Feature importance\u00b6","text":"<p>Feature importance is another way of asking, \"Which features contribute most to the outcomes of the model?\"</p> <p>For our problem, trying to predict heart disease using a patient's medical characteristics, getting the feature importance is like asking \"Which characteristics contribute most to a model predicting whether someone has heart disease or not?\"</p> <p>Because how each model finds patterns in data is slightly different, how a model judges how important those patterns are is different as well.</p> <p>This means for each model, there's a slightly different way of finding which features were most important and in turn, the feature importance of one model won't necessarily reflect the feature importance of another.</p> <p>You can usually find an example via the Scikit-Learn documentation or via searching for something like \"MODEL TYPE feature importance\", such as, \"random forest feature importance\".</p> <p>Since we're using <code>LogisticRegression</code>, we'll look at one way we can calculate feature importance for it.</p> <p>To do so, we'll use the <code>coef_</code> attribute. Looking at the Scikit-Learn documentation for <code>LogisticRegression</code>, the <code>coef_</code> attribute is the coefficient of the features in the decision function.</p> <p>We can access the <code>coef_</code> attribute after we've fit an instance of <code>LogisticRegression</code>.</p>"},{"location":"end-to-end-heart-disease-classification/#9-experimentation","title":"9. Experimentation\u00b6","text":"<p>We've completed all the metrics your boss requested!</p> <p>You should be able to put together a great report containing a confusion matrix, and a handful of cross-validated metrics such as precision, recall and F1-score and you can even include which features contribute most to the model making a decision.</p> <p>But after all this you might be wondering where step 6 in the framework is, experimentation.</p> <p>Well the secret here is, as you might've guessed, the whole thing is experimentation.</p> <p>From trying different models, to tuning different models to figuring out which hyperparameters were best.</p> <p>What we've worked through so far has been a series of experiments.</p> <p>And the truth is, we could keep going. But of course, things can't go on forever.</p> <p>So by this stage, after trying a few different things, we'd ask ourselves did we meet the evaluation metric?</p> <p>Remember we defined one in step 3.</p> <p>If we can reach 95% accuracy at predicting whether or not a patient has heart disease during the proof of concept, we'll pursue this project.</p> <p>In this case, we didn't.</p> <p>The highest accuracy our model achieved was below 90%.</p>"},{"location":"end-to-end-heart-disease-classification/#what-next","title":"What next?\u00b6","text":"<p>You might be wondering, what happens when the evaluation metric doesn't get hit?</p> <p>Is everything we've done wasted?</p> <p>No.</p> <p>It means we know what doesn't work.</p> <p>In this case, we know the current model we're using (a tuned version of <code>sklearn.linear_model.LogisticRegression</code>) along with our specific data set doesn't hit the target we set ourselves.</p> <p>This is where step 6 comes into its own.</p> <p>A good next step would be to discuss with your team or research on your own different options of going forward.</p> <ul> <li>Could you collect more data? Across more patients with more features? This may take a while but in machine learning, more data is generally better.</li> <li>Could you try a better model? If you're working with structured data, you might want to look into CatBoost or XGBoost.</li> <li>Could you improve the current models (beyond what we've done so far)?</li> <li>If your model is good enough, how would you export it and share it with others? (Hint: check out Scikit-Learn's documentation on model persistance)</li> </ul> <p>The key here is to remember, your biggest restriction will be time.</p> <p>Hence why it's paramount to minimise your time between experiments (if you can).</p> <p>The more things you try, the more you figure out what doesn't work, the more you'll start to get a hang of what does.</p> <p>And that's the whole nature of machine learning.</p>"},{"location":"introduction-to-matplotlib/","title":"Introduction to Matplotlib","text":"<p>View source code | Read notebook in online book format</p> In\u00a0[1]: Copied! <pre>import datetime\nprint(f\"Last updated: {datetime.datetime.now()}\")\n</pre> import datetime print(f\"Last updated: {datetime.datetime.now()}\") <pre>Last updated: 2024-09-06 13:12:51.657220\n</pre> In\u00a0[2]: Copied! <pre># Older versions of Jupyter Notebooks and matplotlib required this magic command \n# %matplotlib inline\n\n# Import matplotlib and matplotlib.pyplot\nimport matplotlib\nimport matplotlib.pyplot as plt\n\nprint(f\"matplotlib version: {matplotlib.__version__}\")\n</pre> # Older versions of Jupyter Notebooks and matplotlib required this magic command  # %matplotlib inline  # Import matplotlib and matplotlib.pyplot import matplotlib import matplotlib.pyplot as plt  print(f\"matplotlib version: {matplotlib.__version__}\") <pre>matplotlib version: 3.9.2\n</pre> In\u00a0[3]: Copied! <pre># Create a simple plot, without the semi-colon\nplt.plot()\n</pre> # Create a simple plot, without the semi-colon plt.plot() Out[3]: <pre>[]</pre> In\u00a0[4]: Copied! <pre># With the semi-colon\nplt.plot();\n</pre> # With the semi-colon plt.plot(); In\u00a0[5]: Copied! <pre># You could use plt.show() if you want\nplt.plot()\nplt.show()\n</pre> # You could use plt.show() if you want plt.plot() plt.show() In\u00a0[6]: Copied! <pre># Let's add some data\nplt.plot([1, 2, 3, 4]);\n</pre> # Let's add some data plt.plot([1, 2, 3, 4]); In\u00a0[8]: Copied! <pre># Create some data\nx = [1, 2, 3, 4]\ny = [11, 22, 33, 44]\n</pre> # Create some data x = [1, 2, 3, 4] y = [11, 22, 33, 44] <p>A few quick things about a plot:</p> <ul> <li><code>x</code> is the horizontal axis.</li> <li><code>y</code> is the vertical axis.</li> <li>In a data point, <code>x</code> usually comes first, e.g. <code>(3, 4)</code> would be <code>(x=3, y=4)</code>.</li> <li>The same is happens in <code>matplotlib.pyplot.plot()</code>, <code>x</code> comes before <code>y</code>, e.g. <code>plt.plot(x, y)</code>.</li> </ul> In\u00a0[9]: Copied! <pre># Now a y-value too!\nplt.plot(x, y);\n</pre> # Now a y-value too! plt.plot(x, y); <p>Now let's try using the object-orientated version.</p> <p>We'll start by creating a figure with <code>plt.figure()</code>.</p> <p>And then we'll add an axes with <code>add_subplot</code>.</p> In\u00a0[10]: Copied! <pre># Creating a plot with the object-orientated verison\nfig = plt.figure() # create a figure\nax = fig.add_subplot() # add an axes \nplt.show()\n</pre> # Creating a plot with the object-orientated verison fig = plt.figure() # create a figure ax = fig.add_subplot() # add an axes  plt.show() <p>A note on the terminology:</p> <ul> <li>A <code>Figure</code> (e.g. <code>fig = plt.figure()</code>) is the final image in matplotlib (and it may contain one or more <code>Axes</code>), often shortened to <code>fig</code>.</li> <li>The <code>Axes</code> are an individual plot (e.g. <code>ax = fig.add_subplot()</code>), often shorted to <code>ax</code>.<ul> <li>One <code>Figure</code> can contain one or more <code>Axes</code>.</li> </ul> </li> <li>The <code>Axis</code> are x (horizontal), y (vertical), z (depth).</li> </ul> <p>Now let's add some data to our pevious plot.</p> In\u00a0[11]: Copied! <pre># Add some data to our previous plot \nfig = plt.figure()\nax = fig.add_axes([1, 1, 1, 1])\nax.plot(x, y)\nplt.show()\n</pre> # Add some data to our previous plot  fig = plt.figure() ax = fig.add_axes([1, 1, 1, 1]) ax.plot(x, y) plt.show() <p>But there's an easier way we can use <code>matplotlib.pyplot</code> to help us create a <code>Figure</code> with multiple potential <code>Axes</code>.</p> <p>And that's with <code>plt.subplots()</code>.</p> In\u00a0[12]: Copied! <pre># Create a Figure and multiple potential Axes and add some data\nfig, ax = plt.subplots()\nax.plot(x, y);\n</pre> # Create a Figure and multiple potential Axes and add some data fig, ax = plt.subplots() ax.plot(x, y); In\u00a0[13]: Copied! <pre># This is where the object orientated name comes from \ntype(fig), type(ax)\n</pre> # This is where the object orientated name comes from  type(fig), type(ax) Out[13]: <pre>(matplotlib.figure.Figure, matplotlib.axes._axes.Axes)</pre> In\u00a0[14]: Copied! <pre># A matplotlib workflow\n\n# 0. Import and get matplotlib ready\n# %matplotlib inline # Not necessary in newer versions of Jupyter (e.g. 2022 onwards)\nimport matplotlib.pyplot as plt\n\n# 1. Prepare data\nx = [1, 2, 3, 4]\ny = [11, 22, 33, 44]\n\n# 2. Setup plot (Figure and Axes)\nfig, ax = plt.subplots(figsize=(10,10))\n\n# 3. Plot data\nax.plot(x, y)\n\n# 4. Customize plot\nax.set(title=\"Sample Simple Plot\", xlabel=\"x-axis\", ylabel=\"y-axis\")\n\n# 5. Save &amp; show\nfig.savefig(\"../images/simple-plot.png\")\n</pre> # A matplotlib workflow  # 0. Import and get matplotlib ready # %matplotlib inline # Not necessary in newer versions of Jupyter (e.g. 2022 onwards) import matplotlib.pyplot as plt  # 1. Prepare data x = [1, 2, 3, 4] y = [11, 22, 33, 44]  # 2. Setup plot (Figure and Axes) fig, ax = plt.subplots(figsize=(10,10))  # 3. Plot data ax.plot(x, y)  # 4. Customize plot ax.set(title=\"Sample Simple Plot\", xlabel=\"x-axis\", ylabel=\"y-axis\")  # 5. Save &amp; show fig.savefig(\"../images/simple-plot.png\") In\u00a0[15]: Copied! <pre>import numpy as np\n</pre> import numpy as np In\u00a0[16]: Copied! <pre># Create an array\nx = np.linspace(0, 10, 100)\nx[:10]\n</pre> # Create an array x = np.linspace(0, 10, 100) x[:10] Out[16]: <pre>array([0.        , 0.1010101 , 0.2020202 , 0.3030303 , 0.4040404 ,\n       0.50505051, 0.60606061, 0.70707071, 0.80808081, 0.90909091])</pre> In\u00a0[17]: Copied! <pre># The default plot is line\nfig, ax = plt.subplots()\nax.plot(x, x**2);\n</pre> # The default plot is line fig, ax = plt.subplots() ax.plot(x, x**2); In\u00a0[18]: Copied! <pre># Need to recreate our figure and axis instances when we want a new figure\nfig, ax = plt.subplots()\nax.scatter(x, np.exp(x));\n</pre> # Need to recreate our figure and axis instances when we want a new figure fig, ax = plt.subplots() ax.scatter(x, np.exp(x)); In\u00a0[19]: Copied! <pre>fig, ax = plt.subplots()\nax.scatter(x, np.sin(x));\n</pre> fig, ax = plt.subplots() ax.scatter(x, np.sin(x)); In\u00a0[20]: Copied! <pre># You can make plots from a dictionary\nnut_butter_prices = {\"Almond butter\": 10,\n                     \"Peanut butter\": 8,\n                     \"Cashew butter\": 12}\nfig, ax = plt.subplots()\nax.bar(nut_butter_prices.keys(), nut_butter_prices.values())\nax.set(title=\"Dan's Nut Butter Store\", ylabel=\"Price ($)\");\n</pre> # You can make plots from a dictionary nut_butter_prices = {\"Almond butter\": 10,                      \"Peanut butter\": 8,                      \"Cashew butter\": 12} fig, ax = plt.subplots() ax.bar(nut_butter_prices.keys(), nut_butter_prices.values()) ax.set(title=\"Dan's Nut Butter Store\", ylabel=\"Price ($)\"); In\u00a0[21]: Copied! <pre>fig, ax = plt.subplots()\nax.barh(list(nut_butter_prices.keys()), list(nut_butter_prices.values()));\n</pre> fig, ax = plt.subplots() ax.barh(list(nut_butter_prices.keys()), list(nut_butter_prices.values())); In\u00a0[22]: Copied! <pre># Make some data from a normal distribution\nx = np.random.randn(1000) # pulls data from a normal distribution\n\nfig, ax = plt.subplots()\nax.hist(x);\n</pre> # Make some data from a normal distribution x = np.random.randn(1000) # pulls data from a normal distribution  fig, ax = plt.subplots() ax.hist(x); In\u00a0[23]: Copied! <pre>x = np.random.random(1000) # random data from random distribution\n\nfig, ax = plt.subplots()\nax.hist(x);\n</pre> x = np.random.random(1000) # random data from random distribution  fig, ax = plt.subplots() ax.hist(x); In\u00a0[24]: Copied! <pre># Option 1: Create 4 subplots with each Axes having its own variable name\nfig, ((ax1, ax2), (ax3, ax4)) = plt.subplots(nrows=2, \n                                             ncols=2, \n                                             figsize=(10, 5))\n\n# Plot data to each axis\nax1.plot(x, x/2);\nax2.scatter(np.random.random(10), np.random.random(10));\nax3.bar(nut_butter_prices.keys(), nut_butter_prices.values());\nax4.hist(np.random.randn(1000));\n</pre> # Option 1: Create 4 subplots with each Axes having its own variable name fig, ((ax1, ax2), (ax3, ax4)) = plt.subplots(nrows=2,                                               ncols=2,                                               figsize=(10, 5))  # Plot data to each axis ax1.plot(x, x/2); ax2.scatter(np.random.random(10), np.random.random(10)); ax3.bar(nut_butter_prices.keys(), nut_butter_prices.values()); ax4.hist(np.random.randn(1000)); In\u00a0[25]: Copied! <pre># Option 2: Create 4 subplots with a single ax variable\nfig, ax = plt.subplots(nrows=2, ncols=2, figsize=(10, 5))\n\n# Index the ax variable to plot data\nax[0, 0].plot(x, x/2);\nax[0, 1].scatter(np.random.random(10), np.random.random(10));\nax[1, 0].bar(nut_butter_prices.keys(), nut_butter_prices.values());\nax[1, 1].hist(np.random.randn(1000));\n</pre> # Option 2: Create 4 subplots with a single ax variable fig, ax = plt.subplots(nrows=2, ncols=2, figsize=(10, 5))  # Index the ax variable to plot data ax[0, 0].plot(x, x/2); ax[0, 1].scatter(np.random.random(10), np.random.random(10)); ax[1, 0].bar(nut_butter_prices.keys(), nut_butter_prices.values()); ax[1, 1].hist(np.random.randn(1000)); In\u00a0[26]: Copied! <pre>import pandas as pd\n</pre> import pandas as pd <p>Now we need some data to check out.</p> In\u00a0[28]: Copied! <pre># Let's import the car_sales dataset \n# Note: The following two lines load the same data, one does it from a local file path, the other does it from a URL.\n# car_sales = pd.read_csv(\"../data/car-sales.csv\") # load data from local file\ncar_sales = pd.read_csv(\"https://raw.githubusercontent.com/mrdbourke/zero-to-mastery-ml/master/data/car-sales.csv\") # load data from raw URL (original: https://github.com/mrdbourke/zero-to-mastery-ml/blob/master/data/car-sales.csv)\ncar_sales\n</pre> # Let's import the car_sales dataset  # Note: The following two lines load the same data, one does it from a local file path, the other does it from a URL. # car_sales = pd.read_csv(\"../data/car-sales.csv\") # load data from local file car_sales = pd.read_csv(\"https://raw.githubusercontent.com/mrdbourke/zero-to-mastery-ml/master/data/car-sales.csv\") # load data from raw URL (original: https://github.com/mrdbourke/zero-to-mastery-ml/blob/master/data/car-sales.csv) car_sales Out[28]: Make Colour Odometer (KM) Doors Price 0 Toyota White 150043 4 $4,000.00 1 Honda Red 87899 4 $5,000.00 2 Toyota Blue 32549 3 $7,000.00 3 BMW Black 11179 5 $22,000.00 4 Nissan White 213095 4 $3,500.00 5 Toyota Green 99213 4 $4,500.00 6 Honda Blue 45698 4 $7,500.00 7 Honda Blue 54738 4 $7,000.00 8 Toyota White 60000 4 $6,250.00 9 Nissan White 31600 4 $9,700.00 In\u00a0[29]: Copied! <pre># Start with some dummy data\nts = pd.Series(np.random.randn(1000),\n               index=pd.date_range('1/1/2025', periods=1000))\n\n# Note: ts = short for time series (data over time)\nts\n</pre> # Start with some dummy data ts = pd.Series(np.random.randn(1000),                index=pd.date_range('1/1/2025', periods=1000))  # Note: ts = short for time series (data over time) ts Out[29]: <pre>2025-01-01    1.724020\n2025-01-02   -0.530374\n2025-01-03    2.247190\n2025-01-04    0.077367\n2025-01-05   -1.035777\n                ...   \n2027-09-23   -1.467224\n2027-09-24   -0.588671\n2027-09-25   -0.394004\n2027-09-26    1.327045\n2027-09-27   -0.160190\nFreq: D, Length: 1000, dtype: float64</pre> <p>Great! We've got some random values across time.</p> <p>Now let's add up the data cumulatively overtime with <code>DataFrame.cumsum()</code> (<code>cumsum</code> is short for cumulative sum or continaully adding one thing to the next and so on).</p> In\u00a0[30]: Copied! <pre># Add up the values cumulatively\nts.cumsum()\n</pre> # Add up the values cumulatively ts.cumsum() Out[30]: <pre>2025-01-01     1.724020\n2025-01-02     1.193646\n2025-01-03     3.440836\n2025-01-04     3.518203\n2025-01-05     2.482426\n                ...    \n2027-09-23    32.888806\n2027-09-24    32.300135\n2027-09-25    31.906130\n2027-09-26    33.233175\n2027-09-27    33.072985\nFreq: D, Length: 1000, dtype: float64</pre> <p>We can now visualize the values by calling the <code>plot()</code> method on the DataFrame and specifying the kind of plot we'd like with the <code>kind</code> parameter.</p> <p>In our case, the kind we'd like is a line plot, hence <code>kind=\"line\"</code> (this is the default for the <code>plot()</code> method).</p> In\u00a0[31]: Copied! <pre># Plot the values over time with a line plot (note: both of these will return the same thing)\n# ts.cumsum().plot() # kind=\"line\" is set by default\nts.cumsum().plot(kind=\"line\");\n</pre> # Plot the values over time with a line plot (note: both of these will return the same thing) # ts.cumsum().plot() # kind=\"line\" is set by default ts.cumsum().plot(kind=\"line\"); In\u00a0[32]: Copied! <pre># Import the car sales data \ncar_sales = pd.read_csv(\"https://raw.githubusercontent.com/mrdbourke/zero-to-mastery-ml/master/data/car-sales.csv\")\n\n# Remove price column symbols\ncar_sales[\"Price\"] = car_sales[\"Price\"].str.replace('[\\$\\,\\.]', '', \n                                                    regex=True) # Tell pandas to replace using regex\ncar_sales\n</pre> # Import the car sales data  car_sales = pd.read_csv(\"https://raw.githubusercontent.com/mrdbourke/zero-to-mastery-ml/master/data/car-sales.csv\")  # Remove price column symbols car_sales[\"Price\"] = car_sales[\"Price\"].str.replace('[\\$\\,\\.]', '',                                                      regex=True) # Tell pandas to replace using regex car_sales Out[32]: Make Colour Odometer (KM) Doors Price 0 Toyota White 150043 4 400000 1 Honda Red 87899 4 500000 2 Toyota Blue 32549 3 700000 3 BMW Black 11179 5 2200000 4 Nissan White 213095 4 350000 5 Toyota Green 99213 4 450000 6 Honda Blue 45698 4 750000 7 Honda Blue 54738 4 700000 8 Toyota White 60000 4 625000 9 Nissan White 31600 4 970000 In\u00a0[33]: Copied! <pre># Remove last two zeros\ncar_sales[\"Price\"] = car_sales[\"Price\"].str[:-2]\ncar_sales\n</pre> # Remove last two zeros car_sales[\"Price\"] = car_sales[\"Price\"].str[:-2] car_sales Out[33]: Make Colour Odometer (KM) Doors Price 0 Toyota White 150043 4 4000 1 Honda Red 87899 4 5000 2 Toyota Blue 32549 3 7000 3 BMW Black 11179 5 22000 4 Nissan White 213095 4 3500 5 Toyota Green 99213 4 4500 6 Honda Blue 45698 4 7500 7 Honda Blue 54738 4 7000 8 Toyota White 60000 4 6250 9 Nissan White 31600 4 9700 In\u00a0[34]: Copied! <pre># Add a date column\ncar_sales[\"Sale Date\"] = pd.date_range(\"1/1/2024\", periods=len(car_sales))\ncar_sales\n</pre> # Add a date column car_sales[\"Sale Date\"] = pd.date_range(\"1/1/2024\", periods=len(car_sales)) car_sales Out[34]: Make Colour Odometer (KM) Doors Price Sale Date 0 Toyota White 150043 4 4000 2024-01-01 1 Honda Red 87899 4 5000 2024-01-02 2 Toyota Blue 32549 3 7000 2024-01-03 3 BMW Black 11179 5 22000 2024-01-04 4 Nissan White 213095 4 3500 2024-01-05 5 Toyota Green 99213 4 4500 2024-01-06 6 Honda Blue 45698 4 7500 2024-01-07 7 Honda Blue 54738 4 7000 2024-01-08 8 Toyota White 60000 4 6250 2024-01-09 9 Nissan White 31600 4 9700 2024-01-10 In\u00a0[35]: Copied! <pre># Make total sales column (doesn't work, adds as string)\n#car_sales[\"Total Sales\"] = car_sales[\"Price\"].cumsum()\n\n# Oops... want them as int's not string\ncar_sales[\"Total Sales\"] = car_sales[\"Price\"].astype(int).cumsum()\ncar_sales\n</pre> # Make total sales column (doesn't work, adds as string) #car_sales[\"Total Sales\"] = car_sales[\"Price\"].cumsum()  # Oops... want them as int's not string car_sales[\"Total Sales\"] = car_sales[\"Price\"].astype(int).cumsum() car_sales Out[35]: Make Colour Odometer (KM) Doors Price Sale Date Total Sales 0 Toyota White 150043 4 4000 2024-01-01 4000 1 Honda Red 87899 4 5000 2024-01-02 9000 2 Toyota Blue 32549 3 7000 2024-01-03 16000 3 BMW Black 11179 5 22000 2024-01-04 38000 4 Nissan White 213095 4 3500 2024-01-05 41500 5 Toyota Green 99213 4 4500 2024-01-06 46000 6 Honda Blue 45698 4 7500 2024-01-07 53500 7 Honda Blue 54738 4 7000 2024-01-08 60500 8 Toyota White 60000 4 6250 2024-01-09 66750 9 Nissan White 31600 4 9700 2024-01-10 76450 In\u00a0[36]: Copied! <pre>car_sales.plot(x='Sale Date', y='Total Sales');\n</pre> car_sales.plot(x='Sale Date', y='Total Sales'); In\u00a0[37]: Copied! <pre># Note: In previous versions of matplotlib and pandas, have the \"Price\" column as a string would\n# return an error\ncar_sales[\"Price\"] = car_sales[\"Price\"].astype(str)\n\n# Plot a scatter plot\ncar_sales.plot(x=\"Odometer (KM)\", y=\"Price\", kind=\"scatter\");\n</pre> # Note: In previous versions of matplotlib and pandas, have the \"Price\" column as a string would # return an error car_sales[\"Price\"] = car_sales[\"Price\"].astype(str)  # Plot a scatter plot car_sales.plot(x=\"Odometer (KM)\", y=\"Price\", kind=\"scatter\"); <p>Having the <code>Price</code> column as an <code>int</code> returns a much better looking y-axis.</p> In\u00a0[38]: Copied! <pre># Convert Price to int\ncar_sales[\"Price\"] = car_sales[\"Price\"].astype(int)\n\n# Plot a scatter plot\ncar_sales.plot(x=\"Odometer (KM)\", y=\"Price\", kind='scatter');\n</pre> # Convert Price to int car_sales[\"Price\"] = car_sales[\"Price\"].astype(int)  # Plot a scatter plot car_sales.plot(x=\"Odometer (KM)\", y=\"Price\", kind='scatter'); In\u00a0[39]: Copied! <pre># Create 10 random samples across 4 columns\nx = np.random.rand(10, 4)\nx\n</pre> # Create 10 random samples across 4 columns x = np.random.rand(10, 4) x Out[39]: <pre>array([[0.63664747, 0.11886476, 0.96687683, 0.62490457],\n       [0.9623542 , 0.75100119, 0.08098382, 0.83857796],\n       [0.49430885, 0.00545069, 0.89374991, 0.99877205],\n       [0.89788013, 0.15844467, 0.50083739, 0.72846574],\n       [0.51719877, 0.00978263, 0.74440314, 0.70385373],\n       [0.17211921, 0.42804418, 0.16401737, 0.66153094],\n       [0.39768996, 0.00628579, 0.71681382, 0.83828817],\n       [0.75507146, 0.73571561, 0.30901804, 0.4720662 ],\n       [0.46070935, 0.93093698, 0.01335433, 0.91765471],\n       [0.77798775, 0.70517195, 0.05298553, 0.68972541]])</pre> In\u00a0[40]: Copied! <pre># Turn the data into a DataFrame\ndf = pd.DataFrame(x, columns=['a', 'b', 'c', 'd'])\ndf\n</pre> # Turn the data into a DataFrame df = pd.DataFrame(x, columns=['a', 'b', 'c', 'd']) df Out[40]: a b c d 0 0.636647 0.118865 0.966877 0.624905 1 0.962354 0.751001 0.080984 0.838578 2 0.494309 0.005451 0.893750 0.998772 3 0.897880 0.158445 0.500837 0.728466 4 0.517199 0.009783 0.744403 0.703854 5 0.172119 0.428044 0.164017 0.661531 6 0.397690 0.006286 0.716814 0.838288 7 0.755071 0.735716 0.309018 0.472066 8 0.460709 0.930937 0.013354 0.917655 9 0.777988 0.705172 0.052986 0.689725 <p>We can plot a bar chart directly with the <code>bar()</code> method on the DataFrame.</p> In\u00a0[41]: Copied! <pre># Plot a bar chart\ndf.plot.bar();\n</pre> # Plot a bar chart df.plot.bar(); <p>And we can also do the same thing passing the <code>kind=\"bar\"</code> parameter to <code>DataFrame.plot()</code>.</p> In\u00a0[42]: Copied! <pre># Plot a bar chart with the kind parameter\ndf.plot(kind='bar');\n</pre> # Plot a bar chart with the kind parameter df.plot(kind='bar'); <p>Let's try a bar plot on the <code>car_sales</code> DataFrame.</p> <p>This time we'll specify the <code>x</code> and <code>y</code> axis values.</p> In\u00a0[43]: Copied! <pre># Plot a bar chart from car_sales DataFrame\ncar_sales.plot(x=\"Make\", \n               y=\"Odometer (KM)\", \n               kind=\"bar\");\n</pre> # Plot a bar chart from car_sales DataFrame car_sales.plot(x=\"Make\",                 y=\"Odometer (KM)\",                 kind=\"bar\"); In\u00a0[44]: Copied! <pre>car_sales[\"Odometer (KM)\"].plot.hist(bins=10); # default number of bins (or groups) is 10\n</pre> car_sales[\"Odometer (KM)\"].plot.hist(bins=10); # default number of bins (or groups) is 10 In\u00a0[45]: Copied! <pre>car_sales[\"Odometer (KM)\"].plot(kind=\"hist\");\n</pre> car_sales[\"Odometer (KM)\"].plot(kind=\"hist\"); <p>Changing the <code>bins</code> parameter we can put our data into different numbers of collections.</p> <p>For example, by default <code>bins=10</code> (10 groups of data), let's see what happens when we change it to <code>bins=20</code>.</p> In\u00a0[46]: Copied! <pre># Default number of bins is 10 \ncar_sales[\"Odometer (KM)\"].plot.hist(bins=20);\n</pre> # Default number of bins is 10  car_sales[\"Odometer (KM)\"].plot.hist(bins=20); <p>To practice, let's create a histogram of the <code>Price</code> column.</p> In\u00a0[47]: Copied! <pre># Create a histogram of the Price column\ncar_sales[\"Price\"].plot.hist(bins=10);\n</pre> # Create a histogram of the Price column car_sales[\"Price\"].plot.hist(bins=10); <p>And to practice even further, how about we try another dataset?</p> <p>Namely, let's create some plots using the heart disease dataset we've worked on before.</p> In\u00a0[48]: Copied! <pre># Import the heart disease dataset\n# Note: The following two lines create the same DataFrame, one just loads data from a local filepath where as the other downloads it directly from a URL.\n\n# heart_disease = pd.read_csv(\"../data/heart-disease.csv\") # load from local file path (requires data to be downloaded)\nheart_disease = pd.read_csv(\"https://raw.githubusercontent.com/mrdbourke/zero-to-mastery-ml/master/data/heart-disease.csv\") # load directly from raw URL (source: https://github.com/mrdbourke/zero-to-mastery-ml/blob/master/data/heart-disease.csv)\nheart_disease.head()\n</pre> # Import the heart disease dataset # Note: The following two lines create the same DataFrame, one just loads data from a local filepath where as the other downloads it directly from a URL.  # heart_disease = pd.read_csv(\"../data/heart-disease.csv\") # load from local file path (requires data to be downloaded) heart_disease = pd.read_csv(\"https://raw.githubusercontent.com/mrdbourke/zero-to-mastery-ml/master/data/heart-disease.csv\") # load directly from raw URL (source: https://github.com/mrdbourke/zero-to-mastery-ml/blob/master/data/heart-disease.csv) heart_disease.head() Out[48]: age sex cp trestbps chol fbs restecg thalach exang oldpeak slope ca thal target 0 63 1 3 145 233 1 0 150 0 2.3 0 0 1 1 1 37 1 2 130 250 0 1 187 0 3.5 0 0 2 1 2 41 0 1 130 204 0 0 172 0 1.4 2 0 2 1 3 56 1 1 120 236 0 1 178 0 0.8 2 0 2 1 4 57 0 0 120 354 0 1 163 1 0.6 2 0 2 1 In\u00a0[49]: Copied! <pre># Create a histogram of the age column\nheart_disease[\"age\"].plot.hist(bins=50);\n</pre> # Create a histogram of the age column heart_disease[\"age\"].plot.hist(bins=50); <p>What does this tell you about the spread of heart disease data across different ages?</p> In\u00a0[50]: Copied! <pre># Inspect the data\nheart_disease.head()\n</pre> # Inspect the data heart_disease.head() Out[50]: age sex cp trestbps chol fbs restecg thalach exang oldpeak slope ca thal target 0 63 1 3 145 233 1 0 150 0 2.3 0 0 1 1 1 37 1 2 130 250 0 1 187 0 3.5 0 0 2 1 2 41 0 1 130 204 0 0 172 0 1.4 2 0 2 1 3 56 1 1 120 236 0 1 178 0 0.8 2 0 2 1 4 57 0 0 120 354 0 1 163 1 0.6 2 0 2 1 <p>Since all of our columns are numeric in value, let's try and create a histogram of each column.</p> In\u00a0[51]: Copied! <pre>heart_disease.plot.hist(figsize=(5, 20), \n                        subplots=True);\n</pre> heart_disease.plot.hist(figsize=(5, 20),                          subplots=True); <p>Hmmm... is this a very helpful plot?</p> <p>Perhaps not.</p> <p>Sometimes you can visualize too much on the one plot and it becomes confusing.</p> <p>Best to start with less and gradually increase.</p> In\u00a0[52]: Copied! <pre># Perform data analysis on patients over 50\nover_50 = heart_disease[heart_disease[\"age\"] &gt; 50]\nover_50\n</pre> # Perform data analysis on patients over 50 over_50 = heart_disease[heart_disease[\"age\"] &gt; 50] over_50 Out[52]: age sex cp trestbps chol fbs restecg thalach exang oldpeak slope ca thal target 0 63 1 3 145 233 1 0 150 0 2.3 0 0 1 1 3 56 1 1 120 236 0 1 178 0 0.8 2 0 2 1 4 57 0 0 120 354 0 1 163 1 0.6 2 0 2 1 5 57 1 0 140 192 0 1 148 0 0.4 1 0 1 1 6 56 0 1 140 294 0 0 153 0 1.3 1 0 2 1 ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... 297 59 1 0 164 176 1 0 90 0 1.0 1 2 1 0 298 57 0 0 140 241 0 1 123 1 0.2 1 0 3 0 300 68 1 0 144 193 1 1 141 0 3.4 1 2 3 0 301 57 1 0 130 131 0 1 115 1 1.2 1 1 3 0 302 57 0 1 130 236 0 0 174 0 0.0 1 1 2 0 <p>208 rows \u00d7 14 columns</p> <p>Now let's create a scatter plot directly from the pandas DataFrame.</p> <p>This is quite easy to do but is a bit limited in terms of customization.</p> <p>Let's visualize patients over 50 cholesterol levels.</p> <p>We can visualize which patients have or don't have heart disease by colouring the samples to be in line with the <code>target</code> column (e.g. <code>0</code> = no heart disease, <code>1</code> = heart disease).</p> In\u00a0[53]: Copied! <pre># Create a scatter plot directly from the pandas DataFrame\nover_50.plot(kind=\"scatter\",\n             x=\"age\", \n             y=\"chol\", \n             c=\"target\", # colour the dots by target value\n             figsize=(10, 6));\n</pre> # Create a scatter plot directly from the pandas DataFrame over_50.plot(kind=\"scatter\",              x=\"age\",               y=\"chol\",               c=\"target\", # colour the dots by target value              figsize=(10, 6)); <p>We can recreate the same plot using <code>plt.subplots()</code> and then passing the Axes variable (<code>ax</code>) to the pandas <code>plot()</code> method.</p> In\u00a0[54]: Copied! <pre># Create a Figure and Axes instance\nfig, ax = plt.subplots(figsize=(10, 6))\n\n# Plot data from the DataFrame to the ax object\nover_50.plot(kind=\"scatter\", \n             x=\"age\", \n             y=\"chol\", \n             c=\"target\", \n             ax=ax); # set the target Axes\n\n# Customize the x-axis limits (to be within our target age ranges)\nax.set_xlim([45, 100]);\n</pre> # Create a Figure and Axes instance fig, ax = plt.subplots(figsize=(10, 6))  # Plot data from the DataFrame to the ax object over_50.plot(kind=\"scatter\",               x=\"age\",               y=\"chol\",               c=\"target\",               ax=ax); # set the target Axes  # Customize the x-axis limits (to be within our target age ranges) ax.set_xlim([45, 100]); <p>Now instead of plotting directly from the pandas DataFrame, we can make a bit more of a comprehensive plot by plotting data directly to a target Axes instance.</p> In\u00a0[55]: Copied! <pre># Create Figure and Axes instance\nfig, ax = plt.subplots(figsize=(10, 6))\n\n# Plot data directly to the Axes intance\nscatter = ax.scatter(over_50[\"age\"], \n                     over_50[\"chol\"], \n                     c=over_50[\"target\"]) # Colour the data with the \"target\" column\n\n# Customize the plot parameters \nax.set(title=\"Heart Disease and Cholesterol Levels\",\n       xlabel=\"Age\",\n       ylabel=\"Cholesterol\");\n\n# Setup the legend\nax.legend(*scatter.legend_elements(), \n          title=\"Target\");\n</pre> # Create Figure and Axes instance fig, ax = plt.subplots(figsize=(10, 6))  # Plot data directly to the Axes intance scatter = ax.scatter(over_50[\"age\"],                       over_50[\"chol\"],                       c=over_50[\"target\"]) # Colour the data with the \"target\" column  # Customize the plot parameters  ax.set(title=\"Heart Disease and Cholesterol Levels\",        xlabel=\"Age\",        ylabel=\"Cholesterol\");  # Setup the legend ax.legend(*scatter.legend_elements(),            title=\"Target\"); <p>What if we wanted a horizontal line going across with the mean of <code>heart_disease[\"chol\"]</code>?</p> <p>We do so with the <code>Axes.axhline()</code> method.</p> In\u00a0[56]: Copied! <pre># Create the plot\nfig, ax = plt.subplots(figsize=(10, 6))\n\n# Plot the data\nscatter = ax.scatter(over_50[\"age\"], \n                     over_50[\"chol\"], \n                     c=over_50[\"target\"])\n\n# Customize the plot\nax.set(title=\"Heart Disease and Cholesterol Levels\",\n       xlabel=\"Age\",\n       ylabel=\"Cholesterol\");\n\n# Add a legned\nax.legend(*scatter.legend_elements(), \n          title=\"Target\")\n\n# Add a meanline\nax.axhline(over_50[\"chol\"].mean(),\n           linestyle=\"--\"); # style the line to make it look nice\n</pre> # Create the plot fig, ax = plt.subplots(figsize=(10, 6))  # Plot the data scatter = ax.scatter(over_50[\"age\"],                       over_50[\"chol\"],                       c=over_50[\"target\"])  # Customize the plot ax.set(title=\"Heart Disease and Cholesterol Levels\",        xlabel=\"Age\",        ylabel=\"Cholesterol\");  # Add a legned ax.legend(*scatter.legend_elements(),            title=\"Target\")  # Add a meanline ax.axhline(over_50[\"chol\"].mean(),            linestyle=\"--\"); # style the line to make it look nice In\u00a0[57]: Copied! <pre># Setup plot (2 rows, 1 column)\nfig, (ax0, ax1) = plt.subplots(nrows=2, # 2 rows\n                               ncols=1, # 1 column \n                               sharex=True, # both plots should use the same x-axis \n                               figsize=(10, 8))\n\n# ---------- Axis 0: Heart Disease and Cholesterol Levels ----------\n\n# Add data for ax0\nscatter = ax0.scatter(over_50[\"age\"], \n                      over_50[\"chol\"], \n                      c=over_50[\"target\"])\n# Customize ax0\nax0.set(title=\"Heart Disease and Cholesterol Levels\",\n        ylabel=\"Cholesterol\")\nax0.legend(*scatter.legend_elements(), title=\"Target\")\n\n# Setup a mean line\nax0.axhline(y=over_50[\"chol\"].mean(), \n            color='b', \n            linestyle='--', \n            label=\"Average\")\n\n# ---------- Axis 1: Heart Disease and Max Heart Rate Levels ----------\n\n# Add data for ax1\nscatter = ax1.scatter(over_50[\"age\"], \n                      over_50[\"thalach\"], \n                      c=over_50[\"target\"])\n\n# Customize ax1\nax1.set(title=\"Heart Disease and Max Heart Rate Levels\",\n        xlabel=\"Age\",\n        ylabel=\"Max Heart Rate\")\nax1.legend(*scatter.legend_elements(), title=\"Target\")\n\n# Setup a mean line\nax1.axhline(y=over_50[\"thalach\"].mean(), \n            color='b', \n            linestyle='--', \n            label=\"Average\")\n\n# Title the figure\nfig.suptitle('Heart Disease Analysis', \n             fontsize=16, \n             fontweight='bold');\n</pre> # Setup plot (2 rows, 1 column) fig, (ax0, ax1) = plt.subplots(nrows=2, # 2 rows                                ncols=1, # 1 column                                 sharex=True, # both plots should use the same x-axis                                 figsize=(10, 8))  # ---------- Axis 0: Heart Disease and Cholesterol Levels ----------  # Add data for ax0 scatter = ax0.scatter(over_50[\"age\"],                        over_50[\"chol\"],                        c=over_50[\"target\"]) # Customize ax0 ax0.set(title=\"Heart Disease and Cholesterol Levels\",         ylabel=\"Cholesterol\") ax0.legend(*scatter.legend_elements(), title=\"Target\")  # Setup a mean line ax0.axhline(y=over_50[\"chol\"].mean(),              color='b',              linestyle='--',              label=\"Average\")  # ---------- Axis 1: Heart Disease and Max Heart Rate Levels ----------  # Add data for ax1 scatter = ax1.scatter(over_50[\"age\"],                        over_50[\"thalach\"],                        c=over_50[\"target\"])  # Customize ax1 ax1.set(title=\"Heart Disease and Max Heart Rate Levels\",         xlabel=\"Age\",         ylabel=\"Max Heart Rate\") ax1.legend(*scatter.legend_elements(), title=\"Target\")  # Setup a mean line ax1.axhline(y=over_50[\"thalach\"].mean(),              color='b',              linestyle='--',              label=\"Average\")  # Title the figure fig.suptitle('Heart Disease Analysis',               fontsize=16,               fontweight='bold'); In\u00a0[60]: Copied! <pre># Check the available styles\nplt.style.available\n</pre> # Check the available styles plt.style.available Out[60]: <pre>['Solarize_Light2',\n '_classic_test_patch',\n '_mpl-gallery',\n '_mpl-gallery-nogrid',\n 'bmh',\n 'classic',\n 'dark_background',\n 'fast',\n 'fivethirtyeight',\n 'ggplot',\n 'grayscale',\n 'seaborn-v0_8',\n 'seaborn-v0_8-bright',\n 'seaborn-v0_8-colorblind',\n 'seaborn-v0_8-dark',\n 'seaborn-v0_8-dark-palette',\n 'seaborn-v0_8-darkgrid',\n 'seaborn-v0_8-deep',\n 'seaborn-v0_8-muted',\n 'seaborn-v0_8-notebook',\n 'seaborn-v0_8-paper',\n 'seaborn-v0_8-pastel',\n 'seaborn-v0_8-poster',\n 'seaborn-v0_8-talk',\n 'seaborn-v0_8-ticks',\n 'seaborn-v0_8-white',\n 'seaborn-v0_8-whitegrid',\n 'tableau-colorblind10']</pre> <p>Before we change the style of a plot, let's remind ourselves what the default plot style looks like.</p> In\u00a0[61]: Copied! <pre># Plot before changing style\ncar_sales[\"Price\"].plot();\n</pre> # Plot before changing style car_sales[\"Price\"].plot(); <p>Wonderful!</p> <p>Now let's change the style of our future plots using the <code>plt.style.use(style)</code> method.</p> <p>Where the <code>style</code> parameter is one of the available matplotlib styles.</p> <p>How about we try <code>\"seaborn-v0_8-whitegrid\"</code> (seaborn is another common visualization library built on top of matplotlib)?</p> In\u00a0[62]: Copied! <pre># Change the style of our future plots\nplt.style.use(\"seaborn-v0_8-whitegrid\")\n</pre> # Change the style of our future plots plt.style.use(\"seaborn-v0_8-whitegrid\") In\u00a0[63]: Copied! <pre># Plot the same plot as before\ncar_sales[\"Price\"].plot();\n</pre> # Plot the same plot as before car_sales[\"Price\"].plot(); <p>Wonderful!</p> <p>Notice the slightly different styling of the plot?</p> <p>Some styles change more than others.</p> <p>How about we try <code>\"fivethirtyeight\"</code>?</p> In\u00a0[64]: Copied! <pre># Change the plot style\nplt.style.use(\"fivethirtyeight\")\n</pre> # Change the plot style plt.style.use(\"fivethirtyeight\") In\u00a0[65]: Copied! <pre>car_sales[\"Price\"].plot();\n</pre> car_sales[\"Price\"].plot(); <p>Ohhh that's a nice looking plot!</p> <p>Does the style carry over for another type of plot?</p> <p>How about we try a scatter plot?</p> In\u00a0[66]: Copied! <pre>car_sales.plot(x=\"Odometer (KM)\", \n               y=\"Price\", \n               kind=\"scatter\");\n</pre> car_sales.plot(x=\"Odometer (KM)\",                 y=\"Price\",                 kind=\"scatter\"); <p>It does!</p> <p>Looks like we may need to adjust the spacing on our x-axis though.</p> <p>What about another style?</p> <p>Let's try <code>\"ggplot\"</code>.</p> In\u00a0[67]: Copied! <pre># Change the plot style\nplt.style.use(\"ggplot\")\n</pre> # Change the plot style plt.style.use(\"ggplot\") In\u00a0[69]: Copied! <pre>car_sales[\"Price\"].plot.hist(bins=10);\n</pre> car_sales[\"Price\"].plot.hist(bins=10); <p>Cool!</p> <p>Now how can we go back to the default style?</p> <p>Hint: with <code>\"default\"</code>.</p> In\u00a0[70]: Copied! <pre># Change the plot style back to the default \nplt.style.use(\"default\")\n</pre> # Change the plot style back to the default  plt.style.use(\"default\") In\u00a0[71]: Copied! <pre>car_sales[\"Price\"].plot.hist();\n</pre> car_sales[\"Price\"].plot.hist(); In\u00a0[72]: Copied! <pre># Create random data\nx = np.random.randn(10, 4)\nx\n</pre> # Create random data x = np.random.randn(10, 4) x Out[72]: <pre>array([[ 1.17212975,  0.46563975, -1.90589871, -1.19235958],\n       [-0.63717099, -0.08598952, -0.14465387,  0.54449588],\n       [-1.60294003,  0.96718789, -0.13203246,  0.37619322],\n       [-1.08186882, -1.7225243 , -1.91029832, -1.42247578],\n       [-0.22936709,  1.79289551,  0.24236151, -0.11114891],\n       [-0.22966661, -0.04768414,  0.74157096, -1.71206472],\n       [-0.15221366, -0.34325158,  0.96609502, -1.03521241],\n       [ 1.09157697, -0.77361491,  0.35805583,  0.91628358],\n       [ 0.15352594, -1.22128756, -0.45763768, -1.3302614 ],\n       [-0.86535615, -0.4931282 , -0.43404157,  0.55973627]])</pre> In\u00a0[73]: Copied! <pre># Turn data into DataFrame with simple column names\ndf = pd.DataFrame(x, \n                  columns=['a', 'b', 'c', 'd'])\ndf\n</pre> # Turn data into DataFrame with simple column names df = pd.DataFrame(x,                    columns=['a', 'b', 'c', 'd']) df Out[73]: a b c d 0 1.172130 0.465640 -1.905899 -1.192360 1 -0.637171 -0.085990 -0.144654 0.544496 2 -1.602940 0.967188 -0.132032 0.376193 3 -1.081869 -1.722524 -1.910298 -1.422476 4 -0.229367 1.792896 0.242362 -0.111149 5 -0.229667 -0.047684 0.741571 -1.712065 6 -0.152214 -0.343252 0.966095 -1.035212 7 1.091577 -0.773615 0.358056 0.916284 8 0.153526 -1.221288 -0.457638 -1.330261 9 -0.865356 -0.493128 -0.434042 0.559736 <p>Now let's plot the data from the DataFrame in a bar chart.</p> <p>This time we'll save the plot to a variable called <code>ax</code> (short for Axes).</p> In\u00a0[74]: Copied! <pre># Create a bar plot\nax = df.plot(kind=\"bar\")\n\n# Check the type of the ax variable\ntype(ax)\n</pre> # Create a bar plot ax = df.plot(kind=\"bar\")  # Check the type of the ax variable type(ax) Out[74]: <pre>matplotlib.axes._axes.Axes</pre> <p>Excellent!</p> <p>We can see the type of our <code>ax</code> variable is of <code>AxesSubplot</code> which allows us to use all of the methods available in matplotlib for <code>Axes</code>.</p> <p>Let's set a few attributes of the plot with the <code>set()</code> method.</p> <p>Namely, we'll change the <code>title</code>, <code>xlabel</code> and <code>ylabel</code> to communicate what's being displayed.</p> In\u00a0[75]: Copied! <pre># Recreate the ax object\nax = df.plot(kind=\"bar\")\n\n# Set various attributes\nax.set(title=\"Random Number Bar Graph from DataFrame\", \n       xlabel=\"Row number\", \n       ylabel=\"Random number\");\n</pre> # Recreate the ax object ax = df.plot(kind=\"bar\")  # Set various attributes ax.set(title=\"Random Number Bar Graph from DataFrame\",         xlabel=\"Row number\",         ylabel=\"Random number\"); <p>Notice the legend is up in the top left corner by default, we can change that if we like with the <code>loc</code> parameter of the <code>legend()</code> method.</p> <p><code>loc</code> can be set as a string to reflect where the legend should be.</p> <p>By default it is set to <code>loc=\"best\"</code> which means matplotlib will try to figure out the best positioning for it.</p> <p>Let's try changing it to <code>\"loc=\"upper right\"</code>.</p> In\u00a0[76]: Copied! <pre># Recreate the ax object\nax = df.plot(kind=\"bar\")\n\n# Set various attributes\nax.set(title=\"Random Number Bar Graph from DataFrame\", \n       xlabel=\"Row number\", \n       ylabel=\"Random number\")\n\n# Change the legend position\nax.legend(loc=\"upper right\");\n</pre> # Recreate the ax object ax = df.plot(kind=\"bar\")  # Set various attributes ax.set(title=\"Random Number Bar Graph from DataFrame\",         xlabel=\"Row number\",         ylabel=\"Random number\")  # Change the legend position ax.legend(loc=\"upper right\"); <p>Nice!</p> <p>Is that a better fit?</p> <p>Perhaps not, but it goes to show how you can change the legend position if needed.</p> In\u00a0[77]: Copied! <pre># Setup the Figure and Axes\nfig, ax = plt.subplots(figsize=(10, 6))\n\n# Create a scatter plot with no cmap change (use default colormap)\nscatter = ax.scatter(over_50[\"age\"], \n                     over_50[\"chol\"], \n                     c=over_50[\"target\"],\n                     cmap=\"viridis\") # default cmap value\n\n# Add attributes to the plot\nax.set(title=\"Heart Disease and Cholesterol Levels\",\n       xlabel=\"Age\",\n       ylabel=\"Cholesterol\");\nax.axhline(y=over_50[\"chol\"].mean(), \n           c='b', \n           linestyle='--', \n           label=\"Average\");\nax.legend(*scatter.legend_elements(), \n          title=\"Target\");\n</pre> # Setup the Figure and Axes fig, ax = plt.subplots(figsize=(10, 6))  # Create a scatter plot with no cmap change (use default colormap) scatter = ax.scatter(over_50[\"age\"],                       over_50[\"chol\"],                       c=over_50[\"target\"],                      cmap=\"viridis\") # default cmap value  # Add attributes to the plot ax.set(title=\"Heart Disease and Cholesterol Levels\",        xlabel=\"Age\",        ylabel=\"Cholesterol\"); ax.axhline(y=over_50[\"chol\"].mean(),             c='b',             linestyle='--',             label=\"Average\"); ax.legend(*scatter.legend_elements(),            title=\"Target\"); <p>Wonderful!</p> <p>That plot doesn't look too bad.</p> <p>But what if we wanted to change the colours?</p> <p>There are many different <code>cmap</code> parameter options available in the colormap reference.</p> <p>How about we try <code>cmap=\"winter\"</code>?</p> <p>We can also change the colour of the horizontal line using the <code>color</code> parameter and setting it to a string of the colour we'd like (e.g. <code>color=\"r\"</code> for red).</p> In\u00a0[78]: Copied! <pre>fig, ax = plt.subplots(figsize=(10, 6))\n\n# Setup scatter plot with different cmap\nscatter = ax.scatter(over_50[\"age\"], \n                     over_50[\"chol\"], \n                     c=over_50[\"target\"], \n                     cmap=\"winter\") # Change cmap value \n\n# Add attributes to the plot with different color line\nax.set(title=\"Heart Disease and Cholesterol Levels\",\n       xlabel=\"Age\",\n       ylabel=\"Cholesterol\")\nax.axhline(y=over_50[\"chol\"].mean(), \n           color=\"r\", # Change color of line to \"r\" (for red)\n           linestyle='--', \n           label=\"Average\");\nax.legend(*scatter.legend_elements(), \n          title=\"Target\");\n</pre> fig, ax = plt.subplots(figsize=(10, 6))  # Setup scatter plot with different cmap scatter = ax.scatter(over_50[\"age\"],                       over_50[\"chol\"],                       c=over_50[\"target\"],                       cmap=\"winter\") # Change cmap value   # Add attributes to the plot with different color line ax.set(title=\"Heart Disease and Cholesterol Levels\",        xlabel=\"Age\",        ylabel=\"Cholesterol\") ax.axhline(y=over_50[\"chol\"].mean(),             color=\"r\", # Change color of line to \"r\" (for red)            linestyle='--',             label=\"Average\"); ax.legend(*scatter.legend_elements(),            title=\"Target\"); <p>Woohoo!</p> <p>The first plot looked nice, but I think I prefer the colours of this new plot better.</p> <p>For more on choosing colormaps in matplotlib, there's a sensational and in-depth tutorial in the matplotlib documentation.</p> In\u00a0[79]: Copied! <pre># Recreate double Axes plot from above with colour updates \nfig, (ax0, ax1) = plt.subplots(nrows=2, \n                               ncols=1, \n                               sharex=True, \n                               figsize=(10, 7))\n\n# ---------- Axis 0 ----------\nscatter = ax0.scatter(over_50[\"age\"], \n                      over_50[\"chol\"], \n                      c=over_50[\"target\"],\n                      cmap=\"winter\")\nax0.set(title=\"Heart Disease and Cholesterol Levels\",\n        ylabel=\"Cholesterol\")\n\n# Setup a mean line\nax0.axhline(y=over_50[\"chol\"].mean(), \n            color=\"r\", \n            linestyle=\"--\", \n            label=\"Average\");\nax0.legend(*scatter.legend_elements(), title=\"Target\")\n\n# ---------- Axis 1 ----------\nscatter = ax1.scatter(over_50[\"age\"], \n                      over_50[\"thalach\"], \n                      c=over_50[\"target\"],\n                      cmap=\"winter\")\nax1.set(title=\"Heart Disease and Max Heart Rate Levels\",\n        xlabel=\"Age\",\n        ylabel=\"Max Heart Rate\")\n\n# Setup a mean line\nax1.axhline(y=over_50[\"thalach\"].mean(), \n            color=\"r\", \n            linestyle=\"--\", \n            label=\"Average\");\nax1.legend(*scatter.legend_elements(), \n           title=\"Target\")\n\n# Title the figure\nfig.suptitle(\"Heart Disease Analysis\", \n             fontsize=16, \n             fontweight=\"bold\");\n</pre> # Recreate double Axes plot from above with colour updates  fig, (ax0, ax1) = plt.subplots(nrows=2,                                 ncols=1,                                 sharex=True,                                 figsize=(10, 7))  # ---------- Axis 0 ---------- scatter = ax0.scatter(over_50[\"age\"],                        over_50[\"chol\"],                        c=over_50[\"target\"],                       cmap=\"winter\") ax0.set(title=\"Heart Disease and Cholesterol Levels\",         ylabel=\"Cholesterol\")  # Setup a mean line ax0.axhline(y=over_50[\"chol\"].mean(),              color=\"r\",              linestyle=\"--\",              label=\"Average\"); ax0.legend(*scatter.legend_elements(), title=\"Target\")  # ---------- Axis 1 ---------- scatter = ax1.scatter(over_50[\"age\"],                        over_50[\"thalach\"],                        c=over_50[\"target\"],                       cmap=\"winter\") ax1.set(title=\"Heart Disease and Max Heart Rate Levels\",         xlabel=\"Age\",         ylabel=\"Max Heart Rate\")  # Setup a mean line ax1.axhline(y=over_50[\"thalach\"].mean(),              color=\"r\",              linestyle=\"--\",              label=\"Average\"); ax1.legend(*scatter.legend_elements(),             title=\"Target\")  # Title the figure fig.suptitle(\"Heart Disease Analysis\",               fontsize=16,               fontweight=\"bold\"); <p>Now let's recreate the plot from above but this time we'll change the axis limits.</p> <p>We can do so by using <code>Axes.set(xlim=[50, 80])</code> or <code>Axes.set(ylim=[60, 220])</code> where the inputs to <code>xlim</code> and <code>ylim</code> are a list of integers defining a range of values.</p> <p>For example, <code>xlim=[50, 80]</code> will set the x-axis values to start at <code>50</code> and end at <code>80</code>.</p> In\u00a0[80]: Copied! <pre># Recreate the plot from above with custom x and y axis ranges\nfig, (ax0, ax1) = plt.subplots(nrows=2, \n                               ncols=1, \n                               sharex=True, \n                               figsize=(10, 7))\nscatter = ax0.scatter(over_50[\"age\"], \n                      over_50[\"chol\"], \n                      c=over_50[\"target\"],\n                      cmap='winter')\nax0.set(title=\"Heart Disease and Cholesterol Levels\",\n        ylabel=\"Cholesterol\",\n        xlim=[50, 80]) # set the x-axis ranges \n\n# Setup a mean line\nax0.axhline(y=over_50[\"chol\"].mean(), \n            color=\"r\", \n            linestyle=\"--\", \n            label=\"Average\");\nax0.legend(*scatter.legend_elements(), title=\"Target\")\n\n# Axis 1, 1 (row 1, column 1)\nscatter = ax1.scatter(over_50[\"age\"], \n                      over_50[\"thalach\"], \n                      c=over_50[\"target\"],\n                      cmap='winter')\nax1.set(title=\"Heart Disease and Max Heart Rate Levels\",\n        xlabel=\"Age\",\n        ylabel=\"Max Heart Rate\",\n        ylim=[60, 220]) # change the y-axis range\n\n# Setup a mean line\nax1.axhline(y=over_50[\"thalach\"].mean(), \n            color=\"r\", \n            linestyle=\"--\", \n            label=\"Average\");\nax1.legend(*scatter.legend_elements(), \n           title=\"Target\")\n\n# Title the figure\nfig.suptitle(\"Heart Disease Analysis\", \n             fontsize=16, \n             fontweight=\"bold\");\n</pre> # Recreate the plot from above with custom x and y axis ranges fig, (ax0, ax1) = plt.subplots(nrows=2,                                 ncols=1,                                 sharex=True,                                 figsize=(10, 7)) scatter = ax0.scatter(over_50[\"age\"],                        over_50[\"chol\"],                        c=over_50[\"target\"],                       cmap='winter') ax0.set(title=\"Heart Disease and Cholesterol Levels\",         ylabel=\"Cholesterol\",         xlim=[50, 80]) # set the x-axis ranges   # Setup a mean line ax0.axhline(y=over_50[\"chol\"].mean(),              color=\"r\",              linestyle=\"--\",              label=\"Average\"); ax0.legend(*scatter.legend_elements(), title=\"Target\")  # Axis 1, 1 (row 1, column 1) scatter = ax1.scatter(over_50[\"age\"],                        over_50[\"thalach\"],                        c=over_50[\"target\"],                       cmap='winter') ax1.set(title=\"Heart Disease and Max Heart Rate Levels\",         xlabel=\"Age\",         ylabel=\"Max Heart Rate\",         ylim=[60, 220]) # change the y-axis range  # Setup a mean line ax1.axhline(y=over_50[\"thalach\"].mean(),              color=\"r\",              linestyle=\"--\",              label=\"Average\"); ax1.legend(*scatter.legend_elements(),             title=\"Target\")  # Title the figure fig.suptitle(\"Heart Disease Analysis\",               fontsize=16,               fontweight=\"bold\"); <p>Now that's a nice looking plot!</p> <p>Let's figure out how we'd save it.</p> In\u00a0[81]: Copied! <pre># Recreate the plot from above with custom x and y axis ranges\nfig, (ax0, ax1) = plt.subplots(nrows=2, \n                               ncols=1, \n                               sharex=True, \n                               figsize=(10, 7))\nscatter = ax0.scatter(over_50[\"age\"], \n                      over_50[\"chol\"], \n                      c=over_50[\"target\"],\n                      cmap='winter')\nax0.set(title=\"Heart Disease and Cholesterol Levels\",\n        ylabel=\"Cholesterol\",\n        xlim=[50, 80]) # set the x-axis ranges \n\n# Setup a mean line\nax0.axhline(y=over_50[\"chol\"].mean(), \n            color=\"r\", \n            linestyle=\"--\", \n            label=\"Average\");\nax0.legend(*scatter.legend_elements(), title=\"Target\")\n\n# Axis 1, 1 (row 1, column 1)\nscatter = ax1.scatter(over_50[\"age\"], \n                      over_50[\"thalach\"], \n                      c=over_50[\"target\"],\n                      cmap='winter')\nax1.set(title=\"Heart Disease and Max Heart Rate Levels\",\n        xlabel=\"Age\",\n        ylabel=\"Max Heart Rate\",\n        ylim=[60, 220]) # change the y-axis range\n\n# Setup a mean line\nax1.axhline(y=over_50[\"thalach\"].mean(), \n            color=\"r\", \n            linestyle=\"--\", \n            label=\"Average\");\nax1.legend(*scatter.legend_elements(), \n           title=\"Target\")\n\n# Title the figure\nfig.suptitle(\"Heart Disease Analysis\", \n             fontsize=16, \n             fontweight=\"bold\");\n</pre> # Recreate the plot from above with custom x and y axis ranges fig, (ax0, ax1) = plt.subplots(nrows=2,                                 ncols=1,                                 sharex=True,                                 figsize=(10, 7)) scatter = ax0.scatter(over_50[\"age\"],                        over_50[\"chol\"],                        c=over_50[\"target\"],                       cmap='winter') ax0.set(title=\"Heart Disease and Cholesterol Levels\",         ylabel=\"Cholesterol\",         xlim=[50, 80]) # set the x-axis ranges   # Setup a mean line ax0.axhline(y=over_50[\"chol\"].mean(),              color=\"r\",              linestyle=\"--\",              label=\"Average\"); ax0.legend(*scatter.legend_elements(), title=\"Target\")  # Axis 1, 1 (row 1, column 1) scatter = ax1.scatter(over_50[\"age\"],                        over_50[\"thalach\"],                        c=over_50[\"target\"],                       cmap='winter') ax1.set(title=\"Heart Disease and Max Heart Rate Levels\",         xlabel=\"Age\",         ylabel=\"Max Heart Rate\",         ylim=[60, 220]) # change the y-axis range  # Setup a mean line ax1.axhline(y=over_50[\"thalach\"].mean(),              color=\"r\",              linestyle=\"--\",              label=\"Average\"); ax1.legend(*scatter.legend_elements(),             title=\"Target\")  # Title the figure fig.suptitle(\"Heart Disease Analysis\",               fontsize=16,               fontweight=\"bold\"); <p>Nice!</p> <p>We can save our plots to several different kinds of filetypes.</p> <p>And we can check these filetypes with <code>fig.canvas.get_supported_filetypes()</code>.</p> In\u00a0[82]: Copied! <pre># Check the supported filetypes\nfig.canvas.get_supported_filetypes()\n</pre> # Check the supported filetypes fig.canvas.get_supported_filetypes() Out[82]: <pre>{'eps': 'Encapsulated Postscript',\n 'jpg': 'Joint Photographic Experts Group',\n 'jpeg': 'Joint Photographic Experts Group',\n 'pdf': 'Portable Document Format',\n 'pgf': 'PGF code for LaTeX',\n 'png': 'Portable Network Graphics',\n 'ps': 'Postscript',\n 'raw': 'Raw RGBA bitmap',\n 'rgba': 'Raw RGBA bitmap',\n 'svg': 'Scalable Vector Graphics',\n 'svgz': 'Scalable Vector Graphics',\n 'tif': 'Tagged Image File Format',\n 'tiff': 'Tagged Image File Format',\n 'webp': 'WebP Image Format'}</pre> <p>Image filetypes such as <code>jpg</code> and <code>png</code> are excellent for blog posts and presentations.</p> <p>Where as the <code>pgf</code> or <code>pdf</code> filetypes may be better for reports and papers.</p> <p>One last look at our Figure, which is saved to the <code>fig</code> variable.</p> In\u00a0[83]: Copied! <pre>fig\n</pre> fig Out[83]: <p>Beautiful!</p> <p>Now let's save it to file.</p> In\u00a0[84]: Copied! <pre># Save the file\nfig.savefig(fname=\"../images/heart-disease-analysis.png\",\n            dpi=100)\n</pre> # Save the file fig.savefig(fname=\"../images/heart-disease-analysis.png\",             dpi=100) <p>File saved!</p> <p>Let's try and display it.</p> <p>We can do so with the HTML code:</p> <pre><code>&lt;img src=\"../images/heart-disease-analysis.png\" alt=\"a plot showing a heart disease analysis comparing the presense of heart disease, cholesterol levels and heart rate on patients over 50/&gt;\n</code></pre> <p>And changing the cell below to markdown.</p> <p>Note: Because the plot is highly visual, it's import to make sure there is an <code>alt=\"some_text_here\"</code> tag available when displaying the image, as this tag is used to make the plot more accessible to those with visual impairments. For more on displaying images with HTML, see the Mozzila documentation.</p> <p>Finally, if we wanted to start making more and different Figures, we can reset our <code>fig</code> variable by creating another plot.</p> In\u00a0[85]: Copied! <pre># Resets figure\nfig, ax = plt.subplots()\n</pre> # Resets figure fig, ax = plt.subplots() <p>If you're creating plots and saving them like this often, to save writing excess code, you might put it into a function.</p> <p>A function which follows the Matplotlib workflow.</p> In\u00a0[86]: Copied! <pre># Potential matplotlib workflow function\n\ndef plotting_workflow(data):\n    # 1. Manipulate data\n    \n    # 2. Create plot\n    \n    # 3. Plot data\n    \n    # 4. Customize plot\n    \n    # 5. Save plot\n    \n    # 6. Return plot\n    \n    return plot\n</pre> # Potential matplotlib workflow function  def plotting_workflow(data):     # 1. Manipulate data          # 2. Create plot          # 3. Plot data          # 4. Customize plot          # 5. Save plot          # 6. Return plot          return plot"},{"location":"introduction-to-matplotlib/#a-quick-introduction-to-matplotlib","title":"A Quick Introduction to Matplotlib\u00b6","text":""},{"location":"introduction-to-matplotlib/#what-is-matplotlib","title":"What is matplotlib?\u00b6","text":"<p>Matplotlib is a visualization library for Python.</p> <p>As in, if you want to display something in a chart or graph, matplotlib can help you do that programmatically.</p> <p>Many of the graphics you'll see in machine learning research papers or presentations are made with matplotlib.</p> <p></p>"},{"location":"introduction-to-matplotlib/#why-matplotlib","title":"Why matplotlib?\u00b6","text":"<p>Matplotlib is part of the standard Python data stack (pandas, NumPy, matplotlib, Jupyter).</p> <p>It has terrific integration with many other Python libraries.</p> <p>pandas uses matplotlib as a backend to help visualize data in DataFrames.</p>"},{"location":"introduction-to-matplotlib/#what-does-this-notebook-cover","title":"What does this notebook cover?\u00b6","text":"<p>A central idea in matplotlib is the concept of a \"plot\" (hence the name).</p> <p>So we're going to practice making a series of different plots, which is a way to visually represent data.</p> <p>Since there are basically limitless ways to create a plot, we're going to focus on a making and customizing (making them look pretty) a few common types of plots.</p>"},{"location":"introduction-to-matplotlib/#where-can-i-get-help","title":"Where can I get help?\u00b6","text":"<p>If you get stuck or think of something you'd like to do which this notebook doesn't cover, don't fear!</p> <p>The recommended steps you take are:</p> <ol> <li>Try it - Since matplotlib is very friendly, your first step should be to use what you know and try figure out the answer to your own question (getting it wrong is part of the process). If in doubt, run your code.</li> <li>Search for it - If trying it on your own doesn't work, since someone else has probably tried to do something similar, try searching for your problem in the following places (either via a search engine or direct):<ul> <li>matplotlib documentation - the best place for learning all of the vast functionality of matplotlib. Bonus: You can see a series of matplotlib cheatsheets on the matplotlib website.</li> <li>Stack Overflow - this is the developers Q&amp;A hub, it's full of questions and answers of different problems across a wide range of software development topics and chances are, there's one related to your problem.</li> <li>ChatGPT - ChatGPT is very good at explaining code, however, it can make mistakes. Best to verify the code it writes first before using it. Try asking \"Can you explain the following code for me? {your code here}\" and then continue with follow up questions from there. But always be careful using generated code. Avoid blindly copying something you couldn't reproduce yourself with enough effort.</li> </ul> </li> </ol> <p>An example of searching for a matplotlib feature might be:</p> <p>\"how to colour the bars of a matplotlib plot\"</p> <p>Searching this on Google leads to this documentation page on the matplotlib website: https://matplotlib.org/stable/gallery/lines_bars_and_markers/bar_colors.html</p> <p>The next steps here are to read through the post and see if it relates to your problem. If it does, great, take the code/information you need and rewrite it to suit your own problem.</p> <ol> <li>Ask for help - If you've been through the above 2 steps and you're still stuck, you might want to ask your question on Stack Overflow or in the ZTM Discord chat. Remember to be specific as possible and provide details on what you've tried.</li> </ol> <p>Remember, you don't have to learn all of these functions off by heart to begin with.</p> <p>What's most important is remembering to continually ask yourself, \"what am I trying to visualize?\"</p> <p>Start by answering that question and then practicing finding the code which does it.</p> <p>Let's get to visualizing some data!</p>"},{"location":"introduction-to-matplotlib/#0-importing-matplotlib","title":"0. Importing matplotlib\u00b6","text":"<p>We'll start by importing <code>matplotlib.pyplot</code>.</p> <p>Why <code>pyplot</code>?</p> <p>Because <code>pyplot</code> is a submodule for creating interactive plots programmatically.</p> <p><code>pyplot</code> is often imported as the alias <code>plt</code>.</p> <p>Note: In older notebooks and tutorials of matplotlib, you may see the magic command <code>%matplotlib inline</code>. This was required to view plots inside a notebook, however, as of 2020 it is mostly no longer required.</p>"},{"location":"introduction-to-matplotlib/#1-2-ways-of-creating-plots","title":"1. 2 ways of creating plots\u00b6","text":"<p>There are two main ways of creating plots in matplotlib.</p> <ol> <li><code>matplotlib.pyplot.plot()</code> - Recommended for simple plots (e.g. x and y).</li> <li><code>matplotlib.pyplot.XX</code> (where XX can be one of many methods, this is known as the object-oriented API) - Recommended for more complex plots (for example <code>plt.subplots()</code> to create multiple plots on the same Figure, we'll get to this later).</li> </ol> <p>Both of these methods are still often created by building off <code>import matplotlib.pyplot as plt</code> as a base.</p> <p>Let's start simple.</p>"},{"location":"introduction-to-matplotlib/#anatomy-of-a-matplotlib-figure","title":"Anatomy of a Matplotlib Figure\u00b6","text":"<p>Matplotlib offers almost unlimited options for creating plots.</p> <p>However, let's break down some of the main terms.</p> <ul> <li>Figure - The base canvas of all matplotlib plots. The overall thing you're plotting is a Figure, often shortened to <code>fig</code>.</li> <li>Axes - One Figure can have one or multiple Axes, for example, a Figure with multiple suplots could have 4 Axes (2 rows and 2 columns). Often shortened to <code>ax</code>.</li> <li>Axis - A particular dimension of an Axes, for example, the x-axis or y-axis.</li> </ul> <p></p>"},{"location":"introduction-to-matplotlib/#a-quick-matplotlib-workflow","title":"A quick Matplotlib Workflow\u00b6","text":"<p>The following workflow is a standard practice when creating a matplotlib plot:</p> <ol> <li>Import matplotlib - For example, <code>import matplotlib.pyplot as plt</code>).</li> <li>Prepare data - This may be from an existing dataset (data analysis) or from the outputs of a machine learning model (data science).</li> <li>Setup the plot - In other words, create the Figure and various Axes.</li> <li>Plot data to the Axes - Send the relevant data to the target Axes.</li> <li>Cutomize the plot - Add a title, decorate the colours, label each Axis.</li> <li>Save (optional) and show - See what your masterpiece looks like and save it to file if necessary.</li> </ol>"},{"location":"introduction-to-matplotlib/#2-making-the-most-common-type-of-plots-using-numpy-arrays","title":"2. Making the most common type of plots using NumPy arrays\u00b6","text":"<p>Most of figuring out what kind of plot to use is getting a feel for the data, then seeing what kind of plot suits it best.</p> <p>Matplotlib visualizations are built on NumPy arrays. So in this section we'll build some of the most common types of plots using NumPy arrays.</p> <ul> <li>Line plot - <code>ax.plot()</code> (this is the default plot in matplotlib)</li> <li>Scatter plot - <code>ax.scatter()</code></li> <li>Bar plot - <code>ax.bar()</code></li> <li>Histogram plot - <code>ax.hist()</code></li> </ul> <p>We'll see how all of these can be created as a method from <code>matplotlob.pyplot.subplots()</code>.</p> <p>Resource: Remember you can see many of the different kinds of matplotlib plot types in the documentation.</p> <p>To make sure we have access to NumPy, we'll import it as <code>np</code>.</p>"},{"location":"introduction-to-matplotlib/#creating-a-line-plot","title":"Creating a line plot\u00b6","text":"<p>Line is the default type of visualization in Matplotlib. Usually, unless specified otherwise, your plots will start out as lines.</p> <p>Line plots are great for seeing trends over time.</p>"},{"location":"introduction-to-matplotlib/#creating-a-scatter-plot","title":"Creating a scatter plot\u00b6","text":"<p>Scatter plots can be great for when you've got many different individual data points and you'd like to see how they interact with eachother without being connected.</p>"},{"location":"introduction-to-matplotlib/#creating-bar-plots","title":"Creating bar plots\u00b6","text":"<p>Bar plots are great to visualize different amounts of similar themed items.</p> <p>For example, the sales of items at a Nut Butter Store.</p> <p>You can create vertical bar plots with <code>ax.bar()</code> and horizontal bar plots with <code>ax.barh()</code>.</p>"},{"location":"introduction-to-matplotlib/#creating-a-histogram-plot","title":"Creating a histogram plot\u00b6","text":"<p>Histogram plots are excellent for showing the distribution of data.</p> <p>For example, you might want to show the distribution of ages of a population or wages of city.</p>"},{"location":"introduction-to-matplotlib/#creating-figures-with-multiple-axes-with-subplots","title":"Creating Figures with multiple Axes with Subplots\u00b6","text":"<p>Subplots allow you to create multiple Axes on the same Figure (multiple plots within the same plot).</p> <p>Subplots are helpful because you start with one plot per Figure but scale it up to more when necessary.</p> <p>For example, let's create a subplot that shows many of the above datasets on the same Figure.</p> <p>We can do so by creating multiple Axes with <code>plt.subplots()</code> and setting the <code>nrows</code> (number of rows) and <code>ncols</code> (number of columns) parameters to reflect how many Axes we'd like.</p> <p><code>nrows</code> and <code>ncols</code> parameters are multiplicative, meaning <code>plt.subplots(nrows=2, ncols=2)</code> will create <code>2*2=4</code> total Axes.</p> <p>Resource: You can see a sensational number of examples for creating Subplots in the matplotlib documentation.</p>"},{"location":"introduction-to-matplotlib/#3-plotting-data-directly-with-pandas","title":"3. Plotting data directly with pandas\u00b6","text":"<p>Matplotlib has a tight integration with pandas too.</p> <p>You can directly plot from a pandas DataFrame with <code>DataFrame.plot()</code>.</p> <p>Let's see the following plots directly from a pandas DataFrame:</p> <ul> <li>Line</li> <li>Scatter</li> <li>Bar</li> <li>Hist</li> </ul> <p>To plot data with pandas, we first have to import it as <code>pd</code>.</p>"},{"location":"introduction-to-matplotlib/#line-plot-from-a-pandas-dataframe","title":"Line plot from a pandas DataFrame\u00b6","text":"<p>To understand examples, I often find I have to repeat them (code them myself) rather than just read them.</p> <p>To begin understanding plotting with pandas, let's recreate the a section of the pandas Chart visualization documents.</p>"},{"location":"introduction-to-matplotlib/#working-with-actual-data","title":"Working with actual data\u00b6","text":"<p>Let's do a little data manipulation on our <code>car_sales</code> DataFrame.</p>"},{"location":"introduction-to-matplotlib/#scatter-plot-from-a-pandas-dataframe","title":"Scatter plot from a pandas DataFrame\u00b6","text":"<p>You can create scatter plots from a pandas DataFrame by using the <code>kind=\"scatter\"</code> parameter.</p> <p>However, you'll often find that certain plots require certain kinds of data (e.g. some plots require certain columns to be numeric).</p>"},{"location":"introduction-to-matplotlib/#bar-plot-from-a-pandas-dataframe","title":"Bar plot from a pandas DataFrame\u00b6","text":"<p>Let's see how we can plot a bar plot from a pandas DataFrame.</p> <p>First, we'll create some data.</p>"},{"location":"introduction-to-matplotlib/#histogram-plot-from-a-pandas-dataframe","title":"Histogram plot from a pandas DataFrame\u00b6","text":"<p>We can plot a histogram plot from our <code>car_sales</code> DataFrame using <code>DataFrame.plot.hist()</code> or <code>DataFrame.plot(kind=\"hist\")</code>.</p> <p>Histograms are great for seeing the distribution or the spread of data.</p>"},{"location":"introduction-to-matplotlib/#creating-a-plot-with-multiple-axes-from-a-pandas-dataframe","title":"Creating a plot with multiple Axes from a pandas DataFrame\u00b6","text":"<p>We can also create a series of plots (multiple Axes on one Figure) from a DataFrame using the <code>subplots=True</code> parameter.</p> <p>First, let's remind ourselves what the data looks like.</p>"},{"location":"introduction-to-matplotlib/#4-plotting-more-advanced-plots-from-a-pandas-dataframe","title":"4. Plotting more advanced plots from a pandas DataFrame\u00b6","text":"<p>It's possible to achieve far more complicated and detailed plots from a pandas DataFrame.</p> <p>Let's practice using the <code>heart_disease</code> DataFrame.</p> <p>And as an example, let's do some analysis on people over 50 years of age.</p> <p>To do so, let's start by creating a plot directly from pandas and then using the object-orientated API (<code>plt.subplots()</code>) to build upon it.</p>"},{"location":"introduction-to-matplotlib/#plotting-multiple-plots-on-the-same-figure-adding-another-plot-to-an-existing-one","title":"Plotting multiple plots on the same figure (adding another plot to an existing one)\u00b6","text":"<p>Sometimes you'll want to visualize multiple features of a dataset or results of a model in one Figure.</p> <p>You can achieve this by adding data to multiple Axes on the same Figure.</p> <p>The <code>plt.subplots()</code> method helps you create Figures with a desired number of Axes in a desired figuration.</p> <p>Using <code>nrows</code> (number of rows) and <code>ncols</code> (number of columns) parameters you can control the number of Axes on the Figure.</p> <p>For example:</p> <ul> <li><code>nrows=2</code>, <code>ncols=1</code> = 2x1 = a Figure with 2 Axes</li> <li><code>nrows=5</code>, <code>ncols=5</code> = 5x5 = a Figure with 25 Axes</li> </ul> <p>Let's create a plot with 2 Axes.</p> <p>One the first Axes (Axes 0), we'll plot heart disease against cholesterol levels (<code>chol</code>).</p> <p>On the second Axes (Axis 1), we'll plot heart disease against max heart rate levels (<code>thalach</code>).</p>"},{"location":"introduction-to-matplotlib/#5-customizing-your-plots-making-them-look-pretty","title":"5. Customizing your plots (making them look pretty)\u00b6","text":"<p>If you're not a fan of the default matplotlib styling, there are plenty of ways to make your plots look prettier.</p> <p>The more visually appealing your plot, the higher the chance people are going to want to look at them.</p> <p>However, be careful not to overdo the customizations, as they may hinder the information being conveyed.</p> <p>Some of the things you can customize include:</p> <ul> <li>Axis limits - The range in which your data is displayed.</li> <li>Colors - That colors appear on the plot to represent different data.</li> <li>Overall style - Matplotlib has several different styles built-in which offer different overall themes for your plots, you can see examples of these in the matplotlib style sheets reference documentation.</li> <li>Legend - One of the most informative pieces of information on a Figure can be the legend, you can modify the legend of an Axes with the <code>plt.legend()</code> method.</li> </ul> <p>Let's start by exploring different styles built into matplotlib.</p>"},{"location":"introduction-to-matplotlib/#customizing-the-style-of-plots","title":"Customizing the style of plots\u00b6","text":"<p>Matplotlib comes with several built-in styles that are all created with an overall theme.</p> <p>You can see what styles are available by using <code>plt.style.available</code>.</p> <p>Resources:</p> <ul> <li>To see what many of the available styles look like, you can refer to the matplotlib style sheets reference documentation.</li> <li>For a deeper guide on customizing, refer to the Customizing Matplotlib with style sheets and rcParams tutorial.</li> </ul>"},{"location":"introduction-to-matplotlib/#customizing-the-title-legend-and-axis-labels","title":"Customizing the title, legend and axis labels\u00b6","text":"<p>When you have a matplotlib Figure or Axes object, you can customize many of the attributes by using the <code>Axes.set()</code> method.</p> <p>For example, you can change the:</p> <ul> <li><code>xlabel</code> - Labels on the x-axis.</li> <li><code>ylim</code> - Limits of the y-axis.</li> <li><code>xticks</code> - Style of the x-ticks.</li> <li>much more in the documentation.</li> </ul> <p>Rather than talking about it, let's practice!</p> <p>First, we'll create some random data and then put it into a DataFrame.</p> <p>Then we'll make a plot from that DataFrame and see how to customize it.</p>"},{"location":"introduction-to-matplotlib/#customizing-the-colours-of-plots-with-colormaps-cmap","title":"Customizing the colours of plots with colormaps (cmap)\u00b6","text":"<p>Colour is one of the most important features of a plot.</p> <p>It can help to separate different kinds of information.</p> <p>And with the right colours, plots can be fun to look at and try to learn more.</p> <p>Matplotlib provides many different colour options through <code>matplotlib.colormaps</code>.</p> <p>Let's see how we can change the colours of a matplotlib plot via the <code>cmap</code> parameter (<code>cmap</code> is short for <code>colormaps</code>).</p> <p>We'll start by creating a scatter plot with the default <code>cmap</code> value (<code>cmap=\"viridis\"</code>).</p>"},{"location":"introduction-to-matplotlib/#customizing-the-xlim-ylim","title":"Customizing the xlim &amp; ylim\u00b6","text":"<p>Matplotlib is pretty good at setting the ranges of values on the x-axis and the y-axis.</p> <p>But as you might've guessed, you can customize these to suit your needs.</p> <p>You can change the ranges of different axis values using the <code>xlim</code> and <code>ylim</code> parameters inside of the <code>set()</code> method.</p> <p>To practice, let's recreate our double Axes plot from before with the default x-axis and y-axis values.</p> <p>We'll add in the colour updates from the previous section too.</p>"},{"location":"introduction-to-matplotlib/#6-saving-plots","title":"6. Saving plots\u00b6","text":"<p>Once you've got a nice looking plot that you're happy with, the next thing is going to be sharing it with someone else.</p> <p>In a report, blog post, presentation or something similar.</p> <p>You can save matplotlib Figures with <code>plt.savefig(fname=\"your_plot_file_name\")</code> where <code>fname</code> is the target filename you'd like to save the plot to.</p> <p>Before we save our plot, let's recreate it.</p>"},{"location":"introduction-to-matplotlib/#extra-resources","title":"Extra resources\u00b6","text":"<p>We've covered a fair bit here.</p> <p>But really we've only scratched the surface of what's possible with matplotlib.</p> <p>So for more, I'd recommend going through the following:</p> <ul> <li>Matplotlib quick start guide - Try rewriting all the code in this guide to get familiar with it.</li> <li>Matplotlib plot types guide - Inside you'll get an idea of just how many kinds of plots are possible with matplotlib.</li> <li>Matplotlib lifecycle of a plot guide - A sensational ground-up walkthrough of the many different things you can do with a plot.</li> </ul>"},{"location":"introduction-to-numpy/","title":"Introduction to NumPy","text":"<p>View source code | Read notebook in online book format</p> In\u00a0[1]: Copied! <pre>import datetime\nprint(f\"Last updated: {datetime.datetime.now()}\")\n</pre> import datetime print(f\"Last updated: {datetime.datetime.now()}\") <pre>Last updated: 2024-09-05 13:15:36.894029\n</pre> In\u00a0[2]: Copied! <pre>import numpy as np\n\n# Check the version\nprint(np.__version__)\n</pre> import numpy as np  # Check the version print(np.__version__) <pre>2.1.1\n</pre> In\u00a0[3]: Copied! <pre># 1-dimensonal array, also referred to as a vector\na1 = np.array([1, 2, 3])\n\n# 2-dimensional array, also referred to as matrix\na2 = np.array([[1, 2.0, 3.3],\n               [4, 5, 6.5]])\n\n# 3-dimensional array, also referred to as a matrix\na3 = np.array([[[1, 2, 3],\n                [4, 5, 6],\n                [7, 8, 9]],\n                [[10, 11, 12],\n                 [13, 14, 15],\n                 [16, 17, 18]]])\n</pre> # 1-dimensonal array, also referred to as a vector a1 = np.array([1, 2, 3])  # 2-dimensional array, also referred to as matrix a2 = np.array([[1, 2.0, 3.3],                [4, 5, 6.5]])  # 3-dimensional array, also referred to as a matrix a3 = np.array([[[1, 2, 3],                 [4, 5, 6],                 [7, 8, 9]],                 [[10, 11, 12],                  [13, 14, 15],                  [16, 17, 18]]]) In\u00a0[4]: Copied! <pre>a1.shape, a1.ndim, a1.dtype, a1.size, type(a1)\n</pre> a1.shape, a1.ndim, a1.dtype, a1.size, type(a1) Out[4]: <pre>((3,), 1, dtype('int64'), 3, numpy.ndarray)</pre> In\u00a0[5]: Copied! <pre>a2.shape, a2.ndim, a2.dtype, a2.size, type(a2)\n</pre> a2.shape, a2.ndim, a2.dtype, a2.size, type(a2) Out[5]: <pre>((2, 3), 2, dtype('float64'), 6, numpy.ndarray)</pre> In\u00a0[6]: Copied! <pre>a3.shape, a3.ndim, a3.dtype, a3.size, type(a3)\n</pre> a3.shape, a3.ndim, a3.dtype, a3.size, type(a3) Out[6]: <pre>((2, 3, 3), 3, dtype('int64'), 18, numpy.ndarray)</pre> In\u00a0[7]: Copied! <pre>a1\n</pre> a1 Out[7]: <pre>array([1, 2, 3])</pre> In\u00a0[8]: Copied! <pre>a2\n</pre> a2 Out[8]: <pre>array([[1. , 2. , 3.3],\n       [4. , 5. , 6.5]])</pre> In\u00a0[9]: Copied! <pre>a3\n</pre> a3 Out[9]: <pre>array([[[ 1,  2,  3],\n        [ 4,  5,  6],\n        [ 7,  8,  9]],\n\n       [[10, 11, 12],\n        [13, 14, 15],\n        [16, 17, 18]]])</pre> In\u00a0[10]: Copied! <pre>import pandas as pd\ndf = pd.DataFrame(np.random.randint(10, size=(5, 3)), \n                                    columns=['a', 'b', 'c'])\ndf\n</pre> import pandas as pd df = pd.DataFrame(np.random.randint(10, size=(5, 3)),                                      columns=['a', 'b', 'c']) df Out[10]: a b c 0 5 8 0 1 3 3 2 2 1 6 7 3 7 3 9 4 6 6 7 In\u00a0[11]: Copied! <pre>a2\n</pre> a2 Out[11]: <pre>array([[1. , 2. , 3.3],\n       [4. , 5. , 6.5]])</pre> In\u00a0[12]: Copied! <pre>df2 = pd.DataFrame(a2)\ndf2\n</pre> df2 = pd.DataFrame(a2) df2 Out[12]: 0 1 2 0 1.0 2.0 3.3 1 4.0 5.0 6.5 In\u00a0[13]: Copied! <pre># Create a simple array\nsimple_array = np.array([1, 2, 3])\nsimple_array\n</pre> # Create a simple array simple_array = np.array([1, 2, 3]) simple_array Out[13]: <pre>array([1, 2, 3])</pre> In\u00a0[14]: Copied! <pre>simple_array = np.array((1, 2, 3))\nsimple_array, simple_array.dtype\n</pre> simple_array = np.array((1, 2, 3)) simple_array, simple_array.dtype Out[14]: <pre>(array([1, 2, 3]), dtype('int64'))</pre> In\u00a0[15]: Copied! <pre># Create an array of ones\nones = np.ones((10, 2))\nones\n</pre> # Create an array of ones ones = np.ones((10, 2)) ones Out[15]: <pre>array([[1., 1.],\n       [1., 1.],\n       [1., 1.],\n       [1., 1.],\n       [1., 1.],\n       [1., 1.],\n       [1., 1.],\n       [1., 1.],\n       [1., 1.],\n       [1., 1.]])</pre> In\u00a0[16]: Copied! <pre># The default datatype is 'float64'\nones.dtype\n</pre> # The default datatype is 'float64' ones.dtype Out[16]: <pre>dtype('float64')</pre> In\u00a0[17]: Copied! <pre># You can change the datatype with .astype()\nones.astype(int)\n</pre> # You can change the datatype with .astype() ones.astype(int) Out[17]: <pre>array([[1, 1],\n       [1, 1],\n       [1, 1],\n       [1, 1],\n       [1, 1],\n       [1, 1],\n       [1, 1],\n       [1, 1],\n       [1, 1],\n       [1, 1]])</pre> In\u00a0[18]: Copied! <pre># Create an array of zeros\nzeros = np.zeros((5, 3, 3))\nzeros\n</pre> # Create an array of zeros zeros = np.zeros((5, 3, 3)) zeros Out[18]: <pre>array([[[0., 0., 0.],\n        [0., 0., 0.],\n        [0., 0., 0.]],\n\n       [[0., 0., 0.],\n        [0., 0., 0.],\n        [0., 0., 0.]],\n\n       [[0., 0., 0.],\n        [0., 0., 0.],\n        [0., 0., 0.]],\n\n       [[0., 0., 0.],\n        [0., 0., 0.],\n        [0., 0., 0.]],\n\n       [[0., 0., 0.],\n        [0., 0., 0.],\n        [0., 0., 0.]]])</pre> In\u00a0[19]: Copied! <pre>zeros.dtype\n</pre> zeros.dtype Out[19]: <pre>dtype('float64')</pre> In\u00a0[20]: Copied! <pre># Create an array within a range of values\nrange_array = np.arange(0, 10, 2)\nrange_array\n</pre> # Create an array within a range of values range_array = np.arange(0, 10, 2) range_array Out[20]: <pre>array([0, 2, 4, 6, 8])</pre> In\u00a0[21]: Copied! <pre># Random array\nrandom_array = np.random.randint(10, size=(5, 3))\nrandom_array\n</pre> # Random array random_array = np.random.randint(10, size=(5, 3)) random_array Out[21]: <pre>array([[8, 7, 6],\n       [4, 2, 7],\n       [6, 0, 6],\n       [0, 8, 5],\n       [6, 2, 9]])</pre> In\u00a0[22]: Copied! <pre># Random array of floats (between 0 &amp; 1)\nnp.random.random((5, 3))\n</pre> # Random array of floats (between 0 &amp; 1) np.random.random((5, 3)) Out[22]: <pre>array([[0.47811645, 0.49437395, 0.09426995],\n       [0.80062461, 0.41609157, 0.45268566],\n       [0.24531914, 0.56982162, 0.36856519],\n       [0.32292926, 0.03760924, 0.13312765],\n       [0.66844485, 0.88781517, 0.21807957]])</pre> In\u00a0[23]: Copied! <pre>np.random.random((5, 3))\n</pre> np.random.random((5, 3)) Out[23]: <pre>array([[0.96868201, 0.87777028, 0.21900062],\n       [0.88225041, 0.73815918, 0.83321165],\n       [0.14038979, 0.79643185, 0.2741666 ],\n       [0.48166491, 0.74364069, 0.75385132],\n       [0.58920305, 0.43270563, 0.42922598]])</pre> In\u00a0[24]: Copied! <pre># Random 5x3 array of floats (between 0 &amp; 1), similar to above\nnp.random.rand(5, 3)\n</pre> # Random 5x3 array of floats (between 0 &amp; 1), similar to above np.random.rand(5, 3) Out[24]: <pre>array([[0.90225603, 0.76253433, 0.84856067],\n       [0.8961939 , 0.37019149, 0.00568981],\n       [0.78797133, 0.07953581, 0.99870521],\n       [0.07481087, 0.74846133, 0.0788899 ],\n       [0.40156115, 0.80716411, 0.37204142]])</pre> In\u00a0[25]: Copied! <pre>np.random.rand(5, 3)\n</pre> np.random.rand(5, 3) Out[25]: <pre>array([[0.80767414, 0.62863218, 0.32492877],\n       [0.71402148, 0.06601142, 0.16626604],\n       [0.81986587, 0.75875945, 0.73266779],\n       [0.4233863 , 0.52077358, 0.21571921],\n       [0.75862881, 0.65817717, 0.74667541]])</pre> <p>NumPy uses pseudo-random numbers, which means, the numbers look random but aren't really, they're predetermined.</p> <p>For consistency, you might want to keep the random numbers you generate similar throughout experiments.</p> <p>To do this, you can use <code>np.random.seed()</code>.</p> <p>What this does is it tells NumPy, \"Hey, I want you to create random numbers but keep them aligned with the seed.\"</p> <p>Let's see it.</p> In\u00a0[26]: Copied! <pre># Set random seed to 0\nnp.random.seed(0)\n\n# Make 'random' numbers\nnp.random.randint(10, size=(5, 3))\n</pre> # Set random seed to 0 np.random.seed(0)  # Make 'random' numbers np.random.randint(10, size=(5, 3)) Out[26]: <pre>array([[5, 0, 3],\n       [3, 7, 9],\n       [3, 5, 2],\n       [4, 7, 6],\n       [8, 8, 1]])</pre> <p>With <code>np.random.seed()</code> set, every time you run the cell above, the same random numbers will be generated.</p> <p>What if <code>np.random.seed()</code> wasn't set?</p> <p>Every time you run the cell below, a new set of numbers will appear.</p> In\u00a0[27]: Copied! <pre># Make more random numbers\nnp.random.randint(10, size=(5, 3))\n</pre> # Make more random numbers np.random.randint(10, size=(5, 3)) Out[27]: <pre>array([[6, 7, 7],\n       [8, 1, 5],\n       [9, 8, 9],\n       [4, 3, 0],\n       [3, 5, 0]])</pre> <p>Let's see it in action again, we'll stay consistent and set the random seed to 0.</p> In\u00a0[28]: Copied! <pre># Set random seed to same number as above\nnp.random.seed(0)\n\n# The same random numbers come out\nnp.random.randint(10, size=(5, 3))\n</pre> # Set random seed to same number as above np.random.seed(0)  # The same random numbers come out np.random.randint(10, size=(5, 3)) Out[28]: <pre>array([[5, 0, 3],\n       [3, 7, 9],\n       [3, 5, 2],\n       [4, 7, 6],\n       [8, 8, 1]])</pre> <p>Because <code>np.random.seed()</code> is set to 0, the random numbers are the same as the cell with <code>np.random.seed()</code> set to 0 as well.</p> <p>Setting <code>np.random.seed()</code> is not 100% necessary but it's helpful to keep numbers the same throughout your experiments.</p> <p>For example, say you wanted to split your data randomly into training and test sets.</p> <p>Every time you randomly split, you might get different rows in each set.</p> <p>If you shared your work with someone else, they'd get different rows in each set too.</p> <p>Setting <code>np.random.seed()</code> ensures there's still randomness, it just makes the randomness repeatable. Hence the 'pseudo-random' numbers.</p> In\u00a0[29]: Copied! <pre>np.random.seed(0)\ndf = pd.DataFrame(np.random.randint(10, size=(5, 3)))\ndf\n</pre> np.random.seed(0) df = pd.DataFrame(np.random.randint(10, size=(5, 3))) df Out[29]: 0 1 2 0 5 0 3 1 3 7 9 2 3 5 2 3 4 7 6 4 8 8 1 In\u00a0[30]: Copied! <pre># Your code here\n</pre> # Your code here In\u00a0[31]: Copied! <pre>a1\n</pre> a1 Out[31]: <pre>array([1, 2, 3])</pre> In\u00a0[32]: Copied! <pre>a2\n</pre> a2 Out[32]: <pre>array([[1. , 2. , 3.3],\n       [4. , 5. , 6.5]])</pre> In\u00a0[33]: Copied! <pre>a3\n</pre> a3 Out[33]: <pre>array([[[ 1,  2,  3],\n        [ 4,  5,  6],\n        [ 7,  8,  9]],\n\n       [[10, 11, 12],\n        [13, 14, 15],\n        [16, 17, 18]]])</pre> <p>Array shapes are always listed in the format <code>(row, column, n, n, n...)</code> where <code>n</code> is optional extra dimensions.</p> In\u00a0[34]: Copied! <pre>a1[0]\n</pre> a1[0] Out[34]: <pre>np.int64(1)</pre> In\u00a0[35]: Copied! <pre>a2[0]\n</pre> a2[0] Out[35]: <pre>array([1. , 2. , 3.3])</pre> In\u00a0[36]: Copied! <pre>a3[0]\n</pre> a3[0] Out[36]: <pre>array([[1, 2, 3],\n       [4, 5, 6],\n       [7, 8, 9]])</pre> In\u00a0[37]: Copied! <pre># Get 2nd row (index 1) of a2\na2[1]\n</pre> # Get 2nd row (index 1) of a2 a2[1] Out[37]: <pre>array([4. , 5. , 6.5])</pre> In\u00a0[38]: Copied! <pre># Get the first 2 values of the first 2 rows of both arrays\na3[:2, :2, :2]\n</pre> # Get the first 2 values of the first 2 rows of both arrays a3[:2, :2, :2] Out[38]: <pre>array([[[ 1,  2],\n        [ 4,  5]],\n\n       [[10, 11],\n        [13, 14]]])</pre> <p>This takes a bit of practice, especially when the dimensions get higher. Usually, it takes me a little trial and error of trying to get certain values, viewing the output in the notebook and trying again.</p> <p>NumPy arrays get printed from outside to inside. This means the number at the end of the shape comes first, and the number at the start of the shape comes last.</p> In\u00a0[39]: Copied! <pre>a4 = np.random.randint(10, size=(2, 3, 4, 5))\na4\n</pre> a4 = np.random.randint(10, size=(2, 3, 4, 5)) a4 Out[39]: <pre>array([[[[6, 7, 7, 8, 1],\n         [5, 9, 8, 9, 4],\n         [3, 0, 3, 5, 0],\n         [2, 3, 8, 1, 3]],\n\n        [[3, 3, 7, 0, 1],\n         [9, 9, 0, 4, 7],\n         [3, 2, 7, 2, 0],\n         [0, 4, 5, 5, 6]],\n\n        [[8, 4, 1, 4, 9],\n         [8, 1, 1, 7, 9],\n         [9, 3, 6, 7, 2],\n         [0, 3, 5, 9, 4]]],\n\n\n       [[[4, 6, 4, 4, 3],\n         [4, 4, 8, 4, 3],\n         [7, 5, 5, 0, 1],\n         [5, 9, 3, 0, 5]],\n\n        [[0, 1, 2, 4, 2],\n         [0, 3, 2, 0, 7],\n         [5, 9, 0, 2, 7],\n         [2, 9, 2, 3, 3]],\n\n        [[2, 3, 4, 1, 2],\n         [9, 1, 4, 6, 8],\n         [2, 3, 0, 0, 6],\n         [0, 6, 3, 3, 8]]]])</pre> In\u00a0[40]: Copied! <pre>a4.shape\n</pre> a4.shape Out[40]: <pre>(2, 3, 4, 5)</pre> In\u00a0[41]: Copied! <pre># Get only the first 4 numbers of each single vector\na4[:, :, :, :4]\n</pre> # Get only the first 4 numbers of each single vector a4[:, :, :, :4] Out[41]: <pre>array([[[[6, 7, 7, 8],\n         [5, 9, 8, 9],\n         [3, 0, 3, 5],\n         [2, 3, 8, 1]],\n\n        [[3, 3, 7, 0],\n         [9, 9, 0, 4],\n         [3, 2, 7, 2],\n         [0, 4, 5, 5]],\n\n        [[8, 4, 1, 4],\n         [8, 1, 1, 7],\n         [9, 3, 6, 7],\n         [0, 3, 5, 9]]],\n\n\n       [[[4, 6, 4, 4],\n         [4, 4, 8, 4],\n         [7, 5, 5, 0],\n         [5, 9, 3, 0]],\n\n        [[0, 1, 2, 4],\n         [0, 3, 2, 0],\n         [5, 9, 0, 2],\n         [2, 9, 2, 3]],\n\n        [[2, 3, 4, 1],\n         [9, 1, 4, 6],\n         [2, 3, 0, 0],\n         [0, 6, 3, 3]]]])</pre> <p><code>a4</code>'s shape is (2, 3, 4, 5), this means it gets displayed like so:</p> <ul> <li>Inner most array = size 5</li> <li>Next array = size 4</li> <li>Next array = size 3</li> <li>Outer most array = size 2</li> </ul> In\u00a0[42]: Copied! <pre>a1\n</pre> a1 Out[42]: <pre>array([1, 2, 3])</pre> In\u00a0[43]: Copied! <pre>ones = np.ones(3)\nones\n</pre> ones = np.ones(3) ones Out[43]: <pre>array([1., 1., 1.])</pre> In\u00a0[44]: Copied! <pre># Add two arrays\na1 + ones\n</pre> # Add two arrays a1 + ones Out[44]: <pre>array([2., 3., 4.])</pre> In\u00a0[45]: Copied! <pre># Subtract two arrays\na1 - ones\n</pre> # Subtract two arrays a1 - ones Out[45]: <pre>array([0., 1., 2.])</pre> In\u00a0[46]: Copied! <pre># Multiply two arrays\na1 * ones\n</pre> # Multiply two arrays a1 * ones Out[46]: <pre>array([1., 2., 3.])</pre> In\u00a0[47]: Copied! <pre># Multiply two arrays\na1 * a2\n</pre> # Multiply two arrays a1 * a2 Out[47]: <pre>array([[ 1. ,  4. ,  9.9],\n       [ 4. , 10. , 19.5]])</pre> In\u00a0[48]: Copied! <pre>a1.shape, a2.shape\n</pre> a1.shape, a2.shape Out[48]: <pre>((3,), (2, 3))</pre> In\u00a0[49]: Copied! <pre># This will error as the arrays have a different number of dimensions (2, 3) vs. (2, 3, 3) \na2 * a3\n</pre> # This will error as the arrays have a different number of dimensions (2, 3) vs. (2, 3, 3)  a2 * a3 <pre>\n---------------------------------------------------------------------------\nValueError                                Traceback (most recent call last)\nCell In[49], line 2\n      1 # This will error as the arrays have a different number of dimensions (2, 3) vs. (2, 3, 3) \n----&gt; 2 a2 * a3\n\nValueError: operands could not be broadcast together with shapes (2,3) (2,3,3) </pre> In\u00a0[50]: Copied! <pre>a3\n</pre> a3 Out[50]: <pre>array([[[ 1,  2,  3],\n        [ 4,  5,  6],\n        [ 7,  8,  9]],\n\n       [[10, 11, 12],\n        [13, 14, 15],\n        [16, 17, 18]]])</pre> In\u00a0[51]: Copied! <pre>a1\n</pre> a1 Out[51]: <pre>array([1, 2, 3])</pre> In\u00a0[52]: Copied! <pre>a1.shape\n</pre> a1.shape Out[52]: <pre>(3,)</pre> In\u00a0[53]: Copied! <pre>a2.shape\n</pre> a2.shape Out[53]: <pre>(2, 3)</pre> In\u00a0[54]: Copied! <pre>a2\n</pre> a2 Out[54]: <pre>array([[1. , 2. , 3.3],\n       [4. , 5. , 6.5]])</pre> In\u00a0[55]: Copied! <pre>a1 + a2\n</pre> a1 + a2 Out[55]: <pre>array([[2. , 4. , 6.3],\n       [5. , 7. , 9.5]])</pre> In\u00a0[56]: Copied! <pre>a2 + 2\n</pre> a2 + 2 Out[56]: <pre>array([[3. , 4. , 5.3],\n       [6. , 7. , 8.5]])</pre> In\u00a0[57]: Copied! <pre># Raises an error because there's a shape mismatch (2, 3) vs. (2, 3, 3)\na2 + a3\n</pre> # Raises an error because there's a shape mismatch (2, 3) vs. (2, 3, 3) a2 + a3 <pre>\n---------------------------------------------------------------------------\nValueError                                Traceback (most recent call last)\nCell In[57], line 2\n      1 # Raises an error because there's a shape mismatch (2, 3) vs. (2, 3, 3)\n----&gt; 2 a2 + a3\n\nValueError: operands could not be broadcast together with shapes (2,3) (2,3,3) </pre> In\u00a0[58]: Copied! <pre># Divide two arrays\na1 / ones\n</pre> # Divide two arrays a1 / ones Out[58]: <pre>array([1., 2., 3.])</pre> In\u00a0[59]: Copied! <pre># Divide using floor division\na2 // a1\n</pre> # Divide using floor division a2 // a1 Out[59]: <pre>array([[1., 1., 1.],\n       [4., 2., 2.]])</pre> In\u00a0[60]: Copied! <pre># Take an array to a power\na1 ** 2\n</pre> # Take an array to a power a1 ** 2 Out[60]: <pre>array([1, 4, 9])</pre> In\u00a0[61]: Copied! <pre># You can also use np.square()\nnp.square(a1)\n</pre> # You can also use np.square() np.square(a1) Out[61]: <pre>array([1, 4, 9])</pre> In\u00a0[62]: Copied! <pre># Modulus divide (what's the remainder)\na1 % 2\n</pre> # Modulus divide (what's the remainder) a1 % 2 Out[62]: <pre>array([1, 0, 1])</pre> <p>You can also find the log or exponential of an array using <code>np.log()</code> and <code>np.exp()</code>.</p> In\u00a0[63]: Copied! <pre># Find the log of an array\nnp.log(a1)\n</pre> # Find the log of an array np.log(a1) Out[63]: <pre>array([0.        , 0.69314718, 1.09861229])</pre> In\u00a0[64]: Copied! <pre># Find the exponential of an array\nnp.exp(a1)\n</pre> # Find the exponential of an array np.exp(a1) Out[64]: <pre>array([ 2.71828183,  7.3890561 , 20.08553692])</pre> In\u00a0[65]: Copied! <pre>sum(a1)\n</pre> sum(a1) Out[65]: <pre>np.int64(6)</pre> In\u00a0[66]: Copied! <pre>np.sum(a1)\n</pre> np.sum(a1) Out[66]: <pre>np.int64(6)</pre> <p>Tip: Use NumPy's <code>np.sum()</code> on NumPy arrays and Python's <code>sum()</code> on Python <code>list</code>s.</p> In\u00a0[67]: Copied! <pre>massive_array = np.random.random(100000)\nmassive_array.size, type(massive_array)\n</pre> massive_array = np.random.random(100000) massive_array.size, type(massive_array) Out[67]: <pre>(100000, numpy.ndarray)</pre> In\u00a0[68]: Copied! <pre>%timeit sum(massive_array) # Python sum()\n%timeit np.sum(massive_array) # NumPy np.sum()\n</pre> %timeit sum(massive_array) # Python sum() %timeit np.sum(massive_array) # NumPy np.sum() <pre>3.93 ms \u00b1 145 \u03bcs per loop (mean \u00b1 std. dev. of 7 runs, 100 loops each)\n20.5 \u03bcs \u00b1 698 ns per loop (mean \u00b1 std. dev. of 7 runs, 10,000 loops each)\n</pre> <p>Notice <code>np.sum()</code> is faster on the Numpy array (<code>numpy.ndarray</code>) than Python's <code>sum()</code>.</p> <p>Now let's try it out on a Python list.</p> In\u00a0[69]: Copied! <pre>import random \nmassive_list = [random.randint(0, 10) for i in range(100000)]\nlen(massive_list), type(massive_list)\n</pre> import random  massive_list = [random.randint(0, 10) for i in range(100000)] len(massive_list), type(massive_list) Out[69]: <pre>(100000, list)</pre> In\u00a0[70]: Copied! <pre>massive_list[:10]\n</pre> massive_list[:10] Out[70]: <pre>[8, 9, 1, 0, 0, 6, 2, 8, 6, 3]</pre> In\u00a0[71]: Copied! <pre>%timeit sum(massive_list)\n%timeit np.sum(massive_list)\n</pre> %timeit sum(massive_list) %timeit np.sum(massive_list) <pre>419 \u03bcs \u00b1 6.74 \u03bcs per loop (mean \u00b1 std. dev. of 7 runs, 1,000 loops each)\n2.72 ms \u00b1 118 \u03bcs per loop (mean \u00b1 std. dev. of 7 runs, 100 loops each)\n</pre> <p>NumPy's <code>np.sum()</code> is still fast but Python's <code>sum()</code> is faster on Python <code>list</code>s.</p> In\u00a0[72]: Copied! <pre>a2\n</pre> a2 Out[72]: <pre>array([[1. , 2. , 3.3],\n       [4. , 5. , 6.5]])</pre> In\u00a0[73]: Copied! <pre># Find the mean\nnp.mean(a2)\n</pre> # Find the mean np.mean(a2) Out[73]: <pre>np.float64(3.6333333333333333)</pre> In\u00a0[74]: Copied! <pre># Find the max\nnp.max(a2)\n</pre> # Find the max np.max(a2) Out[74]: <pre>np.float64(6.5)</pre> In\u00a0[75]: Copied! <pre># Find the min\nnp.min(a2)\n</pre> # Find the min np.min(a2) Out[75]: <pre>np.float64(1.0)</pre> In\u00a0[76]: Copied! <pre># Find the standard deviation\nnp.std(a2)\n</pre> # Find the standard deviation np.std(a2) Out[76]: <pre>np.float64(1.8226964152656422)</pre> In\u00a0[77]: Copied! <pre># Find the variance\nnp.var(a2)\n</pre> # Find the variance np.var(a2) Out[77]: <pre>np.float64(3.3222222222222224)</pre> In\u00a0[78]: Copied! <pre># The standard deviation is the square root of the variance\nnp.sqrt(np.var(a2))\n</pre> # The standard deviation is the square root of the variance np.sqrt(np.var(a2)) Out[78]: <pre>np.float64(1.8226964152656422)</pre> <p>What's mean?</p> <p>Mean is the same as average. You can find the average of a set of numbers by adding them up and dividing them by how many there are.</p> <p>What's standard deviation?</p> <p>Standard deviation is a measure of how spread out numbers are.</p> <p>What's variance?</p> <p>The variance is the averaged squared differences of the mean.</p> <p>To work it out, you:</p> <ol> <li>Work out the mean</li> <li>For each number, subtract the mean and square the result</li> <li>Find the average of the squared differences</li> </ol> In\u00a0[79]: Copied! <pre># Demo of variance\nhigh_var_array = np.array([1, 100, 200, 300, 4000, 5000])\nlow_var_array = np.array([2, 4, 6, 8, 10])\n\nnp.var(high_var_array), np.var(low_var_array)\n</pre> # Demo of variance high_var_array = np.array([1, 100, 200, 300, 4000, 5000]) low_var_array = np.array([2, 4, 6, 8, 10])  np.var(high_var_array), np.var(low_var_array) Out[79]: <pre>(np.float64(4296133.472222221), np.float64(8.0))</pre> In\u00a0[80]: Copied! <pre>np.std(high_var_array), np.std(low_var_array)\n</pre> np.std(high_var_array), np.std(low_var_array) Out[80]: <pre>(np.float64(2072.711623024829), np.float64(2.8284271247461903))</pre> In\u00a0[81]: Copied! <pre># The standard deviation is the square root of the variance\nnp.sqrt(np.var(high_var_array))\n</pre> # The standard deviation is the square root of the variance np.sqrt(np.var(high_var_array)) Out[81]: <pre>np.float64(2072.711623024829)</pre> In\u00a0[82]: Copied! <pre>%matplotlib inline\nimport matplotlib.pyplot as plt\nplt.hist(high_var_array)\nplt.show()\n</pre> %matplotlib inline import matplotlib.pyplot as plt plt.hist(high_var_array) plt.show() In\u00a0[83]: Copied! <pre>plt.hist(low_var_array)\nplt.show()\n</pre> plt.hist(low_var_array) plt.show() In\u00a0[84]: Copied! <pre>a2\n</pre> a2 Out[84]: <pre>array([[1. , 2. , 3.3],\n       [4. , 5. , 6.5]])</pre> In\u00a0[85]: Copied! <pre>a2.shape\n</pre> a2.shape Out[85]: <pre>(2, 3)</pre> In\u00a0[86]: Copied! <pre>a2 + a3\n</pre> a2 + a3 <pre>\n---------------------------------------------------------------------------\nValueError                                Traceback (most recent call last)\nCell In[86], line 1\n----&gt; 1 a2 + a3\n\nValueError: operands could not be broadcast together with shapes (2,3) (2,3,3) </pre> In\u00a0[\u00a0]: Copied! <pre>a2.reshape(2, 3, 1)\n</pre> a2.reshape(2, 3, 1) In\u00a0[87]: Copied! <pre>a2.reshape(2, 3, 1) + a3\n</pre> a2.reshape(2, 3, 1) + a3 Out[87]: <pre>array([[[ 2. ,  3. ,  4. ],\n        [ 6. ,  7. ,  8. ],\n        [10.3, 11.3, 12.3]],\n\n       [[14. , 15. , 16. ],\n        [18. , 19. , 20. ],\n        [22.5, 23.5, 24.5]]])</pre> In\u00a0[88]: Copied! <pre>a2.shape\n</pre> a2.shape Out[88]: <pre>(2, 3)</pre> In\u00a0[89]: Copied! <pre>a2.T\n</pre> a2.T Out[89]: <pre>array([[1. , 4. ],\n       [2. , 5. ],\n       [3.3, 6.5]])</pre> In\u00a0[90]: Copied! <pre>a2.transpose()\n</pre> a2.transpose() Out[90]: <pre>array([[1. , 4. ],\n       [2. , 5. ],\n       [3.3, 6.5]])</pre> In\u00a0[91]: Copied! <pre>a2.T.shape\n</pre> a2.T.shape Out[91]: <pre>(3, 2)</pre> <p>For larger arrays, the default value of a tranpose is to swap the first and last axes.</p> <p>For example, <code>(5, 3, 3)</code> -&gt; <code>(3, 3, 5)</code>.</p> In\u00a0[92]: Copied! <pre>matrix = np.random.random(size=(5, 3, 3))\nmatrix\n</pre> matrix = np.random.random(size=(5, 3, 3)) matrix Out[92]: <pre>array([[[0.59816399, 0.17370251, 0.49752936],\n        [0.51231935, 0.41529741, 0.44150892],\n        [0.96844105, 0.23242417, 0.90336451]],\n\n       [[0.35172075, 0.56481088, 0.57771134],\n        [0.73115238, 0.88762934, 0.37368847],\n        [0.35104994, 0.11873224, 0.72324236]],\n\n       [[0.93202688, 0.09600718, 0.4330638 ],\n        [0.71979707, 0.06689016, 0.20815443],\n        [0.55415679, 0.08416165, 0.88953996]],\n\n       [[0.00301345, 0.30163886, 0.12337636],\n        [0.13435611, 0.51987339, 0.05418991],\n        [0.11426417, 0.19005404, 0.61364183]],\n\n       [[0.23385887, 0.13555752, 0.32546415],\n        [0.81922614, 0.94551446, 0.12975713],\n        [0.35431267, 0.37758386, 0.07987885]]])</pre> In\u00a0[93]: Copied! <pre>matrix.shape\n</pre> matrix.shape Out[93]: <pre>(5, 3, 3)</pre> In\u00a0[94]: Copied! <pre>matrix.T\n</pre> matrix.T Out[94]: <pre>array([[[0.59816399, 0.35172075, 0.93202688, 0.00301345, 0.23385887],\n        [0.51231935, 0.73115238, 0.71979707, 0.13435611, 0.81922614],\n        [0.96844105, 0.35104994, 0.55415679, 0.11426417, 0.35431267]],\n\n       [[0.17370251, 0.56481088, 0.09600718, 0.30163886, 0.13555752],\n        [0.41529741, 0.88762934, 0.06689016, 0.51987339, 0.94551446],\n        [0.23242417, 0.11873224, 0.08416165, 0.19005404, 0.37758386]],\n\n       [[0.49752936, 0.57771134, 0.4330638 , 0.12337636, 0.32546415],\n        [0.44150892, 0.37368847, 0.20815443, 0.05418991, 0.12975713],\n        [0.90336451, 0.72324236, 0.88953996, 0.61364183, 0.07987885]]])</pre> In\u00a0[95]: Copied! <pre>matrix.T.shape\n</pre> matrix.T.shape Out[95]: <pre>(3, 3, 5)</pre> In\u00a0[96]: Copied! <pre># Check to see if the reverse shape is same as tranpose shape\nmatrix.T.shape == matrix.shape[::-1]\n</pre> # Check to see if the reverse shape is same as tranpose shape matrix.T.shape == matrix.shape[::-1] Out[96]: <pre>True</pre> In\u00a0[97]: Copied! <pre># Check to see if the first and last axes are swapped\nmatrix.T == matrix.swapaxes(0, -1) # swap first (0) and last (-1) axes\n</pre> # Check to see if the first and last axes are swapped matrix.T == matrix.swapaxes(0, -1) # swap first (0) and last (-1) axes Out[97]: <pre>array([[[ True,  True,  True,  True,  True],\n        [ True,  True,  True,  True,  True],\n        [ True,  True,  True,  True,  True]],\n\n       [[ True,  True,  True,  True,  True],\n        [ True,  True,  True,  True,  True],\n        [ True,  True,  True,  True,  True]],\n\n       [[ True,  True,  True,  True,  True],\n        [ True,  True,  True,  True,  True],\n        [ True,  True,  True,  True,  True]]])</pre> <p>You can see more advanced forms of tranposing in the NumPy documentation under <code>numpy.transpose</code>.</p> In\u00a0[98]: Copied! <pre>np.random.seed(0)\nmat1 = np.random.randint(10, size=(3, 3))\nmat2 = np.random.randint(10, size=(3, 2))\n\nmat1.shape, mat2.shape\n</pre> np.random.seed(0) mat1 = np.random.randint(10, size=(3, 3)) mat2 = np.random.randint(10, size=(3, 2))  mat1.shape, mat2.shape Out[98]: <pre>((3, 3), (3, 2))</pre> In\u00a0[99]: Copied! <pre>mat1\n</pre> mat1 Out[99]: <pre>array([[5, 0, 3],\n       [3, 7, 9],\n       [3, 5, 2]])</pre> In\u00a0[100]: Copied! <pre>mat2\n</pre> mat2 Out[100]: <pre>array([[4, 7],\n       [6, 8],\n       [8, 1]])</pre> In\u00a0[101]: Copied! <pre>np.dot(mat1, mat2)\n</pre> np.dot(mat1, mat2) Out[101]: <pre>array([[ 44,  38],\n       [126,  86],\n       [ 58,  63]])</pre> In\u00a0[102]: Copied! <pre># Can also achieve np.dot() with \"@\" \n# (however, they may behave differently at 3D+ arrays)\nmat1 @ mat2\n</pre> # Can also achieve np.dot() with \"@\"  # (however, they may behave differently at 3D+ arrays) mat1 @ mat2 Out[102]: <pre>array([[ 44,  38],\n       [126,  86],\n       [ 58,  63]])</pre> In\u00a0[103]: Copied! <pre>np.random.seed(0)\nmat3 = np.random.randint(10, size=(4,3))\nmat4 = np.random.randint(10, size=(4,3))\nmat3\n</pre> np.random.seed(0) mat3 = np.random.randint(10, size=(4,3)) mat4 = np.random.randint(10, size=(4,3)) mat3 Out[103]: <pre>array([[5, 0, 3],\n       [3, 7, 9],\n       [3, 5, 2],\n       [4, 7, 6]])</pre> In\u00a0[104]: Copied! <pre>mat4\n</pre> mat4 Out[104]: <pre>array([[8, 8, 1],\n       [6, 7, 7],\n       [8, 1, 5],\n       [9, 8, 9]])</pre> In\u00a0[105]: Copied! <pre># This will fail as the inner dimensions of the matrices do not match\nnp.dot(mat3, mat4)\n</pre> # This will fail as the inner dimensions of the matrices do not match np.dot(mat3, mat4) <pre>\n---------------------------------------------------------------------------\nValueError                                Traceback (most recent call last)\nCell In[105], line 2\n      1 # This will fail as the inner dimensions of the matrices do not match\n----&gt; 2 np.dot(mat3, mat4)\n\nValueError: shapes (4,3) and (4,3) not aligned: 3 (dim 1) != 4 (dim 0)</pre> In\u00a0[106]: Copied! <pre>mat3.T.shape\n</pre> mat3.T.shape Out[106]: <pre>(3, 4)</pre> In\u00a0[107]: Copied! <pre># Dot product\nnp.dot(mat3.T, mat4)\n</pre> # Dot product np.dot(mat3.T, mat4) Out[107]: <pre>array([[118,  96,  77],\n       [145, 110, 137],\n       [148, 137, 130]])</pre> In\u00a0[108]: Copied! <pre># Element-wise multiplication, also known as Hadamard product\nmat3 * mat4\n</pre> # Element-wise multiplication, also known as Hadamard product mat3 * mat4 Out[108]: <pre>array([[40,  0,  3],\n       [18, 49, 63],\n       [24,  5, 10],\n       [36, 56, 54]])</pre> In\u00a0[109]: Copied! <pre>np.random.seed(0)\nsales_amounts = np.random.randint(20, size=(5, 3))\nsales_amounts\n</pre> np.random.seed(0) sales_amounts = np.random.randint(20, size=(5, 3)) sales_amounts Out[109]: <pre>array([[12, 15,  0],\n       [ 3,  3,  7],\n       [ 9, 19, 18],\n       [ 4,  6, 12],\n       [ 1,  6,  7]])</pre> In\u00a0[110]: Copied! <pre>weekly_sales = pd.DataFrame(sales_amounts,\n                            index=[\"Mon\", \"Tues\", \"Wed\", \"Thurs\", \"Fri\"],\n                            columns=[\"Almond butter\", \"Peanut butter\", \"Cashew butter\"])\nweekly_sales\n</pre> weekly_sales = pd.DataFrame(sales_amounts,                             index=[\"Mon\", \"Tues\", \"Wed\", \"Thurs\", \"Fri\"],                             columns=[\"Almond butter\", \"Peanut butter\", \"Cashew butter\"]) weekly_sales Out[110]: Almond butter Peanut butter Cashew butter Mon 12 15 0 Tues 3 3 7 Wed 9 19 18 Thurs 4 6 12 Fri 1 6 7 In\u00a0[111]: Copied! <pre>prices = np.array([10, 8, 12])\nprices\n</pre> prices = np.array([10, 8, 12]) prices Out[111]: <pre>array([10,  8, 12])</pre> In\u00a0[112]: Copied! <pre>butter_prices = pd.DataFrame(prices.reshape(1, 3),\n                             index=[\"Price\"],\n                             columns=[\"Almond butter\", \"Peanut butter\", \"Cashew butter\"])\nbutter_prices.shape\n</pre> butter_prices = pd.DataFrame(prices.reshape(1, 3),                              index=[\"Price\"],                              columns=[\"Almond butter\", \"Peanut butter\", \"Cashew butter\"]) butter_prices.shape Out[112]: <pre>(1, 3)</pre> In\u00a0[113]: Copied! <pre>weekly_sales.shape\n</pre> weekly_sales.shape Out[113]: <pre>(5, 3)</pre> In\u00a0[114]: Copied! <pre># Find the total amount of sales for a whole day\ntotal_sales = prices.dot(sales_amounts)\ntotal_sales\n</pre> # Find the total amount of sales for a whole day total_sales = prices.dot(sales_amounts) total_sales <pre>\n---------------------------------------------------------------------------\nValueError                                Traceback (most recent call last)\nCell In[114], line 2\n      1 # Find the total amount of sales for a whole day\n----&gt; 2 total_sales = prices.dot(sales_amounts)\n      3 total_sales\n\nValueError: shapes (3,) and (5,3) not aligned: 3 (dim 0) != 5 (dim 0)</pre> <p>The shapes aren't aligned, we need the middle two numbers to be the same.</p> In\u00a0[115]: Copied! <pre>prices\n</pre> prices Out[115]: <pre>array([10,  8, 12])</pre> In\u00a0[116]: Copied! <pre>sales_amounts.T.shape\n</pre> sales_amounts.T.shape Out[116]: <pre>(3, 5)</pre> In\u00a0[117]: Copied! <pre># To make the middle numbers the same, we can transpose\ntotal_sales = prices.dot(sales_amounts.T)\ntotal_sales\n</pre> # To make the middle numbers the same, we can transpose total_sales = prices.dot(sales_amounts.T) total_sales Out[117]: <pre>array([240, 138, 458, 232, 142])</pre> In\u00a0[118]: Copied! <pre>butter_prices.shape, weekly_sales.shape\n</pre> butter_prices.shape, weekly_sales.shape Out[118]: <pre>((1, 3), (5, 3))</pre> In\u00a0[119]: Copied! <pre>daily_sales = butter_prices.dot(weekly_sales.T)\ndaily_sales\n</pre> daily_sales = butter_prices.dot(weekly_sales.T) daily_sales Out[119]: Mon Tues Wed Thurs Fri Price 240 138 458 232 142 In\u00a0[120]: Copied! <pre># Need to transpose again\nweekly_sales[\"Total\"] = daily_sales.T\nweekly_sales\n</pre> # Need to transpose again weekly_sales[\"Total\"] = daily_sales.T weekly_sales Out[120]: Almond butter Peanut butter Cashew butter Total Mon 12 15 0 240 Tues 3 3 7 138 Wed 9 19 18 458 Thurs 4 6 12 232 Fri 1 6 7 142 In\u00a0[121]: Copied! <pre>a1\n</pre> a1 Out[121]: <pre>array([1, 2, 3])</pre> In\u00a0[122]: Copied! <pre>a2\n</pre> a2 Out[122]: <pre>array([[1. , 2. , 3.3],\n       [4. , 5. , 6.5]])</pre> In\u00a0[123]: Copied! <pre>a1 &gt; a2\n</pre> a1 &gt; a2 Out[123]: <pre>array([[False, False, False],\n       [False, False, False]])</pre> In\u00a0[124]: Copied! <pre>a1 &gt;= a2\n</pre> a1 &gt;= a2 Out[124]: <pre>array([[ True,  True, False],\n       [False, False, False]])</pre> In\u00a0[125]: Copied! <pre>a1 &gt; 5\n</pre> a1 &gt; 5 Out[125]: <pre>array([False, False, False])</pre> In\u00a0[126]: Copied! <pre>a1 == a1\n</pre> a1 == a1 Out[126]: <pre>array([ True,  True,  True])</pre> In\u00a0[127]: Copied! <pre>a1 == a2\n</pre> a1 == a2 Out[127]: <pre>array([[ True,  True, False],\n       [False, False, False]])</pre> In\u00a0[128]: Copied! <pre>random_array\n</pre> random_array Out[128]: <pre>array([[8, 7, 6],\n       [4, 2, 7],\n       [6, 0, 6],\n       [0, 8, 5],\n       [6, 2, 9]])</pre> In\u00a0[129]: Copied! <pre>np.sort(random_array)\n</pre> np.sort(random_array) Out[129]: <pre>array([[6, 7, 8],\n       [2, 4, 7],\n       [0, 6, 6],\n       [0, 5, 8],\n       [2, 6, 9]])</pre> In\u00a0[130]: Copied! <pre>np.argsort(random_array)\n</pre> np.argsort(random_array) Out[130]: <pre>array([[2, 1, 0],\n       [1, 0, 2],\n       [1, 0, 2],\n       [0, 2, 1],\n       [1, 0, 2]])</pre> In\u00a0[131]: Copied! <pre>a1\n</pre> a1 Out[131]: <pre>array([1, 2, 3])</pre> In\u00a0[132]: Copied! <pre># Return the indices that would sort an array\nnp.argsort(a1)\n</pre> # Return the indices that would sort an array np.argsort(a1) Out[132]: <pre>array([0, 1, 2])</pre> In\u00a0[133]: Copied! <pre># No axis\nnp.argmin(a1)\n</pre> # No axis np.argmin(a1) Out[133]: <pre>np.int64(0)</pre> In\u00a0[134]: Copied! <pre>random_array\n</pre> random_array Out[134]: <pre>array([[8, 7, 6],\n       [4, 2, 7],\n       [6, 0, 6],\n       [0, 8, 5],\n       [6, 2, 9]])</pre> In\u00a0[135]: Copied! <pre># Down the vertical\nnp.argmax(random_array, axis=1)\n</pre> # Down the vertical np.argmax(random_array, axis=1) Out[135]: <pre>array([0, 2, 0, 1, 2])</pre> In\u00a0[136]: Copied! <pre># Across the horizontal\nnp.argmin(random_array, axis=0)\n</pre> # Across the horizontal np.argmin(random_array, axis=0) Out[136]: <pre>array([3, 2, 3])</pre> In\u00a0[137]: Copied! <pre>from matplotlib.image import imread\n\npanda = imread('../images/numpy-panda.jpeg')\nprint(type(panda))\n</pre> from matplotlib.image import imread  panda = imread('../images/numpy-panda.jpeg') print(type(panda)) <pre>&lt;class 'numpy.ndarray'&gt;\n</pre> In\u00a0[138]: Copied! <pre>panda.shape\n</pre> panda.shape Out[138]: <pre>(852, 1280, 3)</pre> In\u00a0[139]: Copied! <pre>panda\n</pre> panda Out[139]: <pre>array([[[14, 27, 17],\n        [14, 27, 17],\n        [12, 28, 17],\n        ...,\n        [42, 36, 24],\n        [42, 35, 25],\n        [41, 34, 24]],\n\n       [[14, 27, 17],\n        [14, 27, 17],\n        [12, 28, 17],\n        ...,\n        [42, 36, 24],\n        [42, 35, 25],\n        [42, 35, 25]],\n\n       [[13, 26, 16],\n        [14, 27, 17],\n        [12, 28, 17],\n        ...,\n        [42, 36, 24],\n        [42, 35, 25],\n        [42, 35, 25]],\n\n       ...,\n\n       [[47, 32, 27],\n        [48, 33, 28],\n        [48, 33, 26],\n        ...,\n        [ 6,  6,  8],\n        [ 6,  6,  8],\n        [ 6,  6,  8]],\n\n       [[39, 24, 17],\n        [40, 25, 18],\n        [42, 27, 20],\n        ...,\n        [ 6,  6,  8],\n        [ 6,  6,  8],\n        [ 6,  6,  8]],\n\n       [[32, 17, 10],\n        [33, 18, 11],\n        [36, 21, 14],\n        ...,\n        [ 6,  6,  8],\n        [ 6,  6,  8],\n        [ 6,  6,  8]]], dtype=uint8)</pre> <p></p> In\u00a0[140]: Copied! <pre>car = imread(\"../images/numpy-car-photo.png\")\ncar.shape\n</pre> car = imread(\"../images/numpy-car-photo.png\") car.shape Out[140]: <pre>(431, 575, 4)</pre> In\u00a0[141]: Copied! <pre>car[:,:,:3].shape\n</pre> car[:,:,:3].shape Out[141]: <pre>(431, 575, 3)</pre> <p></p> In\u00a0[142]: Copied! <pre>dog = imread(\"../images/numpy-dog-photo.png\")\ndog.shape\n</pre> dog = imread(\"../images/numpy-dog-photo.png\") dog.shape Out[142]: <pre>(432, 575, 4)</pre> In\u00a0[143]: Copied! <pre>dog\n</pre> dog Out[143]: <pre>array([[[0.70980394, 0.80784315, 0.88235295, 1.        ],\n        [0.72156864, 0.8117647 , 0.8862745 , 1.        ],\n        [0.7411765 , 0.8156863 , 0.8862745 , 1.        ],\n        ...,\n        [0.49803922, 0.6862745 , 0.8392157 , 1.        ],\n        [0.49411765, 0.68235296, 0.8392157 , 1.        ],\n        [0.49411765, 0.68235296, 0.8352941 , 1.        ]],\n\n       [[0.69411767, 0.8039216 , 0.8862745 , 1.        ],\n        [0.7019608 , 0.8039216 , 0.88235295, 1.        ],\n        [0.7058824 , 0.80784315, 0.88235295, 1.        ],\n        ...,\n        [0.5019608 , 0.6862745 , 0.84705883, 1.        ],\n        [0.49411765, 0.68235296, 0.84313726, 1.        ],\n        [0.49411765, 0.68235296, 0.8392157 , 1.        ]],\n\n       [[0.6901961 , 0.8       , 0.88235295, 1.        ],\n        [0.69803923, 0.8039216 , 0.88235295, 1.        ],\n        [0.7058824 , 0.80784315, 0.88235295, 1.        ],\n        ...,\n        [0.5019608 , 0.6862745 , 0.84705883, 1.        ],\n        [0.49803922, 0.6862745 , 0.84313726, 1.        ],\n        [0.49803922, 0.6862745 , 0.84313726, 1.        ]],\n\n       ...,\n\n       [[0.9098039 , 0.81960785, 0.654902  , 1.        ],\n        [0.8352941 , 0.7490196 , 0.6509804 , 1.        ],\n        [0.72156864, 0.6313726 , 0.5372549 , 1.        ],\n        ...,\n        [0.01568628, 0.07058824, 0.02352941, 1.        ],\n        [0.03921569, 0.09411765, 0.03529412, 1.        ],\n        [0.03921569, 0.09019608, 0.05490196, 1.        ]],\n\n       [[0.9137255 , 0.83137256, 0.6784314 , 1.        ],\n        [0.8117647 , 0.7294118 , 0.627451  , 1.        ],\n        [0.65882355, 0.5686275 , 0.47843137, 1.        ],\n        ...,\n        [0.00392157, 0.05490196, 0.03529412, 1.        ],\n        [0.03137255, 0.09019608, 0.05490196, 1.        ],\n        [0.04705882, 0.10588235, 0.06666667, 1.        ]],\n\n       [[0.9137255 , 0.83137256, 0.68235296, 1.        ],\n        [0.76862746, 0.68235296, 0.5882353 , 1.        ],\n        [0.59607846, 0.5058824 , 0.44313726, 1.        ],\n        ...,\n        [0.03921569, 0.10196079, 0.07058824, 1.        ],\n        [0.02745098, 0.08235294, 0.05882353, 1.        ],\n        [0.05098039, 0.11372549, 0.07058824, 1.        ]]], dtype=float32)</pre>"},{"location":"introduction-to-numpy/#a-quick-introduction-to-numerical-data-manipulation-with-python-and-numpy","title":"A Quick Introduction to Numerical Data Manipulation with Python and NumPy\u00b6","text":""},{"location":"introduction-to-numpy/#what-is-numpy","title":"What is NumPy?\u00b6","text":"<p>NumPy stands for numerical Python. It's the backbone of all kinds of scientific and numerical computing in Python.</p> <p>And since machine learning is all about turning data into numbers and then figuring out the patterns, NumPy often comes into play.</p> <p></p>"},{"location":"introduction-to-numpy/#why-numpy","title":"Why NumPy?\u00b6","text":"<p>You can do numerical calculations using pure Python. In the beginning, you might think Python is fast but once your data gets large, you'll start to notice slow downs.</p> <p>One of the main reasons you use NumPy is because it's fast. Behind the scenes, the code has been optimized to run using C. Which is another programming language, which can do things much faster than Python.</p> <p>The benefit of this being behind the scenes is you don't need to know any C to take advantage of it. You can write your numerical computations in Python using NumPy and get the added speed benefits.</p> <p>If your curious as to what causes this speed benefit, it's a process called vectorization. Vectorization aims to do calculations by avoiding loops as loops can create potential bottlenecks.</p> <p>NumPy achieves vectorization through a process called broadcasting.</p>"},{"location":"introduction-to-numpy/#what-does-this-notebook-cover","title":"What does this notebook cover?\u00b6","text":"<p>The NumPy library is very capable. However, learning everything off by heart isn't necessary. Instead, this notebook focuses on the main concepts of NumPy and the <code>ndarray</code> datatype.</p> <p>You can think of the <code>ndarray</code> datatype as a very flexible array of numbers.</p> <p>More specifically, we'll look at:</p> <ul> <li>NumPy datatypes &amp; attributes</li> <li>Creating arrays</li> <li>Viewing arrays &amp; matrices (indexing)</li> <li>Manipulating &amp; comparing arrays</li> <li>Sorting arrays</li> <li>Use cases (examples of turning things into numbers)</li> </ul> <p>After going through it, you'll have the base knolwedge of NumPy you need to keep moving forward.</p>"},{"location":"introduction-to-numpy/#where-can-i-get-help","title":"Where can I get help?\u00b6","text":"<p>If you get stuck or think of something you'd like to do which this notebook doesn't cover, don't fear!</p> <p>The recommended steps you take are:</p> <ol> <li>Try it - Since NumPy is very friendly, your first step should be to use what you know and try figure out the answer to your own question (getting it wrong is part of the process). If in doubt, run your code.</li> <li>Search for it - If trying it on your own doesn't work, since someone else has probably tried to do something similar, try searching for your problem in the following places (either via a search engine or direct):<ul> <li>NumPy documentation - The ground truth for everything NumPy, this resource covers all of the NumPy functionality.</li> <li>Stack Overflow - This is the developers Q&amp;A hub, it's full of questions and answers of different problems across a wide range of software development topics and chances are, there's one related to your problem.</li> <li>ChatGPT - ChatGPT is very good at explaining code, however, it can make mistakes. Best to verify the code it writes first before using it. Try asking \"Can you explain the following code for me? {your code here}\" and then continue with follow up questions from there. Avoid straight copying and pasting and instead, only use things that you could yourself reproduce with adequate effort.</li> </ul> </li> </ol> <p>An example of searching for a NumPy function might be:</p> <p>\"how to find unique elements in a numpy array\"</p> <p>Searching this on Google leads to the NumPy documentation for the <code>np.unique()</code> function: https://numpy.org/doc/stable/reference/generated/numpy.unique.html</p> <p>The next steps here are to read through the documentation, check the examples and see if they line up to the problem you're trying to solve.</p> <p>If they do, rewrite the code to suit your needs, run it, and see what the outcomes are.</p> <ol> <li>Ask for help - If you've been through the above 2 steps and you're still stuck, you might want to ask your question on Stack Overflow. Be as specific as possible and provide details on what you've tried.</li> </ol> <p>Remember, you don't have to learn all of the functions off by heart to begin with.</p> <p>What's most important is continually asking yourself, \"what am I trying to do with the data?\".</p> <p>Start by answering that question and then practicing finding the code which does it.</p> <p>Let's get started.</p>"},{"location":"introduction-to-numpy/#0-importing-numpy","title":"0. Importing NumPy\u00b6","text":"<p>To get started using NumPy, the first step is to import it.</p> <p>The most common way (and method you should use) is to import NumPy as the abbreviation <code>np</code>.</p> <p>If you see the letters <code>np</code> used anywhere in machine learning or data science, it's probably referring to the NumPy library.</p>"},{"location":"introduction-to-numpy/#1-datatypes-and-attributes","title":"1. DataTypes and attributes\u00b6","text":"<p>Note: Important to remember the main type in NumPy is <code>ndarray</code>, even seemingly different kinds of arrays are still <code>ndarray</code>'s. This means an operation you do on one array, will work on another.</p>"},{"location":"introduction-to-numpy/#anatomy-of-an-array","title":"Anatomy of an array\u00b6","text":"<p>Key terms:</p> <ul> <li>Array - A list of numbers, can be multi-dimensional.</li> <li>Scalar - A single number (e.g. <code>7</code>).</li> <li>Vector - A list of numbers with 1-dimension (e.g. <code>np.array([1, 2, 3])</code>).</li> <li>Matrix - A (usually) multi-dimensional list of numbers (e.g. <code>np.array([[1, 2, 3], [4, 5, 6]])</code>).</li> </ul>"},{"location":"introduction-to-numpy/#pandas-dataframe-out-of-numpy-arrays","title":"pandas DataFrame out of NumPy arrays\u00b6","text":"<p>This is to examplify how NumPy is the backbone of many other libraries.</p>"},{"location":"introduction-to-numpy/#2-creating-arrays","title":"2. Creating arrays\u00b6","text":"<ul> <li><code>np.array()</code></li> <li><code>np.ones()</code></li> <li><code>np.zeros()</code></li> <li><code>np.random.rand(5, 3)</code></li> <li><code>np.random.randint(10, size=5)</code></li> <li><code>np.random.seed()</code> - pseudo random numbers</li> <li>Searching the documentation example (finding <code>np.unique()</code> and using it)</li> </ul>"},{"location":"introduction-to-numpy/#what-unique-values-are-in-the-array-a3","title":"What unique values are in the array a3?\u00b6","text":"<p>Now you've seen a few different ways to create arrays, as an exercise, try find out what NumPy function you could use to find the unique values are within the <code>a3</code> array.</p> <p>You might want to search some like, \"how to find the unqiue values in a numpy array\".</p>"},{"location":"introduction-to-numpy/#3-viewing-arrays-and-matrices-indexing","title":"3. Viewing arrays and matrices (indexing)\u00b6","text":"<p>Remember, because arrays and matrices are both <code>ndarray</code>'s, they can be viewed in similar ways.</p> <p>Let's check out our 3 arrays again.</p>"},{"location":"introduction-to-numpy/#4-manipulating-and-comparing-arrays","title":"4. Manipulating and comparing arrays\u00b6","text":"<ul> <li>Arithmetic<ul> <li><code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>//</code>, <code>**</code>, <code>%</code></li> <li><code>np.exp()</code></li> <li><code>np.log()</code></li> <li>Dot product - <code>np.dot()</code></li> <li>Broadcasting</li> </ul> </li> <li>Aggregation<ul> <li><code>np.sum()</code> - faster than Python's <code>.sum()</code> for NumPy arrays</li> <li><code>np.mean()</code></li> <li><code>np.std()</code></li> <li><code>np.var()</code></li> <li><code>np.min()</code></li> <li><code>np.max()</code></li> <li><code>np.argmin()</code> - find index of minimum value</li> <li><code>np.argmax()</code> - find index of maximum value</li> <li>These work on all <code>ndarray</code>'s<ul> <li><code>a4.min(axis=0)</code> -- you can use axis as well</li> </ul> </li> </ul> </li> <li>Reshaping<ul> <li><code>np.reshape()</code></li> </ul> </li> <li>Transposing<ul> <li><code>a3.T</code></li> </ul> </li> <li>Comparison operators<ul> <li><code>&gt;</code></li> <li><code>&lt;</code></li> <li><code>&lt;=</code></li> <li><code>&gt;=</code></li> <li><code>x != 3</code></li> <li><code>x == 3</code></li> <li><code>np.sum(x &gt; 3)</code></li> </ul> </li> </ul>"},{"location":"introduction-to-numpy/#arithmetic","title":"Arithmetic\u00b6","text":""},{"location":"introduction-to-numpy/#broadcasting","title":"Broadcasting\u00b6","text":"<ul> <li><p>What is broadcasting?</p> <ul> <li>Broadcasting is a feature of NumPy which performs an operation across multiple dimensions of data without replicating the data. This saves time and space. For example, if you have a 3x3 array (A) and want to add a 1x3 array (B), NumPy will add the row of (B) to every row of (A).</li> </ul> </li> <li><p>Rules of Broadcasting</p> <ol> <li>If the two arrays differ in their number of dimensions, the shape of the one with fewer dimensions is padded with ones on its leading (left) side.</li> <li>If the shape of the two arrays does not match in any dimension, the array with shape equal to 1 in that dimension is stretched to match the other shape.</li> <li>If in any dimension the sizes disagree and neither is equal to 1, an error is raised.</li> </ol> </li> </ul> <p>The broadcasting rule: In order to broadcast, the size of the trailing axes for both arrays in an operation must be either the same size or one of them must be one.</p>"},{"location":"introduction-to-numpy/#aggregation","title":"Aggregation\u00b6","text":"<p>Aggregation - bringing things together, doing a similar thing on a number of things.</p>"},{"location":"introduction-to-numpy/#reshaping","title":"Reshaping\u00b6","text":""},{"location":"introduction-to-numpy/#transpose","title":"Transpose\u00b6","text":"<p>A tranpose reverses the order of the axes.</p> <p>For example, an array with shape <code>(2, 3)</code> becomes <code>(3, 2)</code>.</p>"},{"location":"introduction-to-numpy/#dot-product","title":"Dot product\u00b6","text":"<p>The main two rules for dot product to remember are:</p> <ol> <li>The inner dimensions must match:</li> </ol> <ul> <li><code>(3, 2) @ (3, 2)</code> won't work</li> <li><code>(2, 3) @ (3, 2)</code> will work</li> <li><code>(3, 2) @ (2, 3)</code> will work</li> </ul> <ol> <li>The resulting matrix has the shape of the outer dimensions:</li> </ol> <ul> <li><code>(2, 3) @ (3, 2)</code> -&gt; <code>(2, 2)</code></li> <li><code>(3, 2) @ (2, 3)</code> -&gt; <code>(3, 3)</code></li> </ul> <p>Note: In NumPy, <code>np.dot()</code> and <code>@</code> can be used to acheive the same result for 1-2 dimension arrays. However, their behaviour begins to differ at arrays with 3+ dimensions.</p>"},{"location":"introduction-to-numpy/#dot-product-practical-example-nut-butter-sales","title":"Dot product practical example, nut butter sales\u00b6","text":""},{"location":"introduction-to-numpy/#comparison-operators","title":"Comparison operators\u00b6","text":"<p>Finding out if one array is larger, smaller or equal to another.</p>"},{"location":"introduction-to-numpy/#5-sorting-arrays","title":"5. Sorting arrays\u00b6","text":"<ul> <li><code>np.sort()</code> - sort values in a specified dimension of an array.</li> <li><code>np.argsort()</code> - return the indices to sort the array on a given axis.</li> <li><code>np.argmax()</code> - return the index/indicies which gives the highest value(s) along an axis.</li> <li><code>np.argmin()</code> - return the index/indices which gives the lowest value(s) along an axis.</li> </ul>"},{"location":"introduction-to-numpy/#6-use-case","title":"6. Use case\u00b6","text":"<p>Turning an image into a NumPy array.</p> <p>Why?</p> <p>Because computers can use the numbers in the NumPy array to find patterns in the image and in turn use those patterns to figure out what's in the image.</p> <p>This is what happens in modern computer vision algorithms.</p> <p>Let's start with this beautiful image of a panda:</p>"},{"location":"introduction-to-pandas/","title":"Introduction to pandas","text":"<p>View source code | Read notebook in online book format</p> In\u00a0[1]: Copied! <pre>import datetime\nprint(f\"Last updated: {datetime.datetime.now()}\")\n</pre> import datetime print(f\"Last updated: {datetime.datetime.now()}\") <pre>Last updated: 2024-09-04 16:09:35.139163\n</pre> In\u00a0[2]: Copied! <pre>import pandas as pd\n\n# Print the version\nprint(f\"pandas version: {pd.__version__}\")\n</pre> import pandas as pd  # Print the version print(f\"pandas version: {pd.__version__}\") <pre>pandas version: 2.2.2\n</pre> In\u00a0[3]: Copied! <pre># Creating a series of car types\ncars = pd.Series([\"BMW\", \"Toyota\", \"Honda\"])\ncars\n</pre> # Creating a series of car types cars = pd.Series([\"BMW\", \"Toyota\", \"Honda\"]) cars Out[3]: <pre>0       BMW\n1    Toyota\n2     Honda\ndtype: object</pre> In\u00a0[4]: Copied! <pre># Creating a series of colours\ncolours = pd.Series([\"Blue\", \"Red\", \"White\"])\ncolours\n</pre> # Creating a series of colours colours = pd.Series([\"Blue\", \"Red\", \"White\"]) colours Out[4]: <pre>0     Blue\n1      Red\n2    White\ndtype: object</pre> <p>You can create a <code>DataFrame</code> by using <code>pd.DataFrame()</code> and passing it a Python dictionary.</p> <p>Let's use our two <code>Series</code> as the values.</p> In\u00a0[5]: Copied! <pre># Creating a DataFrame of cars and colours\ncar_data = pd.DataFrame({\"Car type\": cars, \n                         \"Colour\": colours})\ncar_data\n</pre> # Creating a DataFrame of cars and colours car_data = pd.DataFrame({\"Car type\": cars,                           \"Colour\": colours}) car_data Out[5]: Car type Colour 0 BMW Blue 1 Toyota Red 2 Honda White <p>You can see the keys of the dictionary became the column headings (text in bold) and the values of the two <code>Series</code>'s became the values in the DataFrame.</p> <p>It's important to note, many different types of data could go into the DataFrame.</p> <p>Here we've used only text but you could use floats, integers, dates and more.</p> In\u00a0[6]: Copied! <pre># Your code here\n</pre> # Your code here In\u00a0[7]: Copied! <pre># Example solution\n\n# Make a Series of different foods\nfoods = pd.Series([\"Almond butter\", \"Eggs\", \"Avocado\"])\n\n# Make a Series of different dollar values \nprices = pd.Series([9, 6, 2])\n\n# Combine your Series of foods and dollar values into a DataFrame\nfood_data = pd.DataFrame({\"Foods\": foods,\n                          \"Price\": prices})\n\nfood_data\n</pre> # Example solution  # Make a Series of different foods foods = pd.Series([\"Almond butter\", \"Eggs\", \"Avocado\"])  # Make a Series of different dollar values  prices = pd.Series([9, 6, 2])  # Combine your Series of foods and dollar values into a DataFrame food_data = pd.DataFrame({\"Foods\": foods,                           \"Price\": prices})  food_data Out[7]: Foods Price 0 Almond butter 9 1 Eggs 6 2 Avocado 2 In\u00a0[8]: Copied! <pre># Import car sales data\ncar_sales = pd.read_csv(\"../data/car-sales.csv\") # takes a filename as string as input\n\n# Option 2: Read directly from a URL/Google Sheets\n# If you are reading from GitHub, be sure to use the \"raw\" link (original link: https://github.com/mrdbourke/zero-to-mastery-ml/blob/master/data/car-sales.csv)\ncar_sales = pd.read_csv(\"https://raw.githubusercontent.com/mrdbourke/zero-to-mastery-ml/master/data/car-sales.csv\")\ncar_sales\n</pre> # Import car sales data car_sales = pd.read_csv(\"../data/car-sales.csv\") # takes a filename as string as input  # Option 2: Read directly from a URL/Google Sheets # If you are reading from GitHub, be sure to use the \"raw\" link (original link: https://github.com/mrdbourke/zero-to-mastery-ml/blob/master/data/car-sales.csv) car_sales = pd.read_csv(\"https://raw.githubusercontent.com/mrdbourke/zero-to-mastery-ml/master/data/car-sales.csv\") car_sales Out[8]: Make Colour Odometer (KM) Doors Price 0 Toyota White 150043 4 $4,000.00 1 Honda Red 87899 4 $5,000.00 2 Toyota Blue 32549 3 $7,000.00 3 BMW Black 11179 5 $22,000.00 4 Nissan White 213095 4 $3,500.00 5 Toyota Green 99213 4 $4,500.00 6 Honda Blue 45698 4 $7,500.00 7 Honda Blue 54738 4 $7,000.00 8 Toyota White 60000 4 $6,250.00 9 Nissan White 31600 4 $9,700.00 <p>Now we've got the same data from the spreadsheet available in a pandas <code>DataFrame</code> called <code>car_sales</code>.</p> <p>Having your data available in a <code>DataFrame</code> allows you to take advantage of all of pandas functionality on it.</p> <p>Another common practice you'll see is data being imported to <code>DataFrame</code> called <code>df</code> (short for <code>DataFrame</code>).</p> In\u00a0[9]: Copied! <pre># Import the car sales data and save it to df\n\n# Option 1: Read from a CSV file (stored on our local computer)\ndf = pd.read_csv(\"../data/car-sales.csv\")\n\n# Option 2: Read directly from a URL/Google Sheets (if the file is hosted online)\ndf = pd.read_csv(\"https://raw.githubusercontent.com/mrdbourke/zero-to-mastery-ml/master/data/car-sales.csv\")\ndf\n</pre> # Import the car sales data and save it to df  # Option 1: Read from a CSV file (stored on our local computer) df = pd.read_csv(\"../data/car-sales.csv\")  # Option 2: Read directly from a URL/Google Sheets (if the file is hosted online) df = pd.read_csv(\"https://raw.githubusercontent.com/mrdbourke/zero-to-mastery-ml/master/data/car-sales.csv\") df Out[9]: Make Colour Odometer (KM) Doors Price 0 Toyota White 150043 4 $4,000.00 1 Honda Red 87899 4 $5,000.00 2 Toyota Blue 32549 3 $7,000.00 3 BMW Black 11179 5 $22,000.00 4 Nissan White 213095 4 $3,500.00 5 Toyota Green 99213 4 $4,500.00 6 Honda Blue 45698 4 $7,500.00 7 Honda Blue 54738 4 $7,000.00 8 Toyota White 60000 4 $6,250.00 9 Nissan White 31600 4 $9,700.00 <p>Now <code>car_sales</code> and <code>df</code> contain the exact same information, the only difference is the name. Like any other variable, you can name your <code>DataFrame</code>'s whatever you want. But best to choose something simple.</p> In\u00a0[10]: Copied! <pre># Export the car sales DataFrame to csv\ncar_sales.to_csv(\"../data/exported-car-sales.csv\")\n</pre> # Export the car sales DataFrame to csv car_sales.to_csv(\"../data/exported-car-sales.csv\") <p>Running this will save a file called <code>export-car-sales.csv</code> to the current folder.</p> <p></p> In\u00a0[11]: Copied! <pre># Your code here\n</pre> # Your code here  In\u00a0[12]: Copied! <pre># Importing heart-disease.csv\npatient_data = pd.read_csv(\"../data/heart-disease.csv\")\npatient_data\n</pre> # Importing heart-disease.csv patient_data = pd.read_csv(\"../data/heart-disease.csv\") patient_data Out[12]: age sex cp trestbps chol fbs restecg thalach exang oldpeak slope ca thal target 0 63 1 3 145 233 1 0 150 0 2.3 0 0 1 1 1 37 1 2 130 250 0 1 187 0 3.5 0 0 2 1 2 41 0 1 130 204 0 0 172 0 1.4 2 0 2 1 3 56 1 1 120 236 0 1 178 0 0.8 2 0 2 1 4 57 0 0 120 354 0 1 163 1 0.6 2 0 2 1 ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... 298 57 0 0 140 241 0 1 123 1 0.2 1 0 3 0 299 45 1 3 110 264 0 1 132 0 1.2 1 0 3 0 300 68 1 0 144 193 1 1 141 0 3.4 1 2 3 0 301 57 1 0 130 131 0 1 115 1 1.2 1 1 3 0 302 57 0 1 130 236 0 0 174 0 0.0 1 1 2 0 <p>303 rows \u00d7 14 columns</p> In\u00a0[13]: Copied! <pre># Exporting the patient_data DataFrame to csv\npatient_data.to_csv(\"../data/exported-patient-data.csv\")\n</pre> # Exporting the patient_data DataFrame to csv patient_data.to_csv(\"../data/exported-patient-data.csv\") <p></p> In\u00a0[14]: Copied! <pre>car_sales\n</pre> car_sales Out[14]: Make Colour Odometer (KM) Doors Price 0 Toyota White 150043 4 $4,000.00 1 Honda Red 87899 4 $5,000.00 2 Toyota Blue 32549 3 $7,000.00 3 BMW Black 11179 5 $22,000.00 4 Nissan White 213095 4 $3,500.00 5 Toyota Green 99213 4 $4,500.00 6 Honda Blue 45698 4 $7,500.00 7 Honda Blue 54738 4 $7,000.00 8 Toyota White 60000 4 $6,250.00 9 Nissan White 31600 4 $9,700.00 <p><code>.dtypes</code> shows us what datatype each column contains.</p> In\u00a0[15]: Copied! <pre>car_sales.dtypes\n</pre> car_sales.dtypes Out[15]: <pre>Make             object\nColour           object\nOdometer (KM)     int64\nDoors             int64\nPrice            object\ndtype: object</pre> <p>Notice how the <code>Price</code> column isn't an integer like <code>Odometer</code> or <code>Doors</code>. Don't worry, pandas makes this easy to fix.</p> <p><code>.describe()</code> gives you a quick statistical overview of the numerical columns.</p> In\u00a0[16]: Copied! <pre>car_sales.describe()\n</pre> car_sales.describe() Out[16]: Odometer (KM) Doors count 10.000000 10.000000 mean 78601.400000 4.000000 std 61983.471735 0.471405 min 11179.000000 3.000000 25% 35836.250000 4.000000 50% 57369.000000 4.000000 75% 96384.500000 4.000000 max 213095.000000 5.000000 <p><code>.info()</code> shows a handful of useful information about a <code>DataFrame</code> such as:</p> <ul> <li>How many entries (rows) there are</li> <li>Whether there are missing values (if a columns non-null value is less than the number of entries, it has missing values)</li> <li>The datatypes of each column</li> </ul> In\u00a0[17]: Copied! <pre>car_sales.info()\n</pre> car_sales.info() <pre>&lt;class 'pandas.core.frame.DataFrame'&gt;\nRangeIndex: 10 entries, 0 to 9\nData columns (total 5 columns):\n #   Column         Non-Null Count  Dtype \n---  ------         --------------  ----- \n 0   Make           10 non-null     object\n 1   Colour         10 non-null     object\n 2   Odometer (KM)  10 non-null     int64 \n 3   Doors          10 non-null     int64 \n 4   Price          10 non-null     object\ndtypes: int64(2), object(3)\nmemory usage: 532.0+ bytes\n</pre> <p>You can also call various statistical and mathematical methods such as <code>.mean()</code> or <code>.sum()</code> directly on a <code>DataFrame</code> or <code>Series</code>.</p> In\u00a0[18]: Copied! <pre># Calling .mean() on a DataFrame\ncar_sales.mean(numeric_only=True) # numeric_only = get mean values of numeric columnns only\n</pre> # Calling .mean() on a DataFrame car_sales.mean(numeric_only=True) # numeric_only = get mean values of numeric columnns only Out[18]: <pre>Odometer (KM)    78601.4\nDoors                4.0\ndtype: float64</pre> In\u00a0[19]: Copied! <pre># Calling .mean() on a Series\ncar_prices = pd.Series([3000, 3500, 11250])\ncar_prices.mean()\n</pre> # Calling .mean() on a Series car_prices = pd.Series([3000, 3500, 11250]) car_prices.mean() Out[19]: <pre>np.float64(5916.666666666667)</pre> In\u00a0[20]: Copied! <pre># Calling .sum() on a DataFrame with numeric_only=False (default)\ncar_sales.sum(numeric_only=False)\n</pre> # Calling .sum() on a DataFrame with numeric_only=False (default) car_sales.sum(numeric_only=False) Out[20]: <pre>Make             ToyotaHondaToyotaBMWNissanToyotaHondaHondaToyo...\nColour               WhiteRedBlueBlackWhiteGreenBlueBlueWhiteWhite\nOdometer (KM)                                               786014\nDoors                                                           40\nPrice            $4,000.00$5,000.00$7,000.00$22,000.00$3,500.00...\ndtype: object</pre> In\u00a0[21]: Copied! <pre># Calling .sum() on a DataFrame with numeric_only=True\ncar_sales.sum(numeric_only=True)\n</pre> # Calling .sum() on a DataFrame with numeric_only=True car_sales.sum(numeric_only=True) Out[21]: <pre>Odometer (KM)    786014\nDoors                40\ndtype: int64</pre> In\u00a0[22]: Copied! <pre># Calling .sum() on a Series\ncar_prices.sum()\n</pre> # Calling .sum() on a Series car_prices.sum() Out[22]: <pre>np.int64(17750)</pre> <p>Calling these on a whole <code>DataFrame</code> may not be as helpful as targeting an individual column. But it's helpful to know they're there.</p> <p><code>.columns</code> will show you all the columns of a <code>DataFrame</code>.</p> In\u00a0[23]: Copied! <pre>car_sales.columns\n</pre> car_sales.columns Out[23]: <pre>Index(['Make', 'Colour', 'Odometer (KM)', 'Doors', 'Price'], dtype='object')</pre> <p>You can save them to a list which you could use later.</p> In\u00a0[24]: Copied! <pre># Save car_sales columns to a list \ncar_columns = car_sales.columns\ncar_columns[0]\n</pre> # Save car_sales columns to a list  car_columns = car_sales.columns car_columns[0] Out[24]: <pre>'Make'</pre> <p><code>.index</code> will show you the values in a <code>DataFrame</code>'s index (the column on the far left).</p> In\u00a0[25]: Copied! <pre>car_sales.index\n</pre> car_sales.index Out[25]: <pre>RangeIndex(start=0, stop=10, step=1)</pre> <p>pandas <code>DataFrame</code>'s, like Python lists, are 0-indexed (unless otherwise changed). This means they start at 0.</p> <p></p> In\u00a0[26]: Copied! <pre># Show the length of a DataFrame\nlen(car_sales)\n</pre> # Show the length of a DataFrame len(car_sales) Out[26]: <pre>10</pre> <p>So even though the length of our <code>car_sales</code> dataframe is 10, this means the indexes go from 0-9.</p> In\u00a0[27]: Copied! <pre># Show the first 5 rows of car_sales\ncar_sales.head()\n</pre> # Show the first 5 rows of car_sales car_sales.head() Out[27]: Make Colour Odometer (KM) Doors Price 0 Toyota White 150043 4 $4,000.00 1 Honda Red 87899 4 $5,000.00 2 Toyota Blue 32549 3 $7,000.00 3 BMW Black 11179 5 $22,000.00 4 Nissan White 213095 4 $3,500.00 <p>Why 5 rows? Good question. I don't know the answer. But 5 seems like a good amount.</p> <p>Want more than 5?</p> <p>No worries, you can pass <code>.head()</code> an integer to display more than or less than 5 rows.</p> In\u00a0[28]: Copied! <pre># Show the first 7 rows of car_sales\ncar_sales.head(7)\n</pre> # Show the first 7 rows of car_sales car_sales.head(7) Out[28]: Make Colour Odometer (KM) Doors Price 0 Toyota White 150043 4 $4,000.00 1 Honda Red 87899 4 $5,000.00 2 Toyota Blue 32549 3 $7,000.00 3 BMW Black 11179 5 $22,000.00 4 Nissan White 213095 4 $3,500.00 5 Toyota Green 99213 4 $4,500.00 6 Honda Blue 45698 4 $7,500.00 <p><code>.tail()</code> allows you to see the bottom 5 rows of your <code>DataFrame</code>. This is helpful if your changes are influencing the bottom rows of your data.</p> In\u00a0[29]: Copied! <pre># Show bottom 5 rows of car_sales\ncar_sales.tail()\n</pre> # Show bottom 5 rows of car_sales car_sales.tail() Out[29]: Make Colour Odometer (KM) Doors Price 5 Toyota Green 99213 4 $4,500.00 6 Honda Blue 45698 4 $7,500.00 7 Honda Blue 54738 4 $7,000.00 8 Toyota White 60000 4 $6,250.00 9 Nissan White 31600 4 $9,700.00 <p>You can use <code>.loc[]</code> and <code>.iloc[]</code> to select data from your <code>Series</code> and <code>DataFrame</code>'s.</p> <p>Let's see.</p> In\u00a0[30]: Copied! <pre># Create a sample series\nanimals = pd.Series([\"cat\", \"dog\", \"bird\", \"snake\", \"ox\", \"lion\"], \n                    index=[0, 3, 9, 8, 67, 3])\nanimals\n</pre> # Create a sample series animals = pd.Series([\"cat\", \"dog\", \"bird\", \"snake\", \"ox\", \"lion\"],                      index=[0, 3, 9, 8, 67, 3]) animals Out[30]: <pre>0       cat\n3       dog\n9      bird\n8     snake\n67       ox\n3      lion\ndtype: object</pre> <p><code>.loc[]</code> takes an integer or label as input. And it chooses from your <code>Series</code> or <code>DataFrame</code> whichever index matches the number.</p> In\u00a0[31]: Copied! <pre># Select all indexes with 3\nanimals.loc[3]\n</pre> # Select all indexes with 3 animals.loc[3] Out[31]: <pre>3     dog\n3    lion\ndtype: object</pre> In\u00a0[32]: Copied! <pre># Select index 9\nanimals.loc[9]\n</pre> # Select index 9 animals.loc[9] Out[32]: <pre>'bird'</pre> <p>Let's try with our <code>car_sales</code> DataFrame.</p> In\u00a0[33]: Copied! <pre>car_sales\n</pre> car_sales Out[33]: Make Colour Odometer (KM) Doors Price 0 Toyota White 150043 4 $4,000.00 1 Honda Red 87899 4 $5,000.00 2 Toyota Blue 32549 3 $7,000.00 3 BMW Black 11179 5 $22,000.00 4 Nissan White 213095 4 $3,500.00 5 Toyota Green 99213 4 $4,500.00 6 Honda Blue 45698 4 $7,500.00 7 Honda Blue 54738 4 $7,000.00 8 Toyota White 60000 4 $6,250.00 9 Nissan White 31600 4 $9,700.00 In\u00a0[34]: Copied! <pre># Select row at index 3\ncar_sales.loc[3]\n</pre> # Select row at index 3 car_sales.loc[3] Out[34]: <pre>Make                    BMW\nColour                Black\nOdometer (KM)         11179\nDoors                     5\nPrice            $22,000.00\nName: 3, dtype: object</pre> <p><code>iloc[]</code> does a similar thing but works with exact positions.</p> In\u00a0[35]: Copied! <pre>animals\n</pre> animals Out[35]: <pre>0       cat\n3       dog\n9      bird\n8     snake\n67       ox\n3      lion\ndtype: object</pre> In\u00a0[36]: Copied! <pre># Select row at position 3\nanimals.iloc[3]\n</pre> # Select row at position 3 animals.iloc[3] Out[36]: <pre>'snake'</pre> <p>Even though <code>'snake'</code> appears at index 8 in the series, it's shown using <code>.iloc[3]</code> because it's at the 3rd (starting from 0) position.</p> <p>Let's try with the <code>car_sales</code> <code>DataFrame</code>.</p> In\u00a0[37]: Copied! <pre># Select row at position 3\ncar_sales.iloc[3]\n</pre> # Select row at position 3 car_sales.iloc[3] Out[37]: <pre>Make                    BMW\nColour                Black\nOdometer (KM)         11179\nDoors                     5\nPrice            $22,000.00\nName: 3, dtype: object</pre> <p>You can see it's the same as <code>.loc[]</code> because the index is in order, position 3 is the same as index 3.</p> <p>You can also use slicing with <code>.loc[]</code> and <code>.iloc[]</code>.</p> In\u00a0[38]: Copied! <pre># Get all rows up to position 3\nanimals.iloc[:3]\n</pre> # Get all rows up to position 3 animals.iloc[:3] Out[38]: <pre>0     cat\n3     dog\n9    bird\ndtype: object</pre> In\u00a0[39]: Copied! <pre># Get all rows up to (and including) index 3\ncar_sales.loc[:3]\n</pre> # Get all rows up to (and including) index 3 car_sales.loc[:3] Out[39]: Make Colour Odometer (KM) Doors Price 0 Toyota White 150043 4 $4,000.00 1 Honda Red 87899 4 $5,000.00 2 Toyota Blue 32549 3 $7,000.00 3 BMW Black 11179 5 $22,000.00 In\u00a0[40]: Copied! <pre># Get all rows of the \"Colour\" column\ncar_sales.loc[:, \"Colour\"] # note: \":\" stands for \"all\", e.g. \"all indices in the first axis\"\n</pre> # Get all rows of the \"Colour\" column car_sales.loc[:, \"Colour\"] # note: \":\" stands for \"all\", e.g. \"all indices in the first axis\" Out[40]: <pre>0    White\n1      Red\n2     Blue\n3    Black\n4    White\n5    Green\n6     Blue\n7     Blue\n8    White\n9    White\nName: Colour, dtype: object</pre> <p>When should you use <code>.loc[]</code> or <code>.iloc[]</code>?</p> <ul> <li>Use <code>.loc[]</code> when you're selecting rows and columns based on their lables or a condition (e.g. retrieving data for specific columns).</li> <li>Use <code>.iloc[]</code> when you're selecting rows and columns based on their integer index positions (e.g. extracting the first ten rows regardless of the labels).</li> </ul> <p>However, in saying this, it will often take a bit of practice with each of the methods before you figure out which you'd like to use.</p> <p>If you want to select a particular column, you can use <code>DataFrame.['COLUMN_NAME']</code>.</p> In\u00a0[41]: Copied! <pre># Select Make column\ncar_sales['Make']\n</pre> # Select Make column car_sales['Make'] Out[41]: <pre>0    Toyota\n1     Honda\n2    Toyota\n3       BMW\n4    Nissan\n5    Toyota\n6     Honda\n7     Honda\n8    Toyota\n9    Nissan\nName: Make, dtype: object</pre> In\u00a0[42]: Copied! <pre># Select Colour column\ncar_sales['Colour']\n</pre> # Select Colour column car_sales['Colour'] Out[42]: <pre>0    White\n1      Red\n2     Blue\n3    Black\n4    White\n5    Green\n6     Blue\n7     Blue\n8    White\n9    White\nName: Colour, dtype: object</pre> <p>Boolean indexing works with column selection too. Using it will select the rows which fulfill the condition in the brackets.</p> In\u00a0[43]: Copied! <pre># Select cars with over 100,000 on the Odometer\ncar_sales[car_sales[\"Odometer (KM)\"] &gt; 100000]\n</pre> # Select cars with over 100,000 on the Odometer car_sales[car_sales[\"Odometer (KM)\"] &gt; 100000] Out[43]: Make Colour Odometer (KM) Doors Price 0 Toyota White 150043 4 $4,000.00 4 Nissan White 213095 4 $3,500.00 In\u00a0[44]: Copied! <pre># Select cars which are made by Toyota\ncar_sales[car_sales[\"Make\"] == \"Toyota\"]\n</pre> # Select cars which are made by Toyota car_sales[car_sales[\"Make\"] == \"Toyota\"] Out[44]: Make Colour Odometer (KM) Doors Price 0 Toyota White 150043 4 $4,000.00 2 Toyota Blue 32549 3 $7,000.00 5 Toyota Green 99213 4 $4,500.00 8 Toyota White 60000 4 $6,250.00 <p><code>pd.crosstab()</code> is a great way to view two different columns together and compare them.</p> In\u00a0[45]: Copied! <pre># Compare car Make with number of Doors\npd.crosstab(car_sales[\"Make\"], car_sales[\"Doors\"])\n</pre> # Compare car Make with number of Doors pd.crosstab(car_sales[\"Make\"], car_sales[\"Doors\"]) Out[45]: Doors 3 4 5 Make BMW 0 0 1 Honda 0 3 0 Nissan 0 2 0 Toyota 1 3 0 <p>If you want to compare more columns in the context of another column, you can use <code>.groupby()</code>.</p> In\u00a0[46]: Copied! <pre>car_sales\n</pre> car_sales Out[46]: Make Colour Odometer (KM) Doors Price 0 Toyota White 150043 4 $4,000.00 1 Honda Red 87899 4 $5,000.00 2 Toyota Blue 32549 3 $7,000.00 3 BMW Black 11179 5 $22,000.00 4 Nissan White 213095 4 $3,500.00 5 Toyota Green 99213 4 $4,500.00 6 Honda Blue 45698 4 $7,500.00 7 Honda Blue 54738 4 $7,000.00 8 Toyota White 60000 4 $6,250.00 9 Nissan White 31600 4 $9,700.00 In\u00a0[47]: Copied! <pre># Group by the Make column and find the mean of the other columns \ncar_sales.groupby([\"Make\"]).mean(numeric_only=True)\n</pre> # Group by the Make column and find the mean of the other columns  car_sales.groupby([\"Make\"]).mean(numeric_only=True) Out[47]: Odometer (KM) Doors Make BMW 11179.000000 5.00 Honda 62778.333333 4.00 Nissan 122347.500000 4.00 Toyota 85451.250000 3.75 <p>pandas even allows for quick plotting of columns so you can see your data visualling. To plot, you'll have to import <code>matplotlib</code>. If your plots aren't showing, try running the two lines of code below.</p> <p><code>%matplotlib inline</code> is a special command which tells Jupyter to show your plots. Commands with <code>%</code> at the front are called magic commands.</p> In\u00a0[52]: Copied! <pre># Import matplotlib and tell Jupyter to show plots\nimport matplotlib.pyplot as plt\n%matplotlib inline\n</pre> # Import matplotlib and tell Jupyter to show plots import matplotlib.pyplot as plt %matplotlib inline <p>You can visualize a column by calling <code>.plot()</code> on it.</p> In\u00a0[53]: Copied! <pre>car_sales[\"Odometer (KM)\"].plot(); # tip: the \";\" on the end prevents matplotlib from outputing the plot class\n</pre> car_sales[\"Odometer (KM)\"].plot(); # tip: the \";\" on the end prevents matplotlib from outputing the plot class <p>Or compare two columns by passing them as <code>x</code> and <code>y</code> to <code>plot()</code>.</p> In\u00a0[54]: Copied! <pre>car_sales.plot(x=\"Make\", y=\"Odometer (KM)\");\n</pre> car_sales.plot(x=\"Make\", y=\"Odometer (KM)\");  <p>You can see the distribution of a column by calling <code>.hist()</code> on you.</p> <p>The distribution of something is a way of describing the spread of different values.</p> In\u00a0[55]: Copied! <pre>car_sales[\"Odometer (KM)\"].hist()\n</pre> car_sales[\"Odometer (KM)\"].hist() Out[55]: <pre>&lt;Axes: &gt;</pre> <p>In this case, the majority of the distribution (spread) of the <code>\"Odometer (KM)\"</code> column is more towards the left of the graph. And there are two values which are more to the right. These two values to the right could be considered outliers (not part of the majority).</p> <p>Now what if we wanted to plot our <code>\"Price\"</code> column?</p> <p>Let's try.</p> In\u00a0[56]: Copied! <pre>car_sales[\"Price\"].plot()\n</pre> car_sales[\"Price\"].plot() <pre>\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\nCell In[56], line 1\n----&gt; 1 car_sales[\"Price\"].plot()\n\nFile ~/miniforge3/envs/ai/lib/python3.11/site-packages/pandas/plotting/_core.py:1030, in PlotAccessor.__call__(self, *args, **kwargs)\n   1027             label_name = label_kw or data.columns\n   1028             data.columns = label_name\n-&gt; 1030 return plot_backend.plot(data, kind=kind, **kwargs)\n\nFile ~/miniforge3/envs/ai/lib/python3.11/site-packages/pandas/plotting/_matplotlib/__init__.py:71, in plot(data, kind, **kwargs)\n     69         kwargs[\"ax\"] = getattr(ax, \"left_ax\", ax)\n     70 plot_obj = PLOT_CLASSES[kind](data, **kwargs)\n---&gt; 71 plot_obj.generate()\n     72 plot_obj.draw()\n     73 return plot_obj.result\n\nFile ~/miniforge3/envs/ai/lib/python3.11/site-packages/pandas/plotting/_matplotlib/core.py:499, in MPLPlot.generate(self)\n    497 @final\n    498 def generate(self) -&gt; None:\n--&gt; 499     self._compute_plot_data()\n    500     fig = self.fig\n    501     self._make_plot(fig)\n\nFile ~/miniforge3/envs/ai/lib/python3.11/site-packages/pandas/plotting/_matplotlib/core.py:698, in MPLPlot._compute_plot_data(self)\n    696 # no non-numeric frames or series allowed\n    697 if is_empty:\n--&gt; 698     raise TypeError(\"no numeric data to plot\")\n    700 self.data = numeric_data.apply(type(self)._convert_to_ndarray)\n\nTypeError: no numeric data to plot</pre> <p>Trying to run it leaves us with an error. This is because the <code>\"Price\"</code> column of <code>car_sales</code> isn't in numeric form. We can tell this because of the <code>TypeError: no numeric data to plot</code> at the bottom of the cell.</p> <p>We can check this with <code>.info()</code>.</p> In\u00a0[57]: Copied! <pre>car_sales.info()\n</pre> car_sales.info() <pre>&lt;class 'pandas.core.frame.DataFrame'&gt;\nRangeIndex: 10 entries, 0 to 9\nData columns (total 5 columns):\n #   Column         Non-Null Count  Dtype \n---  ------         --------------  ----- \n 0   Make           10 non-null     object\n 1   Colour         10 non-null     object\n 2   Odometer (KM)  10 non-null     int64 \n 3   Doors          10 non-null     int64 \n 4   Price          10 non-null     object\ndtypes: int64(2), object(3)\nmemory usage: 532.0+ bytes\n</pre> <p>So what can we do?</p> <p>We need to convert the <code>\"Price\"</code> column to a numeric type.</p> <p>How?</p> <p>We could try a few different things on our own. But let's practice researching.</p> <p>1. Open up a search engine and type in something like \"how to convert a pandas column price to integer\".</p> <p>In the first result, I found this Stack Overflow question and answer . Where someone has had the same problem as us and someone else has provided an answer.</p> <p>Note: Sometimes the answer you're looking for won't be in the first result, or the 2nd or the 3rd. You may have to combine a few different solutions. Or, if possible, you can try and ask ChatGPT to help you out.</p> <p>2. In practice, you'd read through this and see if it relates to your problem.</p> <p>3. If it does, you can adjust the code from what's given in the Stack Overflow answer(s) to your own problem.</p> <p>4. If you're still stuck, you can try and converse with ChatGPT to help you with your problem (as long as the data/problem you're working on is okay to share - never share private data with anyone on the internet, including AI chatbots).</p> <p></p> <p>What's important in the beginning is not to remember every single detail off by heart but to know where to look. Remember, if in doubt, write code, run it, see what happens.</p> <p>Let's copy the answer code here and see how it relates to our problem.</p> <p>Answer code: <code>dataframe['amount'] = dataframe['amount'].str.replace('[\\$\\,\\.]', '').astype(int)</code></p> <p>There's a lot going on here but what we can do is change the parts which aren't in our problem and keep the rest the same.</p> <p>Our <code>DataFrame</code> is called <code>car_sales</code> not <code>dataframe</code>.</p> <p><code>car_sales['amount'] = car_sales['amount'].str.replace('[\\$\\,\\.]', '').astype(int)</code></p> <p>And our <code>'amount'</code> column is called <code>\"Price\"</code>.</p> <p><code>car_sales[\"Price\"] = car_sales[\"Price\"].str.replace('[\\$\\,\\.]', '').astype(int)</code></p> <p>That looks better. What the code on the right of <code>car_sales[\"Price\"]</code> is saying is \"remove the $ sign and comma and change the type of the cell to int\".</p> <p>Let's see what happens.</p> In\u00a0[58]: Copied! <pre># Change Price column to integers\ncar_sales[\"Price\"] = car_sales[\"Price\"].str.replace('[\\$\\,\\.]', '', regex=True)\ncar_sales\n</pre> # Change Price column to integers car_sales[\"Price\"] = car_sales[\"Price\"].str.replace('[\\$\\,\\.]', '', regex=True) car_sales Out[58]: Make Colour Odometer (KM) Doors Price 0 Toyota White 150043 4 400000 1 Honda Red 87899 4 500000 2 Toyota Blue 32549 3 700000 3 BMW Black 11179 5 2200000 4 Nissan White 213095 4 350000 5 Toyota Green 99213 4 450000 6 Honda Blue 45698 4 750000 7 Honda Blue 54738 4 700000 8 Toyota White 60000 4 625000 9 Nissan White 31600 4 970000 <p>Cool! but there are extra zeros in the <code>Price</code> column.</p> <p>Let's remove it.</p> In\u00a0[59]: Copied! <pre># Remove 2 extra zeros from the price column (2200000 -&gt; 22000) by indexing all but the last two digits\ncar_sales[\"Price\"] = car_sales[\"Price\"].str[:-2].astype(int)\ncar_sales\n</pre> # Remove 2 extra zeros from the price column (2200000 -&gt; 22000) by indexing all but the last two digits car_sales[\"Price\"] = car_sales[\"Price\"].str[:-2].astype(int) car_sales Out[59]: Make Colour Odometer (KM) Doors Price 0 Toyota White 150043 4 4000 1 Honda Red 87899 4 5000 2 Toyota Blue 32549 3 7000 3 BMW Black 11179 5 22000 4 Nissan White 213095 4 3500 5 Toyota Green 99213 4 4500 6 Honda Blue 45698 4 7500 7 Honda Blue 54738 4 7000 8 Toyota White 60000 4 6250 9 Nissan White 31600 4 9700 In\u00a0[60]: Copied! <pre>car_sales.dtypes\n</pre> car_sales.dtypes Out[60]: <pre>Make             object\nColour           object\nOdometer (KM)     int64\nDoors             int64\nPrice             int64\ndtype: object</pre> <p>Beautiful! Now let's try to plot it agian.</p> In\u00a0[61]: Copied! <pre>car_sales[\"Price\"].plot();\n</pre> car_sales[\"Price\"].plot(); <p>This is one of the many ways you can manipulate data using pandas.</p> <p>When you see a number of different functions in a row, it's referred to as chaining. This means you add together a series of functions all to do one overall task.</p> <p>Let's see a few more ways of manipulating data.</p> In\u00a0[62]: Copied! <pre># Lower the Make column\ncar_sales[\"Make\"].str.lower()\n</pre> # Lower the Make column car_sales[\"Make\"].str.lower() Out[62]: <pre>0    toyota\n1     honda\n2    toyota\n3       bmw\n4    nissan\n5    toyota\n6     honda\n7     honda\n8    toyota\n9    nissan\nName: Make, dtype: object</pre> <p>Notice how it doesn't change the values of the original <code>car_sales</code> <code>DataFrame</code> unless we set it equal to.</p> In\u00a0[63]: Copied! <pre># View top 5 rows, Make column not lowered\ncar_sales.head()\n</pre> # View top 5 rows, Make column not lowered car_sales.head() Out[63]: Make Colour Odometer (KM) Doors Price 0 Toyota White 150043 4 4000 1 Honda Red 87899 4 5000 2 Toyota Blue 32549 3 7000 3 BMW Black 11179 5 22000 4 Nissan White 213095 4 3500 In\u00a0[64]: Copied! <pre># Set Make column to be lowered\ncar_sales[\"Make\"] = car_sales[\"Make\"].str.lower()\ncar_sales.head()\n</pre> # Set Make column to be lowered car_sales[\"Make\"] = car_sales[\"Make\"].str.lower() car_sales.head() Out[64]: Make Colour Odometer (KM) Doors Price 0 toyota White 150043 4 4000 1 honda Red 87899 4 5000 2 toyota Blue 32549 3 7000 3 bmw Black 11179 5 22000 4 nissan White 213095 4 3500 <p>Reassigning the column changes it in the original <code>DataFrame</code>. This trend occurs throughout all kinds of data manipulation with pandas.</p> <p>Some functions have a parameter called <code>inplace</code> which means a <code>DataFrame</code> is updated in place without having to reassign it.</p> <p>Let's see what it looks like in combination with <code>.fillna()</code>, a function which fills missing data. But the thing is, our table isn't missing any data.</p> <p>In practice, it's likely you'll work with datasets which aren't complete. What this means is you'll have to decide whether how to fill the missing data or remove the rows which have data missing.</p> <p>Let's check out what a version of our <code>car_sales</code> <code>DataFrame</code> might look like with missing values.</p> In\u00a0[65]: Copied! <pre># Option 1: Import car sales data with missing values from local file (stored on our computer)\ncar_sales_missing = pd.read_csv(\"../data/car-sales-missing-data.csv\")\n\n# Option 2: Import car sales data with missing values from GitHub (if the file is hosted online)\ncar_sales_missing = pd.read_csv(\"https://raw.githubusercontent.com/mrdbourke/zero-to-mastery-ml/master/data/car-sales-missing-data.csv\")\ncar_sales_missing\n</pre> # Option 1: Import car sales data with missing values from local file (stored on our computer) car_sales_missing = pd.read_csv(\"../data/car-sales-missing-data.csv\")  # Option 2: Import car sales data with missing values from GitHub (if the file is hosted online) car_sales_missing = pd.read_csv(\"https://raw.githubusercontent.com/mrdbourke/zero-to-mastery-ml/master/data/car-sales-missing-data.csv\") car_sales_missing Out[65]: Make Colour Odometer Doors Price 0 Toyota White 150043.0 4.0 $4,000 1 Honda Red 87899.0 4.0 $5,000 2 Toyota Blue NaN 3.0 $7,000 3 BMW Black 11179.0 5.0 $22,000 4 Nissan White 213095.0 4.0 $3,500 5 Toyota Green NaN 4.0 $4,500 6 Honda NaN NaN 4.0 $7,500 7 Honda Blue NaN 4.0 NaN 8 Toyota White 60000.0 NaN NaN 9 NaN White 31600.0 4.0 $9,700 <p>Missing values are shown by <code>NaN</code> in pandas. This can be considered the equivalent of <code>None</code> in Python.</p> <p>Let's use the <code>.fillna()</code> function to fill the <code>Odometer</code> column with the average of the other values in the same column.</p> In\u00a0[66]: Copied! <pre># Fill Odometer column missing values with mean\ncar_sales_missing[\"Odometer\"].fillna(car_sales_missing[\"Odometer\"].mean(), \n                                     inplace=False) # inplace is set to False by default\n</pre> # Fill Odometer column missing values with mean car_sales_missing[\"Odometer\"].fillna(car_sales_missing[\"Odometer\"].mean(),                                       inplace=False) # inplace is set to False by default  Out[66]: <pre>0    150043.000000\n1     87899.000000\n2     92302.666667\n3     11179.000000\n4    213095.000000\n5     92302.666667\n6     92302.666667\n7     92302.666667\n8     60000.000000\n9     31600.000000\nName: Odometer, dtype: float64</pre> <p>Now let's check the original <code>car_sales_missing</code> <code>DataFrame</code>.</p> In\u00a0[67]: Copied! <pre>car_sales_missing\n</pre> car_sales_missing Out[67]: Make Colour Odometer Doors Price 0 Toyota White 150043.0 4.0 $4,000 1 Honda Red 87899.0 4.0 $5,000 2 Toyota Blue NaN 3.0 $7,000 3 BMW Black 11179.0 5.0 $22,000 4 Nissan White 213095.0 4.0 $3,500 5 Toyota Green NaN 4.0 $4,500 6 Honda NaN NaN 4.0 $7,500 7 Honda Blue NaN 4.0 NaN 8 Toyota White 60000.0 NaN NaN 9 NaN White 31600.0 4.0 $9,700 <p>Because <code>inplace</code> is set to <code>False</code> (default), there's still missing values in the <code>\"Odometer\"</code> column.</p> <p>Instead of using <code>inplace</code>, let's resassign the column to the filled version.</p> <p>We'll use the syntax <code>df[col] = df[col].fillna(value)</code> to fill the missing values in the <code>\"Odometer\"</code> column with the average of the other values in the same column.</p> In\u00a0[68]: Copied! <pre># Fill the Odometer missing values to the mean with inplace=True\ncar_sales_missing[\"Odometer\"] = car_sales_missing[\"Odometer\"].fillna(car_sales_missing[\"Odometer\"].mean())\n</pre> # Fill the Odometer missing values to the mean with inplace=True car_sales_missing[\"Odometer\"] = car_sales_missing[\"Odometer\"].fillna(car_sales_missing[\"Odometer\"].mean()) <p>Now let's check the <code>car_sales_missing</code> <code>DataFrame</code> again.</p> In\u00a0[69]: Copied! <pre>car_sales_missing\n</pre> car_sales_missing Out[69]: Make Colour Odometer Doors Price 0 Toyota White 150043.000000 4.0 $4,000 1 Honda Red 87899.000000 4.0 $5,000 2 Toyota Blue 92302.666667 3.0 $7,000 3 BMW Black 11179.000000 5.0 $22,000 4 Nissan White 213095.000000 4.0 $3,500 5 Toyota Green 92302.666667 4.0 $4,500 6 Honda NaN 92302.666667 4.0 $7,500 7 Honda Blue 92302.666667 4.0 NaN 8 Toyota White 60000.000000 NaN NaN 9 NaN White 31600.000000 4.0 $9,700 <p>The missing values in the <code>Odometer</code> column have been filled with the mean value of the same column.</p> <p>In practice, you might not want to fill a column's missing values with the mean, but this example was to show the difference between <code>inplace=False</code> (default) and <code>inplace=True</code>.</p> <p>Whichever you choose to use will depend on how you structure your code.</p> <p>All you have to remember is <code>inplace=False</code> returns a copy of the <code>DataFrame</code> you're working with.</p> <p>This is helpful if you want to make a duplicate of your current <code>DataFrame</code> and save it to another variable.</p> <p>Where as, <code>inplace=True</code> makes all the changes directly to the target <code>DataFrame</code>.</p> <p>We've filled some values but there's still missing values in <code>car_sales_missing</code>. Let's say you wanted to remove any rows which had missing data and only work with rows which had complete coverage.</p> <p>You can do this using <code>.dropna()</code>.</p> In\u00a0[70]: Copied! <pre># Remove missing data\ncar_sales_missing.dropna()\n</pre> # Remove missing data car_sales_missing.dropna() Out[70]: Make Colour Odometer Doors Price 0 Toyota White 150043.000000 4.0 $4,000 1 Honda Red 87899.000000 4.0 $5,000 2 Toyota Blue 92302.666667 3.0 $7,000 3 BMW Black 11179.000000 5.0 $22,000 4 Nissan White 213095.000000 4.0 $3,500 5 Toyota Green 92302.666667 4.0 $4,500 <p>It appears the rows with missing values have been removed, now let's check to make sure.</p> In\u00a0[71]: Copied! <pre>car_sales_missing\n</pre> car_sales_missing Out[71]: Make Colour Odometer Doors Price 0 Toyota White 150043.000000 4.0 $4,000 1 Honda Red 87899.000000 4.0 $5,000 2 Toyota Blue 92302.666667 3.0 $7,000 3 BMW Black 11179.000000 5.0 $22,000 4 Nissan White 213095.000000 4.0 $3,500 5 Toyota Green 92302.666667 4.0 $4,500 6 Honda NaN 92302.666667 4.0 $7,500 7 Honda Blue 92302.666667 4.0 NaN 8 Toyota White 60000.000000 NaN NaN 9 NaN White 31600.000000 4.0 $9,700 <p>Hmm, they're still there, can you guess why?</p> <p>It's because <code>.dropna()</code> has <code>inplace=False</code> as default. We can either set <code>inplace=True</code> or reassign the <code>car_sales_missing</code> <code>DataFrame</code>.</p> In\u00a0[72]: Copied! <pre># The following two lines do the same thing\ncar_sales_missing.dropna(inplace=True) # Operation happens inplace without reassignment\ncar_sales_missing = car_sales_missing.dropna() # car_sales_missing gets reassigned to same DataFrame but with dropped values\n</pre> # The following two lines do the same thing car_sales_missing.dropna(inplace=True) # Operation happens inplace without reassignment car_sales_missing = car_sales_missing.dropna() # car_sales_missing gets reassigned to same DataFrame but with dropped values   <p>Now if check again, the rows with missing values are gone and the index numbers have been updated.</p> In\u00a0[73]: Copied! <pre>car_sales_missing\n</pre> car_sales_missing Out[73]: Make Colour Odometer Doors Price 0 Toyota White 150043.000000 4.0 $4,000 1 Honda Red 87899.000000 4.0 $5,000 2 Toyota Blue 92302.666667 3.0 $7,000 3 BMW Black 11179.000000 5.0 $22,000 4 Nissan White 213095.000000 4.0 $3,500 5 Toyota Green 92302.666667 4.0 $4,500 <p>Instead of removing or filling data, what if you wanted to create it?</p> <p>For example, creating a column called <code>Seats</code> for number of seats.</p> <p>pandas allows for simple extra column creation on <code>DataFrame</code>'s.</p> <p>Three common ways are:</p> <ol> <li>Adding a <code>pandas.Series</code> as a column.</li> <li>Adding a Python list as a column.</li> <li>By using existing columns to create a new column.</li> </ol> In\u00a0[74]: Copied! <pre># Create a column from a pandas Series\nseats_column = pd.Series([5, 5, 5, 5, 5, 5, 5, 5, 5, 5])\ncar_sales[\"Seats\"] = seats_column\ncar_sales\n</pre> # Create a column from a pandas Series seats_column = pd.Series([5, 5, 5, 5, 5, 5, 5, 5, 5, 5]) car_sales[\"Seats\"] = seats_column car_sales Out[74]: Make Colour Odometer (KM) Doors Price Seats 0 toyota White 150043 4 4000 5 1 honda Red 87899 4 5000 5 2 toyota Blue 32549 3 7000 5 3 bmw Black 11179 5 22000 5 4 nissan White 213095 4 3500 5 5 toyota Green 99213 4 4500 5 6 honda Blue 45698 4 7500 5 7 honda Blue 54738 4 7000 5 8 toyota White 60000 4 6250 5 9 nissan White 31600 4 9700 5 <p>Creating a column is similar to selecting a column, you pass the target <code>DataFrame</code> along with a new column name in brackets.</p> In\u00a0[75]: Copied! <pre># Create a column from a Python list\nengine_sizes = [1.3, 2.0, 3.0, 4.2, 1.6, 1, 2.0, 2.3, 2.0, 3.0]\ncar_sales[\"Engine Size\"] = engine_sizes\ncar_sales\n</pre> # Create a column from a Python list engine_sizes = [1.3, 2.0, 3.0, 4.2, 1.6, 1, 2.0, 2.3, 2.0, 3.0] car_sales[\"Engine Size\"] = engine_sizes car_sales Out[75]: Make Colour Odometer (KM) Doors Price Seats Engine Size 0 toyota White 150043 4 4000 5 1.3 1 honda Red 87899 4 5000 5 2.0 2 toyota Blue 32549 3 7000 5 3.0 3 bmw Black 11179 5 22000 5 4.2 4 nissan White 213095 4 3500 5 1.6 5 toyota Green 99213 4 4500 5 1.0 6 honda Blue 45698 4 7500 5 2.0 7 honda Blue 54738 4 7000 5 2.3 8 toyota White 60000 4 6250 5 2.0 9 nissan White 31600 4 9700 5 3.0 <p>You can also make a column by directly combining the values of other columns. Such as, price per kilometre on the Odometer.</p> In\u00a0[76]: Copied! <pre># Column from other columns\ncar_sales[\"Price per KM\"] = car_sales[\"Price\"] / car_sales[\"Odometer (KM)\"]\ncar_sales\n</pre> # Column from other columns car_sales[\"Price per KM\"] = car_sales[\"Price\"] / car_sales[\"Odometer (KM)\"] car_sales Out[76]: Make Colour Odometer (KM) Doors Price Seats Engine Size Price per KM 0 toyota White 150043 4 4000 5 1.3 0.026659 1 honda Red 87899 4 5000 5 2.0 0.056883 2 toyota Blue 32549 3 7000 5 3.0 0.215060 3 bmw Black 11179 5 22000 5 4.2 1.967976 4 nissan White 213095 4 3500 5 1.6 0.016425 5 toyota Green 99213 4 4500 5 1.0 0.045357 6 honda Blue 45698 4 7500 5 2.0 0.164121 7 honda Blue 54738 4 7000 5 2.3 0.127882 8 toyota White 60000 4 6250 5 2.0 0.104167 9 nissan White 31600 4 9700 5 3.0 0.306962 <p>Now can you think why this might not be a great column to add?</p> <p>It could be confusing when a car with less kilometers on the odometer looks to cost more per kilometre than one with more.</p> <p>When buying a car, usually less kilometres on the odometer is better.</p> <p>This kind of column creation is called feature engineering, the practice of enriching your dataset with more information (either from it directly or elsewhere).</p> <p>If <code>Make</code>, <code>Colour</code>, <code>Doors</code> are features of the data, creating <code>Price per KM</code> could be another. But in this case, not a very good one.</p> <p>As for column creation, you can also create a new column setting all values to a one standard value.</p> In\u00a0[77]: Copied! <pre># Column to all 1 value (number of wheels)\ncar_sales[\"Number of wheels\"] = 4\ncar_sales\n</pre> # Column to all 1 value (number of wheels) car_sales[\"Number of wheels\"] = 4 car_sales Out[77]: Make Colour Odometer (KM) Doors Price Seats Engine Size Price per KM Number of wheels 0 toyota White 150043 4 4000 5 1.3 0.026659 4 1 honda Red 87899 4 5000 5 2.0 0.056883 4 2 toyota Blue 32549 3 7000 5 3.0 0.215060 4 3 bmw Black 11179 5 22000 5 4.2 1.967976 4 4 nissan White 213095 4 3500 5 1.6 0.016425 4 5 toyota Green 99213 4 4500 5 1.0 0.045357 4 6 honda Blue 45698 4 7500 5 2.0 0.164121 4 7 honda Blue 54738 4 7000 5 2.3 0.127882 4 8 toyota White 60000 4 6250 5 2.0 0.104167 4 9 nissan White 31600 4 9700 5 3.0 0.306962 4 In\u00a0[78]: Copied! <pre>car_sales[\"Passed road safety\"] = True\ncar_sales\n</pre> car_sales[\"Passed road safety\"] = True car_sales Out[78]: Make Colour Odometer (KM) Doors Price Seats Engine Size Price per KM Number of wheels Passed road safety 0 toyota White 150043 4 4000 5 1.3 0.026659 4 True 1 honda Red 87899 4 5000 5 2.0 0.056883 4 True 2 toyota Blue 32549 3 7000 5 3.0 0.215060 4 True 3 bmw Black 11179 5 22000 5 4.2 1.967976 4 True 4 nissan White 213095 4 3500 5 1.6 0.016425 4 True 5 toyota Green 99213 4 4500 5 1.0 0.045357 4 True 6 honda Blue 45698 4 7500 5 2.0 0.164121 4 True 7 honda Blue 54738 4 7000 5 2.3 0.127882 4 True 8 toyota White 60000 4 6250 5 2.0 0.104167 4 True 9 nissan White 31600 4 9700 5 3.0 0.306962 4 True <p>Now you've created some columns, you decide to show your colleague what you've done. When they ask about the <code>Price per KM</code> column, you tell them you're not really sure why it's there.</p> <p>You decide you better remove it to prevent confusion.</p> <p>You can remove a column using <code>.drop('COLUMN_NAME', axis=1)</code>.</p> In\u00a0[79]: Copied! <pre># Drop the Price per KM column\ncar_sales = car_sales.drop(\"Price per KM\", axis=1) # columns live on axis 1\ncar_sales\n</pre> # Drop the Price per KM column car_sales = car_sales.drop(\"Price per KM\", axis=1) # columns live on axis 1 car_sales Out[79]: Make Colour Odometer (KM) Doors Price Seats Engine Size Number of wheels Passed road safety 0 toyota White 150043 4 4000 5 1.3 4 True 1 honda Red 87899 4 5000 5 2.0 4 True 2 toyota Blue 32549 3 7000 5 3.0 4 True 3 bmw Black 11179 5 22000 5 4.2 4 True 4 nissan White 213095 4 3500 5 1.6 4 True 5 toyota Green 99213 4 4500 5 1.0 4 True 6 honda Blue 45698 4 7500 5 2.0 4 True 7 honda Blue 54738 4 7000 5 2.3 4 True 8 toyota White 60000 4 6250 5 2.0 4 True 9 nissan White 31600 4 9700 5 3.0 4 True <p>Why <code>axis=1</code>? Because that's the axis columns live on. Rows live on <code>axis=0</code>.</p> <p>Let's say you wanted to shuffle the order of your <code>DataFrame</code> so you could split it into train, validation and test sets. And even though the order of your samples was random, you wanted to make sure.</p> <p>To do so you could use <code>.sample(frac=1)</code>.</p> <p><code>.sample()</code> randomly samples different rows from a <code>DataFrame</code>.</p> <p>The <code>frac</code> parameter dictates the fraction, where 1 = 100% of rows, 0.5 = 50% of rows, 0.01 = 1% of rows.</p> <p>You can also use <code>.sample(n=1)</code> where <code>n</code> is the number of rows to sample.</p> In\u00a0[80]: Copied! <pre># Sample car_sales\ncar_sales_sampled = car_sales.sample(frac=1)\ncar_sales_sampled\n</pre> # Sample car_sales car_sales_sampled = car_sales.sample(frac=1) car_sales_sampled Out[80]: Make Colour Odometer (KM) Doors Price Seats Engine Size Number of wheels Passed road safety 2 toyota Blue 32549 3 7000 5 3.0 4 True 4 nissan White 213095 4 3500 5 1.6 4 True 9 nissan White 31600 4 9700 5 3.0 4 True 1 honda Red 87899 4 5000 5 2.0 4 True 0 toyota White 150043 4 4000 5 1.3 4 True 8 toyota White 60000 4 6250 5 2.0 4 True 3 bmw Black 11179 5 22000 5 4.2 4 True 5 toyota Green 99213 4 4500 5 1.0 4 True 6 honda Blue 45698 4 7500 5 2.0 4 True 7 honda Blue 54738 4 7000 5 2.3 4 True <p>Notice how the rows remain intact but their order is mixed (check the indexes).</p> <p><code>.sample(frac=X)</code> is also helpful when you're working with a large <code>DataFrame</code>.</p> <p>Say you had 2,000,000 rows.</p> <p>Running tests, analysis and machine learning algorithms on 2,000,000 rows could take a long time. And since being a data scientist or machine learning engineer is about reducing the time between experiments, you might begin with a sample of rows first.</p> <p>For example, you could use <code>40k_rows = 2_mil_rows.sample(frac=0.05)</code> to work on 40,000 rows from a <code>DataFrame</code> called <code>2_mil_rows</code> containing 2,000,000 rows.</p> <p>What if you wanted to get the indexes back in order?</p> <p>You could do so using <code>.reset_index()</code>.</p> In\u00a0[81]: Copied! <pre># Reset the indexes of car_sales_sampled\ncar_sales_sampled.reset_index()\n</pre> # Reset the indexes of car_sales_sampled car_sales_sampled.reset_index() Out[81]: index Make Colour Odometer (KM) Doors Price Seats Engine Size Number of wheels Passed road safety 0 2 toyota Blue 32549 3 7000 5 3.0 4 True 1 4 nissan White 213095 4 3500 5 1.6 4 True 2 9 nissan White 31600 4 9700 5 3.0 4 True 3 1 honda Red 87899 4 5000 5 2.0 4 True 4 0 toyota White 150043 4 4000 5 1.3 4 True 5 8 toyota White 60000 4 6250 5 2.0 4 True 6 3 bmw Black 11179 5 22000 5 4.2 4 True 7 5 toyota Green 99213 4 4500 5 1.0 4 True 8 6 honda Blue 45698 4 7500 5 2.0 4 True 9 7 honda Blue 54738 4 7000 5 2.3 4 True <p>Calling <code>.reset_index()</code> on a <code>DataFrame</code> resets the index numbers to their defaults. It also creates a new <code>Index</code> column by default which contains the previous index values.</p> <p>Finally, what if you wanted to apply a function to a column. Such as, converting the <code>Odometer</code> column from kilometers to miles.</p> <p>You can do so using the <code>.apply()</code> function and passing it a Python lambda function. We know there's about 1.6 kilometers in a mile, so if you divide the value in the <code>Odometer</code> column by 1.6, it should convert it to miles.</p> In\u00a0[82]: Copied! <pre># Change the Odometer values from kilometres to miles\ncar_sales[\"Odometer (KM)\"].apply(lambda x: x / 1.6)\n</pre> # Change the Odometer values from kilometres to miles car_sales[\"Odometer (KM)\"].apply(lambda x: x / 1.6) Out[82]: <pre>0     93776.875\n1     54936.875\n2     20343.125\n3      6986.875\n4    133184.375\n5     62008.125\n6     28561.250\n7     34211.250\n8     37500.000\n9     19750.000\nName: Odometer (KM), dtype: float64</pre> <p>Now let's check our <code>car_sales</code> <code>DataFrame</code>.</p> In\u00a0[83]: Copied! <pre>car_sales\n</pre> car_sales Out[83]: Make Colour Odometer (KM) Doors Price Seats Engine Size Number of wheels Passed road safety 0 toyota White 150043 4 4000 5 1.3 4 True 1 honda Red 87899 4 5000 5 2.0 4 True 2 toyota Blue 32549 3 7000 5 3.0 4 True 3 bmw Black 11179 5 22000 5 4.2 4 True 4 nissan White 213095 4 3500 5 1.6 4 True 5 toyota Green 99213 4 4500 5 1.0 4 True 6 honda Blue 45698 4 7500 5 2.0 4 True 7 honda Blue 54738 4 7000 5 2.3 4 True 8 toyota White 60000 4 6250 5 2.0 4 True 9 nissan White 31600 4 9700 5 3.0 4 True <p>The <code>Odometer</code> column didn't change. Can you guess why?</p> <p>We didn't reassign it.</p> In\u00a0[84]: Copied! <pre># Reassign the Odometer column to be miles instead of kilometers\ncar_sales[\"Odometer (KM)\"] = car_sales[\"Odometer (KM)\"].apply(lambda x: x / 1.6)\ncar_sales\n</pre> # Reassign the Odometer column to be miles instead of kilometers car_sales[\"Odometer (KM)\"] = car_sales[\"Odometer (KM)\"].apply(lambda x: x / 1.6) car_sales Out[84]: Make Colour Odometer (KM) Doors Price Seats Engine Size Number of wheels Passed road safety 0 toyota White 93776.875 4 4000 5 1.3 4 True 1 honda Red 54936.875 4 5000 5 2.0 4 True 2 toyota Blue 20343.125 3 7000 5 3.0 4 True 3 bmw Black 6986.875 5 22000 5 4.2 4 True 4 nissan White 133184.375 4 3500 5 1.6 4 True 5 toyota Green 62008.125 4 4500 5 1.0 4 True 6 honda Blue 28561.250 4 7500 5 2.0 4 True 7 honda Blue 34211.250 4 7000 5 2.3 4 True 8 toyota White 37500.000 4 6250 5 2.0 4 True 9 nissan White 19750.000 4 9700 5 3.0 4 True <p>If you've never seen a lambda function they can be tricky. What the line above is saying is \"take the value in the <code>Odometer (KM)</code> column (<code>x</code>) and set it to be itself divided by 1.6\".</p>"},{"location":"introduction-to-pandas/#a-quick-introduction-to-data-analysis-and-manipulation-with-python-and-pandas","title":"A Quick Introduction to Data Analysis and Manipulation with Python and pandas\u00b6","text":""},{"location":"introduction-to-pandas/#what-is-pandas","title":"What is pandas?\u00b6","text":"<p>If you're getting into machine learning and data science and you're using Python, you're going to use pandas.</p> <p>pandas is an open source library which helps you analyse and manipulate data.</p> <p></p>"},{"location":"introduction-to-pandas/#why-pandas","title":"Why pandas?\u00b6","text":"<p>pandas provides a simple to use but very capable set of functions you can use to on your data.</p> <p>It's integrated with many other data science and machine learning tools which use Python so having an understanding of it will be helpful throughout your journey.</p> <p>One of the main use cases you'll come across is using pandas to transform your data in a way which makes it usable with machine learning algorithms.</p>"},{"location":"introduction-to-pandas/#what-does-this-notebook-cover","title":"What does this notebook cover?\u00b6","text":"<p>Because the pandas library is vast, there's often many ways to do the same thing. This notebook covers some of the most fundamental functions of the library, which are more than enough to get started.</p>"},{"location":"introduction-to-pandas/#where-can-i-get-help","title":"Where can I get help?\u00b6","text":"<p>If you get stuck or think of something you'd like to do which this notebook doesn't cover, don't fear!</p> <p>The recommended steps you take are:</p> <ol> <li>Try it - Since pandas is very friendly, your first step should be to use what you know and try figure out the answer to your own question (getting it wrong is part of the process). If in doubt, run your code.</li> <li>Search for it - If trying it on your own doesn't work, since someone else has probably tried to do something similar, try searching for your problem in the following places (either via a search engine or direct):<ul> <li>pandas documentation - the best place for learning pandas, this resource covers all of the pandas functionality.</li> <li>Stack Overflow - this is the developers Q&amp;A hub, it's full of questions and answers of different problems across a wide range of software development topics and chances are, there's one related to your problem.</li> <li>ChatGPT - ChatGPT is very good at explaining code, however, it can make mistakes. Best to verify the code it writes first before using it. Try asking \"Can you explain the following code for me? {your code here}\" and then continue with follow up questions from there.</li> </ul> </li> </ol> <p>An example of searching for a pandas function might be:</p> <p>\"how to fill all the missing values of two columns using pandas\"</p> <p>Searching this on Google leads to this post on Stack Overflow: https://stackoverflow.com/questions/36556256/how-do-i-fill-na-values-in-multiple-columns-in-pandas</p> <p>The next steps here are to read through the post and see if it relates to your problem. If it does, great, take the code/information you need and rewrite it to suit your own problem.</p> <ol> <li>Ask for help - If you've been through the above 2 steps and you're still stuck, you might want to ask your question on Stack Overflow. Remember to be specific as possible and provide details on what you've tried.</li> </ol> <p>Remember, you don't have to learn all of these functions off by heart to begin with.</p> <p>What's most important is remembering to continually ask yourself, \"what am I trying to do with the data?\".</p> <p>Start by answering that question and then practicing finding the code which does it.</p> <p>Let's get started.</p>"},{"location":"introduction-to-pandas/#0-importing-pandas","title":"0. Importing pandas\u00b6","text":"<p>To get started using pandas, the first step is to import it.</p> <p>The most common way (and method you should use) is to import pandas as the abbreviation <code>pd</code> (e.g. <code>pandas</code> -&gt; <code>pd</code>).</p> <p>If you see the letters <code>pd</code> used anywhere in machine learning or data science, it's probably referring to the pandas library.</p>"},{"location":"introduction-to-pandas/#1-datatypes","title":"1. Datatypes\u00b6","text":"<p>pandas has two main datatypes, <code>Series</code> and <code>DataFrame</code>.</p> <ul> <li><code>pandas.Series</code> - a 1-dimensional column of data.</li> <li><code>pandas.DataFrame</code> (most common) - a 2-dimesional table of data with rows and columns.</li> </ul> <p>You can create a <code>Series</code> using <code>pd.Series()</code> and passing it a Python list.</p>"},{"location":"introduction-to-pandas/#exercises","title":"Exercises\u00b6","text":"<ol> <li>Make a <code>Series</code> of different foods.</li> <li>Make a <code>Series</code> of different dollar values (these can be integers).</li> <li>Combine your <code>Series</code>'s of foods and dollar values into a <code>DataFrame</code>.</li> </ol> <p>Try it out for yourself first, then see how your code goes against the solution.</p> <p>Note: Make sure your two <code>Series</code> are the same size before combining them in a DataFrame.</p>"},{"location":"introduction-to-pandas/#2-importing-data","title":"2. Importing data\u00b6","text":"<p>Creating <code>Series</code> and <code>DataFrame</code>'s from scratch is nice but what you'll usually be doing is importing your data in the form of a <code>.csv</code> (comma separated value), spreadsheet file or something similar such as an SQL database.</p> <p>pandas allows for easy importing of data like this through functions such as <code>pd.read_csv()</code> and <code>pd.read_excel()</code> (for Microsoft Excel files).</p> <p>Say you wanted to get this information from this Google Sheet document into a pandas <code>DataFrame</code>.</p> <p>You could export it as a <code>.csv</code> file and then import it using <code>pd.read_csv()</code>.</p> <p>Tip: If the Google Sheet is public, <code>pd.read_csv()</code> can read it via URL, try searching for \"pandas read Google Sheet with URL\".</p> <p>In this case, the exported <code>.csv</code> file is called <code>car-sales.csv</code>.</p>"},{"location":"introduction-to-pandas/#anatomy-of-a-dataframe","title":"Anatomy of a DataFrame\u00b6","text":"<p>Different functions use different labels for different things. This graphic sums up some of the main components of <code>DataFrame</code>'s and their different names.</p> <p></p>"},{"location":"introduction-to-pandas/#3-exporting-data","title":"3. Exporting data\u00b6","text":"<p>After you've made a few changes to your data, you might want to export it and save it so someone else can access the changes.</p> <p>pandas allows you to export <code>DataFrame</code>'s to <code>.csv</code> format using <code>.to_csv()</code> or spreadsheet format using <code>.to_excel()</code>.</p> <p>We haven't made any changes yet to the <code>car_sales</code> <code>DataFrame</code> but let's try export it.</p>"},{"location":"introduction-to-pandas/#exercises","title":"Exercises\u00b6","text":"<ol> <li>Practice importing a <code>.csv</code> file using <code>pd.read_csv()</code>, you can download <code>heart-disease.csv</code>. This file contains annonymous patient medical records and whether or not they have heart disease.</li> <li>Practice exporting a <code>DataFrame</code> using <code>.to_csv()</code>. You could export the heart disease <code>DataFrame</code> after you've imported it.</li> </ol> <p>Note:</p> <ul> <li>Make sure the <code>heart-disease.csv</code> file is in the same folder as your notebook orbe sure to use the filepath where the file is.</li> <li>You can name the variables and exported files whatever you like but make sure they're readable.</li> </ul>"},{"location":"introduction-to-pandas/#example-solution","title":"Example solution\u00b6","text":""},{"location":"introduction-to-pandas/#4-describing-data","title":"4. Describing data\u00b6","text":"<p>One of the first things you'll want to do after you import some data into a pandas <code>DataFrame</code> is to start exploring it.</p> <p>pandas has many built in functions which allow you to quickly get information about a <code>DataFrame</code>.</p> <p>Let's explore some using the <code>car_sales</code> <code>DataFrame</code>.</p>"},{"location":"introduction-to-pandas/#5-viewing-and-selecting-data","title":"5. Viewing and selecting data\u00b6","text":"<p>Some common methods for viewing and selecting data in a pandas DataFrame include:</p> <ul> <li><code>DataFrame.head(n=5)</code> - Displays the first <code>n</code> rows of a DataFrame (e.g. <code>car_sales.head()</code> will show the first 5 rows of the <code>car_sales</code> DataFrame).</li> <li><code>DataFrame.tail(n=5)</code> - Displays the last <code>n</code> rows of a DataFrame.</li> <li><code>DataFrame.loc[]</code> - Accesses a group of rows and columns by labels or a boolean array.</li> <li><code>DataFrame.iloc[]</code> - Accesses a group of rows and columns by integer indices (e.g. <code>car_sales.iloc[0]</code> shows all the columns from index <code>0</code>.</li> <li><code>DataFrame.columns</code> -  Lists the column labels of the DataFrame.</li> <li><code>DataFrame['A']</code> - Selects the column named <code>'A'</code> from the DataFrame.</li> <li><code>DataFrame[DataFrame['A'] &gt; 5]</code> - Boolean indexing filters rows based on column values meeting a condition (e.g. all rows from column <code>'A'</code> greater than <code>5</code>.</li> <li><code>DataFrame.plot()</code> - Creates a line plot of a DataFrame's columns (e.g. plot <code>Make</code> vs. <code>Odometer (KM)</code> columns with <code>car_sales[[\"Make\", \"Odometer (KM)\"]].plot();</code>).</li> <li><code>DataFrame.hist()</code> - Generates histograms for columns in a DataFrame.</li> <li><code>pandas.crosstab()</code> - Computes a cross-tabulation of two or more factors.</li> </ul> <p>In practice, you'll constantly be making changes to your data, and viewing it. Changing it, viewing it, changing it, viewing it.</p> <p>You won't always want to change all of the data in your <code>DataFrame</code>'s either. So there are just as many different ways to select data as there is to view it.</p> <p><code>.head()</code> allows you to view the first 5 rows of your <code>DataFrame</code>. You'll likely be using this one a lot.</p>"},{"location":"introduction-to-pandas/#6-manipulating-data","title":"6. Manipulating data\u00b6","text":"<p>You've seen an example of one way to manipulate data but pandas has many more.</p> <p>How many more?</p> <p>Put it this way, if you can imagine it, chances are, pandas can do it.</p> <p>Let's start with string methods. Because pandas is based on Python, however you can manipulate strings in Python, you can do the same in pandas.</p> <p>You can access the string value of a column using <code>.str</code>. Knowing this, how do you think you'd set a column to lowercase?</p>"},{"location":"introduction-to-pandas/#summary","title":"Summary\u00b6","text":""},{"location":"introduction-to-pandas/#main-topics-we-covered","title":"Main topics we covered\u00b6","text":"<ul> <li>Series - a single column (can be multiple rows) of values.</li> <li>DataFrame - multiple columns/rows of values (a DataFrame is comprised of multiple Series).</li> <li>Importing data - we used <code>pd.read_csv()</code> to read in a CSV (comma-separated values) file but there are multiple options for reading data.</li> <li>Exporting data - we exported our data using <code>to_csv()</code>, however there are multiple methods of exporting data.</li> <li>Describing data<ul> <li><code>df.dtypes</code> - find the datatypes present in a dataframe.</li> <li><code>df.describe()</code> - find various numerical features of a dataframe.</li> <li><code>df.info()</code> - find the number of rows and whether or not any of them are empty.</li> </ul> </li> <li>Viewing and selecting data<ul> <li><code>df.head()</code> - view the first 5 rows of <code>df</code>.</li> <li><code>df.loc</code> &amp; <code>df.iloc</code> - select specific parts of a dataframe.</li> <li><code>df['A']</code> - select column <code>A</code> of <code>df</code>.</li> <li><code>df[df['A'] &gt; 1000]</code> - selection column <code>A</code> rows with values over 1000 of <code>df</code>.</li> <li><code>df['A']</code> - plot values from column <code>A</code> using matplotlib (defaults to line graph).</li> </ul> </li> <li>Manipulating data and performing operations - pandas has many built-in functions you can use to manipulate data, also many of the Python operators (e.g. <code>+</code>, <code>-</code>, <code>&gt;</code>, <code>==</code>) work with pandas.</li> </ul>"},{"location":"introduction-to-pandas/#further-reading","title":"Further reading\u00b6","text":"<p>Since pandas is such a large library, it would be impossible to cover it all in one go.</p> <p>The following are some resources you might want to look into for more.</p> <ul> <li>Python for Data Analysis by Wes McKinney - possibly the most complete text of the pandas library (apart from the documentation itself) written by the creator of pandas.</li> <li>Data Manipulation with Pandas (section of Python Data Science Handbook by Jake VanderPlas) - a very hands-on approach to many of the main functions in the pandas library.</li> </ul>"},{"location":"introduction-to-pandas/#exercises","title":"Exercises\u00b6","text":"<p>After completing this notebook, you next thing should be to try out some more pandas code of your own.</p> <p>I'd suggest at least going through number 1 (write out all the code yourself), a couple from number 2 (again, write out the code yourself) and spend an hour reading number 3 (this is vast but keep it in mind).</p> <ol> <li>10-minute introduction to pandas - go through all the functions here and be sure to write out the code yourself.</li> <li>Pandas getting started tutorial - pick a couple from here which spark your interest and go through them both writing out the code for your self.</li> <li>Pandas essential basic functionality - spend an hour reading this and bookmark it for whenever you need to come back for an overview of pandas.</li> </ol>"},{"location":"introduction-to-scikit-learn/","title":"Introduction to Scikit-Learn","text":"<p>View source code | Read notebook in online book format</p> In\u00a0[1]: Copied! <pre>import datetime\nprint(f\"Last updated: {datetime.datetime.now()}\")\n</pre> import datetime print(f\"Last updated: {datetime.datetime.now()}\") <pre>Last updated: 2024-09-06 13:30:34.743560\n</pre> In\u00a0[2]: Copied! <pre># Standard imports\n# %matplotlib inline # No longer required in newer versions of Jupyter (2022+)\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport pandas as pd\n\nimport sklearn\nprint(f\"Using Scikit-Learn version: {sklearn.__version__} (materials in this notebook require this version or newer).\")\n</pre> # Standard imports # %matplotlib inline # No longer required in newer versions of Jupyter (2022+) import matplotlib.pyplot as plt import numpy as np import pandas as pd  import sklearn print(f\"Using Scikit-Learn version: {sklearn.__version__} (materials in this notebook require this version or newer).\") <pre>Using Scikit-Learn version: 1.5.1 (materials in this notebook require this version or newer).\n</pre> In\u00a0[3]: Copied! <pre>import pandas as pd\n\n# heart_disease = pd.read_csv(\"../data/heart-disease.csv\") # load data from local directory\nheart_disease = pd.read_csv(\"https://raw.githubusercontent.com/mrdbourke/zero-to-mastery-ml/master/data/heart-disease.csv\") # load data directly from URL (requires raw form on GitHub, source: https://github.com/mrdbourke/zero-to-mastery-ml/blob/master/data/heart-disease.csv)\nheart_disease.head()\n</pre> import pandas as pd  # heart_disease = pd.read_csv(\"../data/heart-disease.csv\") # load data from local directory heart_disease = pd.read_csv(\"https://raw.githubusercontent.com/mrdbourke/zero-to-mastery-ml/master/data/heart-disease.csv\") # load data directly from URL (requires raw form on GitHub, source: https://github.com/mrdbourke/zero-to-mastery-ml/blob/master/data/heart-disease.csv) heart_disease.head() Out[3]: age sex cp trestbps chol fbs restecg thalach exang oldpeak slope ca thal target 0 63 1 3 145 233 1 0 150 0 2.3 0 0 1 1 1 37 1 2 130 250 0 1 187 0 3.5 0 0 2 1 2 41 0 1 130 204 0 0 172 0 1.4 2 0 2 1 3 56 1 1 120 236 0 1 178 0 0.8 2 0 2 1 4 57 0 0 120 354 0 1 163 1 0.6 2 0 2 1 <p>Here, each row is a different patient and all columns except <code>target</code> are different patient characteristics.</p> <p>The <code>target</code> column indicates whether the patient has heart disease (<code>target=1</code>) or not (<code>target=0</code>), this is our \"label\" columnm, the variable we're going to try and predict.</p> <p>The rest of the columns (often called features) are what we'll be using to predict the <code>target</code> value.</p> <p>Note: It's a common custom to save features to a varialbe <code>X</code> and labels to a variable <code>y</code>. In practice, we'd like to use the <code>X</code> (features) to build a predictive algorithm to predict the <code>y</code> (labels).</p> In\u00a0[4]: Copied! <pre># Create X (all the feature columns)\nX = heart_disease.drop(\"target\", axis=1)\n\n# Create y (the target column)\ny = heart_disease[\"target\"]\n\n# Check the head of the features DataFrame\nX.head()\n</pre> # Create X (all the feature columns) X = heart_disease.drop(\"target\", axis=1)  # Create y (the target column) y = heart_disease[\"target\"]  # Check the head of the features DataFrame X.head() Out[4]: age sex cp trestbps chol fbs restecg thalach exang oldpeak slope ca thal 0 63 1 3 145 233 1 0 150 0 2.3 0 0 1 1 37 1 2 130 250 0 1 187 0 3.5 0 0 2 2 41 0 1 130 204 0 0 172 0 1.4 2 0 2 3 56 1 1 120 236 0 1 178 0 0.8 2 0 2 4 57 0 0 120 354 0 1 163 1 0.6 2 0 2 In\u00a0[5]: Copied! <pre># Check the head and the value counts of the labels \ny.head(), y.value_counts()\n</pre> # Check the head and the value counts of the labels  y.head(), y.value_counts() Out[5]: <pre>(0    1\n 1    1\n 2    1\n 3    1\n 4    1\n Name: target, dtype: int64,\n target\n 1    165\n 0    138\n Name: count, dtype: int64)</pre> <p>One of the most important practices in machine learning is to split datasets into training and test sets.</p> <p>As in, a model will train on the training set to learn patterns and then those patterns can be evaluated on the test set.</p> <p>Crucially, a model should never see testing data during training.</p> <p>This is equivalent to a student studying course materials during the semester (training set) and then testing their abilities on the following exam (testing set).</p> <p>Scikit-learn provides the <code>sklearn.model_selection.train_test_split</code> method to split datasets in training and test sets.</p> <p>Note: A common practice to use an 80/20 or 70/30 or 75/25 split for training/testing data. There is also a third set, known as a validation set (e.g. 70/15/15 for training/validation/test) for hyperparamter tuning on but for now we'll focus on training and test sets.</p> In\u00a0[6]: Copied! <pre># Split the data into training and test sets\nfrom sklearn.model_selection import train_test_split\n\nX_train, X_test, y_train, y_test = train_test_split(X, \n                                                    y,\n                                                    test_size=0.25) # by default train_test_split uses 25% of the data for the test set\n\nX_train.shape, X_test.shape, y_train.shape, y_test.shape\n</pre> # Split the data into training and test sets from sklearn.model_selection import train_test_split  X_train, X_test, y_train, y_test = train_test_split(X,                                                      y,                                                     test_size=0.25) # by default train_test_split uses 25% of the data for the test set  X_train.shape, X_test.shape, y_train.shape, y_test.shape Out[6]: <pre>((227, 13), (76, 13), (227,), (76,))</pre> In\u00a0[7]: Copied! <pre># Since we're working on a classification problem, we'll start with a RandomForestClassifier\nfrom sklearn.ensemble import RandomForestClassifier\n\nclf = RandomForestClassifier()\n</pre> # Since we're working on a classification problem, we'll start with a RandomForestClassifier from sklearn.ensemble import RandomForestClassifier  clf = RandomForestClassifier() <p>We can see the current hyperparameters of a model with the <code>get_params()</code> method.</p> In\u00a0[8]: Copied! <pre># View the current hyperparameters\nclf.get_params()\n</pre> # View the current hyperparameters clf.get_params() Out[8]: <pre>{'bootstrap': True,\n 'ccp_alpha': 0.0,\n 'class_weight': None,\n 'criterion': 'gini',\n 'max_depth': None,\n 'max_features': 'sqrt',\n 'max_leaf_nodes': None,\n 'max_samples': None,\n 'min_impurity_decrease': 0.0,\n 'min_samples_leaf': 1,\n 'min_samples_split': 2,\n 'min_weight_fraction_leaf': 0.0,\n 'monotonic_cst': None,\n 'n_estimators': 100,\n 'n_jobs': None,\n 'oob_score': False,\n 'random_state': None,\n 'verbose': 0,\n 'warm_start': False}</pre> <p>We'll leave this as is for now, as Scikit-Learn models generally have good default settings.</p> In\u00a0[9]: Copied! <pre>clf.fit(X=X_train, y=y_train)\n</pre> clf.fit(X=X_train, y=y_train) Out[9]: <pre>RandomForestClassifier()</pre>In a Jupyter environment, please rerun this cell to show the HTML representation or trust the notebook. On GitHub, the HTML representation is unable to render, please try loading this page with nbviewer.org.\u00a0\u00a0RandomForestClassifier?Documentation for RandomForestClassifieriFitted<pre>RandomForestClassifier()</pre> In\u00a0[10]: Copied! <pre># This doesn't work... incorrect shapes\ny_label = clf.predict(np.array([0, 2, 3, 4]))\n</pre> # This doesn't work... incorrect shapes y_label = clf.predict(np.array([0, 2, 3, 4])) <pre>/Users/daniel/miniforge3/envs/ai/lib/python3.11/site-packages/sklearn/base.py:493: UserWarning: X does not have valid feature names, but RandomForestClassifier was fitted with feature names\n  warnings.warn(\n</pre> <pre>\n---------------------------------------------------------------------------\nValueError                                Traceback (most recent call last)\nCell In[10], line 2\n      1 # This doesn't work... incorrect shapes\n----&gt; 2 y_label = clf.predict(np.array([0, 2, 3, 4]))\n\nFile ~/miniforge3/envs/ai/lib/python3.11/site-packages/sklearn/ensemble/_forest.py:904, in ForestClassifier.predict(self, X)\n    883 def predict(self, X):\n    884     \"\"\"\n    885     Predict class for X.\n    886 \n   (...)\n    902         The predicted classes.\n    903     \"\"\"\n--&gt; 904     proba = self.predict_proba(X)\n    906     if self.n_outputs_ == 1:\n    907         return self.classes_.take(np.argmax(proba, axis=1), axis=0)\n\nFile ~/miniforge3/envs/ai/lib/python3.11/site-packages/sklearn/ensemble/_forest.py:946, in ForestClassifier.predict_proba(self, X)\n    944 check_is_fitted(self)\n    945 # Check data\n--&gt; 946 X = self._validate_X_predict(X)\n    948 # Assign chunk of trees to jobs\n    949 n_jobs, _, _ = _partition_estimators(self.n_estimators, self.n_jobs)\n\nFile ~/miniforge3/envs/ai/lib/python3.11/site-packages/sklearn/ensemble/_forest.py:641, in BaseForest._validate_X_predict(self, X)\n    638 else:\n    639     force_all_finite = True\n--&gt; 641 X = self._validate_data(\n    642     X,\n    643     dtype=DTYPE,\n    644     accept_sparse=\"csr\",\n    645     reset=False,\n    646     force_all_finite=force_all_finite,\n    647 )\n    648 if issparse(X) and (X.indices.dtype != np.intc or X.indptr.dtype != np.intc):\n    649     raise ValueError(\"No support for np.int64 index based sparse matrices\")\n\nFile ~/miniforge3/envs/ai/lib/python3.11/site-packages/sklearn/base.py:633, in BaseEstimator._validate_data(self, X, y, reset, validate_separately, cast_to_ndarray, **check_params)\n    631         out = X, y\n    632 elif not no_val_X and no_val_y:\n--&gt; 633     out = check_array(X, input_name=\"X\", **check_params)\n    634 elif no_val_X and not no_val_y:\n    635     out = _check_y(y, **check_params)\n\nFile ~/miniforge3/envs/ai/lib/python3.11/site-packages/sklearn/utils/validation.py:1050, in check_array(array, accept_sparse, accept_large_sparse, dtype, order, copy, force_writeable, force_all_finite, ensure_2d, allow_nd, ensure_min_samples, ensure_min_features, estimator, input_name)\n   1043         else:\n   1044             msg = (\n   1045                 f\"Expected 2D array, got 1D array instead:\\narray={array}.\\n\"\n   1046                 \"Reshape your data either using array.reshape(-1, 1) if \"\n   1047                 \"your data has a single feature or array.reshape(1, -1) \"\n   1048                 \"if it contains a single sample.\"\n   1049             )\n-&gt; 1050         raise ValueError(msg)\n   1052 if dtype_numeric and hasattr(array.dtype, \"kind\") and array.dtype.kind in \"USV\":\n   1053     raise ValueError(\n   1054         \"dtype='numeric' is not compatible with arrays of bytes/strings.\"\n   1055         \"Convert your data to numeric values explicitly instead.\"\n   1056     )\n\nValueError: Expected 2D array, got 1D array instead:\narray=[0. 2. 3. 4.].\nReshape your data either using array.reshape(-1, 1) if your data has a single feature or array.reshape(1, -1) if it contains a single sample.</pre> <p>Oh no!</p> <p>We get a <code>ValueError</code> (mismatched shapes):</p> <pre><code>ValueError: Expected 2D array, got 1D array instead:\narray=[0. 2. 3. 4.].\nReshape your data either using array.reshape(-1, 1) if your data has a single feature or array.reshape(1, -1) if it contains a single sample.\n</code></pre> <p>This happens because we're trying to make predictions on data that is in a different format to the data our model was trained on.</p> <p>Since our model was trained on data from <code>X_train</code>, predictions should be made on data in the same format and shape as <code>X_train</code>.</p> <p>Our goal in many machine learning problems is to use patterns learned from the training data to make predictions on the test data (or future unseen data).</p> In\u00a0[11]: Copied! <pre># In order to predict a label, data has to be in the same shape as X_train\nX_test.head()\n</pre> # In order to predict a label, data has to be in the same shape as X_train X_test.head() Out[11]: age sex cp trestbps chol fbs restecg thalach exang oldpeak slope ca thal 165 67 1 0 160 286 0 0 108 1 1.5 1 3 2 71 51 1 2 94 227 0 1 154 1 0.0 2 1 3 24 40 1 3 140 199 0 1 178 1 1.4 2 0 3 19 69 0 3 140 239 0 1 151 0 1.8 2 2 2 258 62 0 0 150 244 0 1 154 1 1.4 1 0 2 In\u00a0[12]: Copied! <pre># Use the model to make a prediction on the test data (further evaluation)\ny_preds = clf.predict(X=X_test)\n</pre> # Use the model to make a prediction on the test data (further evaluation) y_preds = clf.predict(X=X_test) In\u00a0[13]: Copied! <pre># Evaluate the model on the training set\ntrain_acc = clf.score(X=X_train, y=y_train)\nprint(f\"The model's accuracy on the training dataset is: {train_acc*100}%\")\n</pre> # Evaluate the model on the training set train_acc = clf.score(X=X_train, y=y_train) print(f\"The model's accuracy on the training dataset is: {train_acc*100}%\") <pre>The model's accuracy on the training dataset is: 100.0%\n</pre> <p>Woah! Looks like our model does pretty well on the training datset.</p> <p>This is because it has a chance to see both data and labels.</p> <p>How about the test dataset?</p> In\u00a0[14]: Copied! <pre># Evaluate the model on the test set\ntest_acc = clf.score(X=X_test, y=y_test)\nprint(f\"The model's accuracy on the testing dataset is: {test_acc*100:.2f}%\")\n</pre> # Evaluate the model on the test set test_acc = clf.score(X=X_test, y=y_test) print(f\"The model's accuracy on the testing dataset is: {test_acc*100:.2f}%\") <pre>The model's accuracy on the testing dataset is: 88.16%\n</pre> <p>Hmm, looks like our model's accuracy is a bit less on the test dataset than the training dataset.</p> <p>This is quite often the case, because remember, a model has never seen the testing examples before.</p> <p>There are also a number of other evaluation methods we can use for our classification models.</p> <p>All of the following classification metrics come from the <code>sklearn.metrics</code> module:</p> <ul> <li><code>classification_report(y_true, y_true)</code> - Builds a text report showing various classification metrics such as precision, recall and F1-score.</li> <li><code>confusion_matrix(y_true, y_pred)</code> - Create a confusion matrix to compare predictions to truth labels.</li> <li><code>accuracy_score(y_true, y_pred)</code> - Find the accuracy score (the default metric) for a classifier.</li> </ul> <p>All metrics have the following in common: they compare a model's predictions (<code>y_pred</code>) to truth labels (<code>y_true</code>).</p> In\u00a0[15]: Copied! <pre>from sklearn.metrics import classification_report, confusion_matrix, accuracy_score\n\n# Create a classification report\nprint(classification_report(y_test, y_preds))\n</pre> from sklearn.metrics import classification_report, confusion_matrix, accuracy_score  # Create a classification report print(classification_report(y_test, y_preds)) <pre>              precision    recall  f1-score   support\n\n           0       0.87      0.84      0.85        31\n           1       0.89      0.91      0.90        45\n\n    accuracy                           0.88        76\n   macro avg       0.88      0.87      0.88        76\nweighted avg       0.88      0.88      0.88        76\n\n</pre> In\u00a0[16]: Copied! <pre># Create a confusion matrix\nconf_mat = confusion_matrix(y_test, y_preds)\nconf_mat\n</pre> # Create a confusion matrix conf_mat = confusion_matrix(y_test, y_preds) conf_mat Out[16]: <pre>array([[26,  5],\n       [ 4, 41]])</pre> In\u00a0[17]: Copied! <pre># Compute the accuracy score (same as the score() method for classifiers) \naccuracy_score(y_test, y_preds)\n</pre> # Compute the accuracy score (same as the score() method for classifiers)  accuracy_score(y_test, y_preds) Out[17]: <pre>0.881578947368421</pre> In\u00a0[18]: Copied! <pre># Try different numbers of estimators (trees)... (no cross-validation)\nnp.random.seed(42)\nfor i in range(100, 200, 10):\n    print(f\"Trying model with {i} estimators...\")\n    model = RandomForestClassifier(n_estimators=i).fit(X_train, y_train)\n    print(f\"Model accuracy on test set: {model.score(X_test, y_test) * 100:.2f}%\")\n    print(\"\")\n</pre> # Try different numbers of estimators (trees)... (no cross-validation) np.random.seed(42) for i in range(100, 200, 10):     print(f\"Trying model with {i} estimators...\")     model = RandomForestClassifier(n_estimators=i).fit(X_train, y_train)     print(f\"Model accuracy on test set: {model.score(X_test, y_test) * 100:.2f}%\")     print(\"\") <pre>Trying model with 100 estimators...\nModel accuracy on test set: 88.16%\n\nTrying model with 110 estimators...\nModel accuracy on test set: 90.79%\n\nTrying model with 120 estimators...\nModel accuracy on test set: 90.79%\n\nTrying model with 130 estimators...\nModel accuracy on test set: 89.47%\n\nTrying model with 140 estimators...\nModel accuracy on test set: 88.16%\n\nTrying model with 150 estimators...\nModel accuracy on test set: 94.74%\n\nTrying model with 160 estimators...\nModel accuracy on test set: 92.11%\n\nTrying model with 170 estimators...\nModel accuracy on test set: 92.11%\n\nTrying model with 180 estimators...\nModel accuracy on test set: 92.11%\n\nTrying model with 190 estimators...\nModel accuracy on test set: 89.47%\n\n</pre> <p>The metrics above were measured on a single train and test split.</p> <p>Let's use <code>sklearn.model_selection.cross_val_score</code> to measure the results across 5 different train and test sets.</p> <p>We can achieve this by setting <code>cross_val_score(X, y, cv=5)</code>.</p> <p>Where <code>X</code> is the full feature set and <code>y</code> is the full label set and <code>cv</code> is the number of train and test splits <code>cross_val_score</code> will automatically create from the data (in our case, <code>5</code> different splits, this is known as 5-fold cross-validation).</p> In\u00a0[19]: Copied! <pre>from sklearn.model_selection import cross_val_score\n\n# With cross-validation\nnp.random.seed(42)\nfor i in range(100, 200, 10):\n    print(f\"Trying model with {i} estimators...\")\n    model = RandomForestClassifier(n_estimators=i).fit(X_train, y_train)\n\n    # Measure the model score on a single train/test split\n    model_score = model.score(X_test, y_test)\n    print(f\"Model accuracy on single test set split: {model_score * 100:.2f}%\")\n    \n    # Measure the mean cross-validation score across 5 different train and test splits\n    cross_val_mean = np.mean(cross_val_score(model, X, y, cv=5))\n    print(f\"5-fold cross-validation score: {cross_val_mean * 100:.2f}%\")\n    \n    print(\"\")\n</pre> from sklearn.model_selection import cross_val_score  # With cross-validation np.random.seed(42) for i in range(100, 200, 10):     print(f\"Trying model with {i} estimators...\")     model = RandomForestClassifier(n_estimators=i).fit(X_train, y_train)      # Measure the model score on a single train/test split     model_score = model.score(X_test, y_test)     print(f\"Model accuracy on single test set split: {model_score * 100:.2f}%\")          # Measure the mean cross-validation score across 5 different train and test splits     cross_val_mean = np.mean(cross_val_score(model, X, y, cv=5))     print(f\"5-fold cross-validation score: {cross_val_mean * 100:.2f}%\")          print(\"\") <pre>Trying model with 100 estimators...\nModel accuracy on single test set split: 88.16%\n5-fold cross-validation score: 82.15%\n\nTrying model with 110 estimators...\nModel accuracy on single test set split: 94.74%\n5-fold cross-validation score: 81.17%\n\nTrying model with 120 estimators...\nModel accuracy on single test set split: 88.16%\n5-fold cross-validation score: 83.49%\n\nTrying model with 130 estimators...\nModel accuracy on single test set split: 89.47%\n5-fold cross-validation score: 83.14%\n\nTrying model with 140 estimators...\nModel accuracy on single test set split: 88.16%\n5-fold cross-validation score: 82.48%\n\nTrying model with 150 estimators...\nModel accuracy on single test set split: 90.79%\n5-fold cross-validation score: 80.17%\n\nTrying model with 160 estimators...\nModel accuracy on single test set split: 89.47%\n5-fold cross-validation score: 80.83%\n\nTrying model with 170 estimators...\nModel accuracy on single test set split: 86.84%\n5-fold cross-validation score: 82.16%\n\nTrying model with 180 estimators...\nModel accuracy on single test set split: 92.11%\n5-fold cross-validation score: 81.50%\n\nTrying model with 190 estimators...\nModel accuracy on single test set split: 88.16%\n5-fold cross-validation score: 81.83%\n\n</pre> <p>Which model had the best cross-validation score?</p> <p>This is usually a better indicator of a quality model than a single split accuracy score.</p> <p>Rather than set up and track the results of these experiments manually, we can get Scikit-Learn to do the exploration for us.</p> <p>Scikit-Learn's <code>sklearn.model_selection.GridSearchCV</code> is a way to search over a set of different hyperparameter values and automatically track which perform the best.</p> <p>Let's test it!</p> In\u00a0[20]: Copied! <pre># Another way to do it with GridSearchCV...\nnp.random.seed(42)\nfrom sklearn.model_selection import GridSearchCV\n\n# Define the parameters to search over in dictionary form \n# (these can be any of your target model's hyperparameters) \nparam_grid = {'n_estimators': [i for i in range(100, 200, 10)]}\n\n# Setup the grid search\ngrid = GridSearchCV(estimator=RandomForestClassifier(),\n                    param_grid=param_grid,\n                    cv=5,\n                    verbose=1) \n\n# Fit the grid search to the data\ngrid.fit(X, y)\n\n# Find the best parameters\nprint(f\"The best parameter values are: {grid.best_params_}\")\nprint(f\"With a score of: {grid.best_score_*100:.2f}%\")\n</pre> # Another way to do it with GridSearchCV... np.random.seed(42) from sklearn.model_selection import GridSearchCV  # Define the parameters to search over in dictionary form  # (these can be any of your target model's hyperparameters)  param_grid = {'n_estimators': [i for i in range(100, 200, 10)]}  # Setup the grid search grid = GridSearchCV(estimator=RandomForestClassifier(),                     param_grid=param_grid,                     cv=5,                     verbose=1)   # Fit the grid search to the data grid.fit(X, y)  # Find the best parameters print(f\"The best parameter values are: {grid.best_params_}\") print(f\"With a score of: {grid.best_score_*100:.2f}%\") <pre>Fitting 5 folds for each of 10 candidates, totalling 50 fits\nThe best parameter values are: {'n_estimators': 120}\nWith a score of: 82.82%\n</pre> <p>We can extract the best model/estimator with the <code>best_estimator_</code> attribute.</p> In\u00a0[21]: Copied! <pre># Set the model to be the best estimator\nclf = grid.best_estimator_\nclf\n</pre> # Set the model to be the best estimator clf = grid.best_estimator_ clf Out[21]: <pre>RandomForestClassifier(n_estimators=120)</pre>In a Jupyter environment, please rerun this cell to show the HTML representation or trust the notebook. On GitHub, the HTML representation is unable to render, please try loading this page with nbviewer.org.\u00a0\u00a0RandomForestClassifier?Documentation for RandomForestClassifieriFitted<pre>RandomForestClassifier(n_estimators=120)</pre> <p>And now we've got the best cross-validated model, we can fit and score it on our original single train/test split of the data.</p> In\u00a0[22]: Copied! <pre># Fit the best model\nclf = clf.fit(X_train, y_train)\n\n# Find the best model scores on our single test split\n# (note: this may be lower than the cross-validation score since it's only on one split of the data)\nprint(f\"Best model score on single split of the data: {clf.score(X_test, y_test)*100:.2f}%\")\n</pre> # Fit the best model clf = clf.fit(X_train, y_train)  # Find the best model scores on our single test split # (note: this may be lower than the cross-validation score since it's only on one split of the data) print(f\"Best model score on single split of the data: {clf.score(X_test, y_test)*100:.2f}%\") <pre>Best model score on single split of the data: 85.53%\n</pre> In\u00a0[23]: Copied! <pre>import pickle\n\n# Save an existing model to file\npickle.dump(model, open(\"random_forest_model_1.pkl\", \"wb\"))\n</pre> import pickle  # Save an existing model to file pickle.dump(model, open(\"random_forest_model_1.pkl\", \"wb\")) In\u00a0[24]: Copied! <pre># Load a saved pickle model and evaluate it\nloaded_pickle_model = pickle.load(open(\"random_forest_model_1.pkl\", \"rb\"))\nprint(f\"Loaded pickle model prediction score: {loaded_pickle_model.score(X_test, y_test) * 100:.2f}%\")\n</pre> # Load a saved pickle model and evaluate it loaded_pickle_model = pickle.load(open(\"random_forest_model_1.pkl\", \"rb\")) print(f\"Loaded pickle model prediction score: {loaded_pickle_model.score(X_test, y_test) * 100:.2f}%\") <pre>Loaded pickle model prediction score: 88.16%\n</pre> <p>For larger models, it may be more efficient to use Joblib.</p> In\u00a0[25]: Copied! <pre>from joblib import dump, load\n\n# Save a model using joblib\ndump(model, \"random_forest_model_1.joblib\")\n</pre> from joblib import dump, load  # Save a model using joblib dump(model, \"random_forest_model_1.joblib\") Out[25]: <pre>['random_forest_model_1.joblib']</pre> In\u00a0[26]: Copied! <pre># Load a saved joblib model and evaluate it\nloaded_joblib_model = load(\"random_forest_model_1.joblib\")\nprint(f\"Loaded joblib model prediction score: {loaded_joblib_model.score(X_test, y_test) * 100:.2f}%\")\n</pre> # Load a saved joblib model and evaluate it loaded_joblib_model = load(\"random_forest_model_1.joblib\") print(f\"Loaded joblib model prediction score: {loaded_joblib_model.score(X_test, y_test) * 100:.2f}%\") <pre>Loaded joblib model prediction score: 88.16%\n</pre> <p>Woah!</p> <p>We've covered a lot of ground fast...</p> <p>Let's break things down a bit more by revisting each section.</p> In\u00a0[27]: Copied! <pre># Splitting the data into X &amp; y\nheart_disease.head()\n</pre> # Splitting the data into X &amp; y heart_disease.head() Out[27]: age sex cp trestbps chol fbs restecg thalach exang oldpeak slope ca thal target 0 63 1 3 145 233 1 0 150 0 2.3 0 0 1 1 1 37 1 2 130 250 0 1 187 0 3.5 0 0 2 1 2 41 0 1 130 204 0 0 172 0 1.4 2 0 2 1 3 56 1 1 120 236 0 1 178 0 0.8 2 0 2 1 4 57 0 0 120 354 0 1 163 1 0.6 2 0 2 1 In\u00a0[28]: Copied! <pre># Splitting the data into features (X) and labels (y)\nX = heart_disease.drop('target', axis=1)\nX\n</pre> # Splitting the data into features (X) and labels (y) X = heart_disease.drop('target', axis=1) X Out[28]: age sex cp trestbps chol fbs restecg thalach exang oldpeak slope ca thal 0 63 1 3 145 233 1 0 150 0 2.3 0 0 1 1 37 1 2 130 250 0 1 187 0 3.5 0 0 2 2 41 0 1 130 204 0 0 172 0 1.4 2 0 2 3 56 1 1 120 236 0 1 178 0 0.8 2 0 2 4 57 0 0 120 354 0 1 163 1 0.6 2 0 2 ... ... ... ... ... ... ... ... ... ... ... ... ... ... 298 57 0 0 140 241 0 1 123 1 0.2 1 0 3 299 45 1 3 110 264 0 1 132 0 1.2 1 0 3 300 68 1 0 144 193 1 1 141 0 3.4 1 2 3 301 57 1 0 130 131 0 1 115 1 1.2 1 1 3 302 57 0 1 130 236 0 0 174 0 0.0 1 1 2 <p>303 rows \u00d7 13 columns</p> <p>Nice! Looks like our dataset has 303 samples with 13 features (13 columns).</p> <p>Let's check out the labels.</p> In\u00a0[29]: Copied! <pre>y = heart_disease['target']\ny\n</pre> y = heart_disease['target'] y Out[29]: <pre>0      1\n1      1\n2      1\n3      1\n4      1\n      ..\n298    0\n299    0\n300    0\n301    0\n302    0\nName: target, Length: 303, dtype: int64</pre> <p>Beautiful, 303 labels with values of <code>0</code> (no heart disease) and <code>1</code> (heart disease).</p> <p>Now let's split our data into training and test sets, we'll use an 80/20 split (80% of samples for training and 20% of samples for testing).</p> In\u00a0[30]: Copied! <pre># Splitting the data into training and test sets\nfrom sklearn.model_selection import train_test_split\nX_train, X_test, y_train, y_test = train_test_split(X, \n                                                    y, \n                                                    test_size=0.2) # you can change the test size\n\n# Check the shapes of different data splits\nX_train.shape, X_test.shape, y_train.shape, y_test.shape\n</pre> # Splitting the data into training and test sets from sklearn.model_selection import train_test_split X_train, X_test, y_train, y_test = train_test_split(X,                                                      y,                                                      test_size=0.2) # you can change the test size  # Check the shapes of different data splits X_train.shape, X_test.shape, y_train.shape, y_test.shape Out[30]: <pre>((242, 13), (61, 13), (242,), (61,))</pre> In\u00a0[31]: Copied! <pre># 80% of data is being used for the training set (the model will learn patterns on these samples)\nX.shape[0] * 0.8\n</pre> # 80% of data is being used for the training set (the model will learn patterns on these samples) X.shape[0] * 0.8 Out[31]: <pre>242.4</pre> In\u00a0[32]: Copied! <pre># And 20% of the data is being used for the testing set (the model will be evaluated on these samples)\nX.shape[0] * 0.2\n</pre> # And 20% of the data is being used for the testing set (the model will be evaluated on these samples) X.shape[0] * 0.2 Out[32]: <pre>60.6</pre> In\u00a0[33]: Copied! <pre># Import car-sales-extended.csv\n# car_sales = pd.read_csv(\"../data/car-sales-extended.csv\") # load data from local directory \ncar_sales = pd.read_csv(\"https://raw.githubusercontent.com/mrdbourke/zero-to-mastery-ml/master/data/car-sales-extended.csv\") # load data directly from raw URL (source: https://github.com/mrdbourke/zero-to-mastery-ml/blob/master/data/car-sales-extended.csv)\ncar_sales\n</pre> # Import car-sales-extended.csv # car_sales = pd.read_csv(\"../data/car-sales-extended.csv\") # load data from local directory  car_sales = pd.read_csv(\"https://raw.githubusercontent.com/mrdbourke/zero-to-mastery-ml/master/data/car-sales-extended.csv\") # load data directly from raw URL (source: https://github.com/mrdbourke/zero-to-mastery-ml/blob/master/data/car-sales-extended.csv) car_sales Out[33]: Make Colour Odometer (KM) Doors Price 0 Honda White 35431 4 15323 1 BMW Blue 192714 5 19943 2 Honda White 84714 4 28343 3 Toyota White 154365 4 13434 4 Nissan Blue 181577 3 14043 ... ... ... ... ... ... 995 Toyota Black 35820 4 32042 996 Nissan White 155144 3 5716 997 Nissan Blue 66604 4 31570 998 Honda White 215883 4 4001 999 Toyota Blue 248360 4 12732 <p>1000 rows \u00d7 5 columns</p> <p>We can check the dataset types with <code>.dtypes</code>.</p> In\u00a0[34]: Copied! <pre>car_sales.dtypes\n</pre> car_sales.dtypes Out[34]: <pre>Make             object\nColour           object\nOdometer (KM)     int64\nDoors             int64\nPrice             int64\ndtype: object</pre> <p>Notice the <code>Make</code> and <code>Colour</code> features are of <code>dtype=object</code> (they're strings) where as the rest of the columns are of <code>dtype=int64</code>.</p> <p>If we want to use the <code>Make</code> and <code>Colour</code> features in our model, we'll need to figure out how to turn them into numerical form.</p> In\u00a0[35]: Copied! <pre># Split into X &amp; y and train/test\nX = car_sales.drop(\"Price\", axis=1)\ny = car_sales[\"Price\"]\n\nX_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2)\n</pre> # Split into X &amp; y and train/test X = car_sales.drop(\"Price\", axis=1) y = car_sales[\"Price\"]  X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2) <p>Now let's try and build a model on our <code>car_sales</code> data.</p> In\u00a0[36]: Copied! <pre># Try to predict with random forest on price column (doesn't work)\nfrom sklearn.ensemble import RandomForestRegressor\n\nmodel = RandomForestRegressor()\nmodel.fit(X_train, y_train)\nmodel.score(X_test, y_test)\n</pre> # Try to predict with random forest on price column (doesn't work) from sklearn.ensemble import RandomForestRegressor  model = RandomForestRegressor() model.fit(X_train, y_train) model.score(X_test, y_test) <pre>\n---------------------------------------------------------------------------\nValueError                                Traceback (most recent call last)\n/var/folders/c4/qj4gdk190td18bqvjjh0p3p00000gn/T/ipykernel_23180/1044518071.py in ?()\n      1 # Try to predict with random forest on price column (doesn't work)\n      2 from sklearn.ensemble import RandomForestRegressor\n      3 \n      4 model = RandomForestRegressor()\n----&gt; 5 model.fit(X_train, y_train)\n      6 model.score(X_test, y_test)\n\n~/miniforge3/envs/ai/lib/python3.11/site-packages/sklearn/base.py in ?(estimator, *args, **kwargs)\n   1469                 skip_parameter_validation=(\n   1470                     prefer_skip_nested_validation or global_skip_validation\n   1471                 )\n   1472             ):\n-&gt; 1473                 return fit_method(estimator, *args, **kwargs)\n\n~/miniforge3/envs/ai/lib/python3.11/site-packages/sklearn/ensemble/_forest.py in ?(self, X, y, sample_weight)\n    359         # Validate or convert input data\n    360         if issparse(y):\n    361             raise ValueError(\"sparse multilabel-indicator for y is not supported.\")\n    362 \n--&gt; 363         X, y = self._validate_data(\n    364             X,\n    365             y,\n    366             multi_output=True,\n\n~/miniforge3/envs/ai/lib/python3.11/site-packages/sklearn/base.py in ?(self, X, y, reset, validate_separately, cast_to_ndarray, **check_params)\n    646                 if \"estimator\" not in check_y_params:\n    647                     check_y_params = {**default_check_params, **check_y_params}\n    648                 y = check_array(y, input_name=\"y\", **check_y_params)\n    649             else:\n--&gt; 650                 X, y = check_X_y(X, y, **check_params)\n    651             out = X, y\n    652 \n    653         if not no_val_X and check_params.get(\"ensure_2d\", True):\n\n~/miniforge3/envs/ai/lib/python3.11/site-packages/sklearn/utils/validation.py in ?(X, y, accept_sparse, accept_large_sparse, dtype, order, copy, force_writeable, force_all_finite, ensure_2d, allow_nd, multi_output, ensure_min_samples, ensure_min_features, y_numeric, estimator)\n   1297         raise ValueError(\n   1298             f\"{estimator_name} requires y to be passed, but the target y is None\"\n   1299         )\n   1300 \n-&gt; 1301     X = check_array(\n   1302         X,\n   1303         accept_sparse=accept_sparse,\n   1304         accept_large_sparse=accept_large_sparse,\n\n~/miniforge3/envs/ai/lib/python3.11/site-packages/sklearn/utils/validation.py in ?(array, accept_sparse, accept_large_sparse, dtype, order, copy, force_writeable, force_all_finite, ensure_2d, allow_nd, ensure_min_samples, ensure_min_features, estimator, input_name)\n   1009                         )\n   1010                     array = xp.astype(array, dtype, copy=False)\n   1011                 else:\n   1012                     array = _asarray_with_order(array, order=order, dtype=dtype, xp=xp)\n-&gt; 1013             except ComplexWarning as complex_warning:\n   1014                 raise ValueError(\n   1015                     \"Complex data not supported\\n{}\\n\".format(array)\n   1016                 ) from complex_warning\n\n~/miniforge3/envs/ai/lib/python3.11/site-packages/sklearn/utils/_array_api.py in ?(array, dtype, order, copy, xp, device)\n    747         # Use NumPy API to support order\n    748         if copy is True:\n    749             array = numpy.array(array, order=order, dtype=dtype)\n    750         else:\n--&gt; 751             array = numpy.asarray(array, order=order, dtype=dtype)\n    752 \n    753         # At this point array is a NumPy ndarray. We convert it to an array\n    754         # container that is consistent with the input's namespace.\n\n~/miniforge3/envs/ai/lib/python3.11/site-packages/pandas/core/generic.py in ?(self, dtype, copy)\n   2149     def __array__(\n   2150         self, dtype: npt.DTypeLike | None = None, copy: bool_t | None = None\n   2151     ) -&gt; np.ndarray:\n   2152         values = self._values\n-&gt; 2153         arr = np.asarray(values, dtype=dtype)\n   2154         if (\n   2155             astype_is_view(values.dtype, arr.dtype)\n   2156             and using_copy_on_write()\n\nValueError: could not convert string to float: 'Honda'</pre> <p>Oh no! We get a another <code>ValueError</code> (some of data is in string format rather than numerical format).</p> <pre><code>ValueError: could not convert string to float: 'Honda'\n</code></pre> <p>Machine learning models prefer to work with numbers than text.</p> <p>So we'll have to convert the non-numerical features into numbers first.</p> <p>The process of turning categorical features into numbers is often referred to as encoding.</p> <p>Scikit-Learn has a fantastic in-depth guide on Encoding categorical features.</p> <p>But let's look at one of the most straightforward ways to turn categorical features into numbers, one-hot encoding.</p> <p>In machine learning, one-hot encoding gives a value of <code>1</code> to the target value and a value of <code>0</code> to the other values.</p> <p>For example, let's say we had five samples and three car make options, Honda, Toyota, BMW.</p> <p>And our samples were:</p> <ol> <li>Honda</li> <li>BMW</li> <li>BMW</li> <li>Toyota</li> <li>Toyota</li> </ol> <p>If we were to one-hot encode these, it would look like:</p> Sample Honda Toyota BMW 1 1 0 0 2 0 0 1 3 0 0 1 4 0 1 0 5 0 1 0 <p>Notice how there's a 1 for each target value but a 0 for each other value.</p> <p>We can use the following steps to one-hot encode our dataset:</p> <ol> <li>Import <code>sklearn.preprocessing.OneHotEncoder</code> to one-hot encode our features and <code>sklearn.compose.ColumnTransformer</code> to target the specific columns of our DataFrame to transform.</li> <li>Define the categorical features we'd like to transform.</li> <li>Create an instance of the <code>OneHotEncoder</code>.</li> <li>Create an instance of <code>ColumnTransformer</code> and feed it the transforms we'd like to make.</li> <li>Fit the instance of the <code>ColumnTransformer</code> to our data and transform it with the <code>fit_transform(X)</code> method.</li> </ol> <p>Note: In Scikit-Learn, the term \"transformer\" is often used to refer to something that transforms data.</p> In\u00a0[37]: Copied! <pre># 1. Import OneHotEncoder and ColumnTransformer\nfrom sklearn.preprocessing import OneHotEncoder\nfrom sklearn.compose import ColumnTransformer\n\n# 2. Define the categorical features to transform\ncategorical_features = [\"Make\", \"Colour\", \"Doors\"]\n\n# 3. Create an instance of OneHotEncoder\none_hot = OneHotEncoder()\n\n# 4. Create an instance of ColumnTransformer\ntransformer = ColumnTransformer([(\"one_hot\", # name\n                                  one_hot, # transformer\n                                  categorical_features)], # columns to transform\n                                  remainder=\"passthrough\") # what to do with the rest of the columns? (\"passthrough\" = leave unchanged) \n\n# 5. Turn the categorical features into numbers (this will return an array-like sparse matrix, not a DataFrame)\ntransformed_X = transformer.fit_transform(X)\ntransformed_X\n</pre> # 1. Import OneHotEncoder and ColumnTransformer from sklearn.preprocessing import OneHotEncoder from sklearn.compose import ColumnTransformer  # 2. Define the categorical features to transform categorical_features = [\"Make\", \"Colour\", \"Doors\"]  # 3. Create an instance of OneHotEncoder one_hot = OneHotEncoder()  # 4. Create an instance of ColumnTransformer transformer = ColumnTransformer([(\"one_hot\", # name                                   one_hot, # transformer                                   categorical_features)], # columns to transform                                   remainder=\"passthrough\") # what to do with the rest of the columns? (\"passthrough\" = leave unchanged)   # 5. Turn the categorical features into numbers (this will return an array-like sparse matrix, not a DataFrame) transformed_X = transformer.fit_transform(X) transformed_X Out[37]: <pre>array([[0.00000e+00, 1.00000e+00, 0.00000e+00, ..., 1.00000e+00,\n        0.00000e+00, 3.54310e+04],\n       [1.00000e+00, 0.00000e+00, 0.00000e+00, ..., 0.00000e+00,\n        1.00000e+00, 1.92714e+05],\n       [0.00000e+00, 1.00000e+00, 0.00000e+00, ..., 1.00000e+00,\n        0.00000e+00, 8.47140e+04],\n       ...,\n       [0.00000e+00, 0.00000e+00, 1.00000e+00, ..., 1.00000e+00,\n        0.00000e+00, 6.66040e+04],\n       [0.00000e+00, 1.00000e+00, 0.00000e+00, ..., 1.00000e+00,\n        0.00000e+00, 2.15883e+05],\n       [0.00000e+00, 0.00000e+00, 0.00000e+00, ..., 1.00000e+00,\n        0.00000e+00, 2.48360e+05]])</pre> <p>Note: You might be thinking why we considered <code>Doors</code> as a categorical variable. Which is a good question considering <code>Doors</code> is already numerical. Well, the answer is that <code>Doors</code> could be either numerical or categorical. However, I've decided to go with categorical, since where I'm from, number of doors is often a different category of car. For example, you can shop for 4-door cars or shop for 5-door cars (which always confused me since where's the 5th door?). However, you could experiment with treating this value as numerical or categorical, training a model on each, and then see how each model performs.</p> <p>Woah! Looks like our samples are all numerical, what did our data look like previously?</p> In\u00a0[38]: Copied! <pre>X.head()\n</pre> X.head() Out[38]: Make Colour Odometer (KM) Doors 0 Honda White 35431 4 1 BMW Blue 192714 5 2 Honda White 84714 4 3 Toyota White 154365 4 4 Nissan Blue 181577 3 <p>It seems <code>OneHotEncoder</code> and <code>ColumnTransformer</code> have turned all of our data samples into numbers.</p> <p>Let's check out the first transformed sample.</p> In\u00a0[39]: Copied! <pre># View first transformed sample\ntransformed_X[0]\n</pre> # View first transformed sample transformed_X[0] Out[39]: <pre>array([0.0000e+00, 1.0000e+00, 0.0000e+00, 0.0000e+00, 0.0000e+00,\n       0.0000e+00, 0.0000e+00, 0.0000e+00, 1.0000e+00, 0.0000e+00,\n       1.0000e+00, 0.0000e+00, 3.5431e+04])</pre> <p>And what were these values originally?</p> In\u00a0[40]: Copied! <pre># View original first sample\nX.iloc[0]\n</pre> # View original first sample X.iloc[0] Out[40]: <pre>Make             Honda\nColour           White\nOdometer (KM)    35431\nDoors                4\nName: 0, dtype: object</pre> In\u00a0[41]: Copied! <pre># View head of original DataFrame\ncar_sales.head()\n</pre> # View head of original DataFrame car_sales.head() Out[41]: Make Colour Odometer (KM) Doors Price 0 Honda White 35431 4 15323 1 BMW Blue 192714 5 19943 2 Honda White 84714 4 28343 3 Toyota White 154365 4 13434 4 Nissan Blue 181577 3 14043 <p>Wonderful, now let's use <code>pd.get_dummies()</code> to turn our categorical variables into one-hot encoded variables.</p> In\u00a0[42]: Copied! <pre># One-hot encode categorical variables\ncategorical_variables = [\"Make\", \"Colour\", \"Doors\"]\ndummies = pd.get_dummies(data=car_sales[categorical_variables])\ndummies\n</pre> # One-hot encode categorical variables categorical_variables = [\"Make\", \"Colour\", \"Doors\"] dummies = pd.get_dummies(data=car_sales[categorical_variables]) dummies Out[42]: Doors Make_BMW Make_Honda Make_Nissan Make_Toyota Colour_Black Colour_Blue Colour_Green Colour_Red Colour_White 0 4 False True False False False False False False True 1 5 True False False False False True False False False 2 4 False True False False False False False False True 3 4 False False False True False False False False True 4 3 False False True False False True False False False ... ... ... ... ... ... ... ... ... ... ... 995 4 False False False True True False False False False 996 3 False False True False False False False False True 997 4 False False True False False True False False False 998 4 False True False False False False False False True 999 4 False False False True False True False False False <p>1000 rows \u00d7 10 columns</p> <p>Nice!</p> <p>Notice how there's a new column for each categorical option (e.g. <code>Make_BMW</code>, <code>Make_Honda</code>, etc).</p> <p>But also notice how it also missed the <code>Doors</code> column?</p> <p>This is because <code>Doors</code> is already numeric, so for <code>pd.get_dummies()</code> to work on it, we can change it to type <code>object</code>.</p> <p>By default, <code>pd.get_dummies()</code> also turns all of the values to bools (<code>True</code> or <code>False</code>).</p> <p>We can get the returned values as <code>0</code> or <code>1</code> by setting <code>dtype=float</code>.</p> In\u00a0[43]: Copied! <pre># Have to convert doors to object for dummies to work on it...\ncar_sales[\"Doors\"] = car_sales[\"Doors\"].astype(object)\ndummies = pd.get_dummies(data=car_sales[[\"Make\", \"Colour\", \"Doors\"]],\n                         dtype=float)\ndummies\n</pre> # Have to convert doors to object for dummies to work on it... car_sales[\"Doors\"] = car_sales[\"Doors\"].astype(object) dummies = pd.get_dummies(data=car_sales[[\"Make\", \"Colour\", \"Doors\"]],                          dtype=float) dummies Out[43]: Make_BMW Make_Honda Make_Nissan Make_Toyota Colour_Black Colour_Blue Colour_Green Colour_Red Colour_White Doors_3 Doors_4 Doors_5 0 0.0 1.0 0.0 0.0 0.0 0.0 0.0 0.0 1.0 0.0 1.0 0.0 1 1.0 0.0 0.0 0.0 0.0 1.0 0.0 0.0 0.0 0.0 0.0 1.0 2 0.0 1.0 0.0 0.0 0.0 0.0 0.0 0.0 1.0 0.0 1.0 0.0 3 0.0 0.0 0.0 1.0 0.0 0.0 0.0 0.0 1.0 0.0 1.0 0.0 4 0.0 0.0 1.0 0.0 0.0 1.0 0.0 0.0 0.0 1.0 0.0 0.0 ... ... ... ... ... ... ... ... ... ... ... ... ... 995 0.0 0.0 0.0 1.0 1.0 0.0 0.0 0.0 0.0 0.0 1.0 0.0 996 0.0 0.0 1.0 0.0 0.0 0.0 0.0 0.0 1.0 1.0 0.0 0.0 997 0.0 0.0 1.0 0.0 0.0 1.0 0.0 0.0 0.0 0.0 1.0 0.0 998 0.0 1.0 0.0 0.0 0.0 0.0 0.0 0.0 1.0 0.0 1.0 0.0 999 0.0 0.0 0.0 1.0 0.0 1.0 0.0 0.0 0.0 0.0 1.0 0.0 <p>1000 rows \u00d7 12 columns</p> <p>Woohoo!</p> <p>We've now turned our data into fully numeric form using Scikit-Learn and pandas.</p> <p>Now you might be wondering...</p> <p>Should you use Scikit-Learn or pandas for turning data into numerical form?</p> <p>And the answer is either.</p> <p>But as a rule of thumb:</p> <ul> <li>If you're performing quick data analysis and running small modelling experiments, use <code>pandas</code> as it's generally quite fast to get up and running.</li> <li>If you're performing a larger scale modelling experiment or would like to put your data processing steps into a production pipeline, I'd recommend leaning towards Scikit-Learn, specifically a Scikit-Learn Pipeline (chaining together multiple estimator/modelling steps).</li> </ul> <p>Since we've turned our data into numerical form, how about we try and fit our model again?</p> <p>Let's recreate a train/test split except this time we'll use <code>transformed_X</code> instead of <code>X</code>.</p> In\u00a0[44]: Copied! <pre>np.random.seed(42)\n\n# Create train and test splits with transformed_X\nX_train, X_test, y_train, y_test = train_test_split(transformed_X,\n                                                    y,\n                                                    test_size=0.2)\n\n# Create the model instance\nmodel = RandomForestRegressor()\n\n# Fit the model on the numerical data (this errored before since our data wasn't fully numeric)\nmodel.fit(X_train, y_train)\n\n# Score the model (returns r^2 metric by default, also called coefficient of determination, higher is better)\nmodel.score(X_test, y_test)\n</pre> np.random.seed(42)  # Create train and test splits with transformed_X X_train, X_test, y_train, y_test = train_test_split(transformed_X,                                                     y,                                                     test_size=0.2)  # Create the model instance model = RandomForestRegressor()  # Fit the model on the numerical data (this errored before since our data wasn't fully numeric) model.fit(X_train, y_train)  # Score the model (returns r^2 metric by default, also called coefficient of determination, higher is better) model.score(X_test, y_test) Out[44]: <pre>0.3235867221569877</pre> In\u00a0[47]: Copied! <pre># Import car sales dataframe with missing values\n# car_sales_missing = pd.read_csv(\"../data/car-sales-extended-missing-data.csv\") # load from local directory\ncar_sales_missing = pd.read_csv(\"https://raw.githubusercontent.com/mrdbourke/zero-to-mastery-ml/master/data/car-sales-extended-missing-data.csv\") # read directly from URL (source: https://github.com/mrdbourke/zero-to-mastery-ml/blob/master/data/car-sales-extended-missing-data.csv)\ncar_sales_missing.head(10)\n</pre> # Import car sales dataframe with missing values # car_sales_missing = pd.read_csv(\"../data/car-sales-extended-missing-data.csv\") # load from local directory car_sales_missing = pd.read_csv(\"https://raw.githubusercontent.com/mrdbourke/zero-to-mastery-ml/master/data/car-sales-extended-missing-data.csv\") # read directly from URL (source: https://github.com/mrdbourke/zero-to-mastery-ml/blob/master/data/car-sales-extended-missing-data.csv) car_sales_missing.head(10) Out[47]: Make Colour Odometer (KM) Doors Price 0 Honda White 35431.0 4.0 15323.0 1 BMW Blue 192714.0 5.0 19943.0 2 Honda White 84714.0 4.0 28343.0 3 Toyota White 154365.0 4.0 13434.0 4 Nissan Blue 181577.0 3.0 14043.0 5 Honda Red 42652.0 4.0 23883.0 6 Toyota Blue 163453.0 4.0 8473.0 7 Honda White NaN 4.0 20306.0 8 NaN White 130538.0 4.0 9374.0 9 Honda Blue 51029.0 4.0 26683.0 <p>Notice the <code>NaN</code> value in row 7 for the <code>Odometer (KM)</code> column, that means pandas has detected a missing value there.</p> <p>However, if you're dataset is large, it's likely you aren't going to go through it sample by sample to find the missing values.</p> <p>Luckily, pandas has a method called <code>pd.DataFrame.isna()</code> which is able to detect missing values.</p> <p>Let's try it on our DataFrame.</p> In\u00a0[48]: Copied! <pre># Get the sum of all missing values\ncar_sales_missing.isna().sum()\n</pre> # Get the sum of all missing values car_sales_missing.isna().sum() Out[48]: <pre>Make             49\nColour           50\nOdometer (KM)    50\nDoors            50\nPrice            50\ndtype: int64</pre> <p>Hmm... seems there's about 50 or so missing values per column.</p> <p>How about we try and split the data into features and labels, then convert the categorical data to numbers, then split the data into training and test and then try and fit a model on it (just like we did before)?</p> In\u00a0[49]: Copied! <pre># Create features\nX_missing = car_sales_missing.drop(\"Price\", axis=1)\nprint(f\"Number of missing X values:\\n{X_missing.isna().sum()}\")\n</pre> # Create features X_missing = car_sales_missing.drop(\"Price\", axis=1) print(f\"Number of missing X values:\\n{X_missing.isna().sum()}\") <pre>Number of missing X values:\nMake             49\nColour           50\nOdometer (KM)    50\nDoors            50\ndtype: int64\n</pre> In\u00a0[50]: Copied! <pre># Create labels\ny_missing = car_sales_missing[\"Price\"]\nprint(f\"Number of missing y values: {y_missing.isna().sum()}\")\n</pre> # Create labels y_missing = car_sales_missing[\"Price\"] print(f\"Number of missing y values: {y_missing.isna().sum()}\") <pre>Number of missing y values: 50\n</pre> <p>Now we can convert the categorical columns into one-hot encodings (just as before).</p> In\u00a0[51]: Copied! <pre># Let's convert the categorical columns to one hot encoded (code copied from above)\n# Turn the categories (Make and Colour) into numbers\nfrom sklearn.preprocessing import OneHotEncoder\nfrom sklearn.compose import ColumnTransformer\n\ncategorical_features = [\"Make\", \"Colour\", \"Doors\"]\n\none_hot = OneHotEncoder()\n\ntransformer = ColumnTransformer([(\"one_hot\", \n                                  one_hot, \n                                  categorical_features)],\n                                remainder=\"passthrough\",\n                                sparse_threshold=0) # return a sparse matrix or not\n\ntransformed_X_missing = transformer.fit_transform(X_missing)\ntransformed_X_missing\n</pre> # Let's convert the categorical columns to one hot encoded (code copied from above) # Turn the categories (Make and Colour) into numbers from sklearn.preprocessing import OneHotEncoder from sklearn.compose import ColumnTransformer  categorical_features = [\"Make\", \"Colour\", \"Doors\"]  one_hot = OneHotEncoder()  transformer = ColumnTransformer([(\"one_hot\",                                    one_hot,                                    categorical_features)],                                 remainder=\"passthrough\",                                 sparse_threshold=0) # return a sparse matrix or not  transformed_X_missing = transformer.fit_transform(X_missing) transformed_X_missing Out[51]: <pre>array([[0.00000e+00, 1.00000e+00, 0.00000e+00, ..., 0.00000e+00,\n        0.00000e+00, 3.54310e+04],\n       [1.00000e+00, 0.00000e+00, 0.00000e+00, ..., 1.00000e+00,\n        0.00000e+00, 1.92714e+05],\n       [0.00000e+00, 1.00000e+00, 0.00000e+00, ..., 0.00000e+00,\n        0.00000e+00, 8.47140e+04],\n       ...,\n       [0.00000e+00, 0.00000e+00, 1.00000e+00, ..., 0.00000e+00,\n        0.00000e+00, 6.66040e+04],\n       [0.00000e+00, 1.00000e+00, 0.00000e+00, ..., 0.00000e+00,\n        0.00000e+00, 2.15883e+05],\n       [0.00000e+00, 0.00000e+00, 0.00000e+00, ..., 0.00000e+00,\n        0.00000e+00, 2.48360e+05]])</pre> <p>Finally, let's split the missing data samples into train and test sets and then try to fit and score a model on them.</p> In\u00a0[52]: Copied! <pre># Split data into training and test sets\nX_train, X_test, y_train, y_test = train_test_split(transformed_X_missing,\n                                                    y_missing,\n                                                    test_size=0.2)\n\n# Fit and score a model\nmodel = RandomForestRegressor()\nmodel.fit(X_train, y_train)\nmodel.score(X_test, y_test)\n</pre> # Split data into training and test sets X_train, X_test, y_train, y_test = train_test_split(transformed_X_missing,                                                     y_missing,                                                     test_size=0.2)  # Fit and score a model model = RandomForestRegressor() model.fit(X_train, y_train) model.score(X_test, y_test) <pre>\n---------------------------------------------------------------------------\nValueError                                Traceback (most recent call last)\nCell In[52], line 8\n      6 # Fit and score a model\n      7 model = RandomForestRegressor()\n----&gt; 8 model.fit(X_train, y_train)\n      9 model.score(X_test, y_test)\n\nFile ~/miniforge3/envs/ai/lib/python3.11/site-packages/sklearn/base.py:1473, in _fit_context.&lt;locals&gt;.decorator.&lt;locals&gt;.wrapper(estimator, *args, **kwargs)\n   1466     estimator._validate_params()\n   1468 with config_context(\n   1469     skip_parameter_validation=(\n   1470         prefer_skip_nested_validation or global_skip_validation\n   1471     )\n   1472 ):\n-&gt; 1473     return fit_method(estimator, *args, **kwargs)\n\nFile ~/miniforge3/envs/ai/lib/python3.11/site-packages/sklearn/ensemble/_forest.py:363, in BaseForest.fit(self, X, y, sample_weight)\n    360 if issparse(y):\n    361     raise ValueError(\"sparse multilabel-indicator for y is not supported.\")\n--&gt; 363 X, y = self._validate_data(\n    364     X,\n    365     y,\n    366     multi_output=True,\n    367     accept_sparse=\"csc\",\n    368     dtype=DTYPE,\n    369     force_all_finite=False,\n    370 )\n    371 # _compute_missing_values_in_feature_mask checks if X has missing values and\n    372 # will raise an error if the underlying tree base estimator can't handle missing\n    373 # values. Only the criterion is required to determine if the tree supports\n    374 # missing values.\n    375 estimator = type(self.estimator)(criterion=self.criterion)\n\nFile ~/miniforge3/envs/ai/lib/python3.11/site-packages/sklearn/base.py:650, in BaseEstimator._validate_data(self, X, y, reset, validate_separately, cast_to_ndarray, **check_params)\n    648         y = check_array(y, input_name=\"y\", **check_y_params)\n    649     else:\n--&gt; 650         X, y = check_X_y(X, y, **check_params)\n    651     out = X, y\n    653 if not no_val_X and check_params.get(\"ensure_2d\", True):\n\nFile ~/miniforge3/envs/ai/lib/python3.11/site-packages/sklearn/utils/validation.py:1318, in check_X_y(X, y, accept_sparse, accept_large_sparse, dtype, order, copy, force_writeable, force_all_finite, ensure_2d, allow_nd, multi_output, ensure_min_samples, ensure_min_features, y_numeric, estimator)\n   1297     raise ValueError(\n   1298         f\"{estimator_name} requires y to be passed, but the target y is None\"\n   1299     )\n   1301 X = check_array(\n   1302     X,\n   1303     accept_sparse=accept_sparse,\n   (...)\n   1315     input_name=\"X\",\n   1316 )\n-&gt; 1318 y = _check_y(y, multi_output=multi_output, y_numeric=y_numeric, estimator=estimator)\n   1320 check_consistent_length(X, y)\n   1322 return X, y\n\nFile ~/miniforge3/envs/ai/lib/python3.11/site-packages/sklearn/utils/validation.py:1328, in _check_y(y, multi_output, y_numeric, estimator)\n   1326 \"\"\"Isolated part of check_X_y dedicated to y validation\"\"\"\n   1327 if multi_output:\n-&gt; 1328     y = check_array(\n   1329         y,\n   1330         accept_sparse=\"csr\",\n   1331         force_all_finite=True,\n   1332         ensure_2d=False,\n   1333         dtype=None,\n   1334         input_name=\"y\",\n   1335         estimator=estimator,\n   1336     )\n   1337 else:\n   1338     estimator_name = _check_estimator_name(estimator)\n\nFile ~/miniforge3/envs/ai/lib/python3.11/site-packages/sklearn/utils/validation.py:1064, in check_array(array, accept_sparse, accept_large_sparse, dtype, order, copy, force_writeable, force_all_finite, ensure_2d, allow_nd, ensure_min_samples, ensure_min_features, estimator, input_name)\n   1058     raise ValueError(\n   1059         \"Found array with dim %d. %s expected &lt;= 2.\"\n   1060         % (array.ndim, estimator_name)\n   1061     )\n   1063 if force_all_finite:\n-&gt; 1064     _assert_all_finite(\n   1065         array,\n   1066         input_name=input_name,\n   1067         estimator_name=estimator_name,\n   1068         allow_nan=force_all_finite == \"allow-nan\",\n   1069     )\n   1071 if copy:\n   1072     if _is_numpy_namespace(xp):\n   1073         # only make a copy if `array` and `array_orig` may share memory`\n\nFile ~/miniforge3/envs/ai/lib/python3.11/site-packages/sklearn/utils/validation.py:123, in _assert_all_finite(X, allow_nan, msg_dtype, estimator_name, input_name)\n    120 if first_pass_isfinite:\n    121     return\n--&gt; 123 _assert_all_finite_element_wise(\n    124     X,\n    125     xp=xp,\n    126     allow_nan=allow_nan,\n    127     msg_dtype=msg_dtype,\n    128     estimator_name=estimator_name,\n    129     input_name=input_name,\n    130 )\n\nFile ~/miniforge3/envs/ai/lib/python3.11/site-packages/sklearn/utils/validation.py:172, in _assert_all_finite_element_wise(X, xp, allow_nan, msg_dtype, estimator_name, input_name)\n    155 if estimator_name and input_name == \"X\" and has_nan_error:\n    156     # Improve the error message on how to handle missing values in\n    157     # scikit-learn.\n    158     msg_err += (\n    159         f\"\\n{estimator_name} does not accept missing values\"\n    160         \" encoded as NaN natively. For supervised learning, you might want\"\n   (...)\n    170         \"#estimators-that-handle-nan-values\"\n    171     )\n--&gt; 172 raise ValueError(msg_err)\n\nValueError: Input y contains NaN.</pre> <p>Ahh... dam! Another <code>ValueError</code> (our input data contains missing values).</p> <p><code>ValueError: Input y contains NaN.</code></p> <p>Looks like the model we're trying to use doesn't work with missing values.</p> <p>When we try to fit it on a dataset with missing samples, Scikit-Learn produces an error similar to:</p> <p><code>ValueError: Input X contains NaN. RandomForestRegressor does not accept missing values encoded as NaN natively...</code></p> <p>Looks like if we want to use <code>RandomForestRegressor</code>, we'll have to either fill or remove the missing values.</p> Note: Scikit-Learn does have a          list of models which can handle NaNs or missing values directly.      <p>Such as,          <code>sklearn.ensemble.HistGradientBoostingClassifier</code>          or          <code>sklearn.ensemble.HistGradientBoostingRegressor</code>.     </p> <p>As an experiment, you may want to try the following:</p> <pre><code>\nfrom sklearn.ensemble import HistGradientBoostingRegressor\n\n<p># Try a model that can handle NaNs natively\nnan_model = HistGradientBoostingRegressor()\nnan_model.fit(X_train, y_train)\nnan_model.score(X_test, y_test)\n</p></code></pre>  Let's see what values are missing again.    In\u00a0[53]: Copied! <pre>car_sales_missing.isna().sum()\n</pre> car_sales_missing.isna().sum() Out[53]: <pre>Make             49\nColour           50\nOdometer (KM)    50\nDoors            50\nPrice            50\ndtype: int64</pre> <p>How can fill (impute) or remove these?</p> In\u00a0[55]: Copied! <pre># Fill the missing values in the Make column\n# Note: In previous versions of pandas, inplace=True was possible, however this will be changed in a future version, can use reassignment instead.\n# car_sales_missing[\"Make\"].fillna(value=\"missing\", inplace=True)\n\ncar_sales_missing[\"Make\"] = car_sales_missing[\"Make\"].fillna(value=\"missing\")\n</pre> # Fill the missing values in the Make column # Note: In previous versions of pandas, inplace=True was possible, however this will be changed in a future version, can use reassignment instead. # car_sales_missing[\"Make\"].fillna(value=\"missing\", inplace=True)  car_sales_missing[\"Make\"] = car_sales_missing[\"Make\"].fillna(value=\"missing\") <p>And we can do the same with the <code>Colour</code> column.</p> In\u00a0[56]: Copied! <pre># Note: In previous versions of pandas, inplace=True was possible, however this will be changed in a future version, can use reassignment instead.\n# car_sales_missing[\"Colour\"].fillna(value=\"missing\", inplace=True)\n\n# Fill the Colour column\ncar_sales_missing[\"Colour\"] = car_sales_missing[\"Colour\"].fillna(value=\"missing\")\n</pre> # Note: In previous versions of pandas, inplace=True was possible, however this will be changed in a future version, can use reassignment instead. # car_sales_missing[\"Colour\"].fillna(value=\"missing\", inplace=True)  # Fill the Colour column car_sales_missing[\"Colour\"] = car_sales_missing[\"Colour\"].fillna(value=\"missing\") <p>How many missing values do we have now?</p> In\u00a0[57]: Copied! <pre>car_sales_missing.isna().sum()\n</pre> car_sales_missing.isna().sum() Out[57]: <pre>Make              0\nColour            0\nOdometer (KM)    50\nDoors            50\nPrice            50\ndtype: int64</pre> <p>Wonderful! We're making some progress.</p> <p>Now let's fill the <code>Doors</code> column with <code>4</code> (the most common value), this is the same as filling it with the median or mode of the <code>Doors</code> column.</p> In\u00a0[58]: Copied! <pre># Find the most common value of the Doors column\ncar_sales_missing[\"Doors\"].value_counts()\n</pre> # Find the most common value of the Doors column car_sales_missing[\"Doors\"].value_counts() Out[58]: <pre>Doors\n4.0    811\n5.0     75\n3.0     64\nName: count, dtype: int64</pre> In\u00a0[59]: Copied! <pre># Fill the Doors column with the most common value\ncar_sales_missing[\"Doors\"] = car_sales_missing[\"Doors\"].fillna(value=4)\n</pre> # Fill the Doors column with the most common value car_sales_missing[\"Doors\"] = car_sales_missing[\"Doors\"].fillna(value=4) <p>Next, we'll fill the <code>Odometer (KM)</code> column with the mean value of itself.</p> In\u00a0[60]: Copied! <pre># Fill the Odometer (KM) column\n# Old: car_sales_missing[\"Odometer (KM)\"].fillna(value=car_sales_missing[\"Odometer (KM)\"].mean(), inplace=True)\n\ncar_sales_missing[\"Odometer (KM)\"] = car_sales_missing[\"Odometer (KM)\"].fillna(value=car_sales_missing[\"Odometer (KM)\"].mean())\n</pre> # Fill the Odometer (KM) column # Old: car_sales_missing[\"Odometer (KM)\"].fillna(value=car_sales_missing[\"Odometer (KM)\"].mean(), inplace=True)  car_sales_missing[\"Odometer (KM)\"] = car_sales_missing[\"Odometer (KM)\"].fillna(value=car_sales_missing[\"Odometer (KM)\"].mean()) <p>How many missing values do we have now?</p> In\u00a0[61]: Copied! <pre># Check the number of missing values\ncar_sales_missing.isna().sum()\n</pre> # Check the number of missing values car_sales_missing.isna().sum() Out[61]: <pre>Make              0\nColour            0\nOdometer (KM)     0\nDoors             0\nPrice            50\ndtype: int64</pre> <p>Woohoo! That's looking a lot better.</p> <p>Finally, we can remove the rows which are missing the target value <code>Price</code>.</p> <p>Note: Another option would be to impute the <code>Price</code> value with the mean or median or some other calculated value (such as by using similar cars to estimate the price), however, to keep things simple and prevent introducing too many fake labels to the data, we'll remove the samples missing a <code>Price</code> value.</p> <p>We can remove rows with missing values in place from a pandas DataFrame with the <code>pandas.DataFrame.dropna(inplace=True)</code> method.</p> In\u00a0[62]: Copied! <pre># Remove rows with missing Price labels\ncar_sales_missing.dropna(inplace=True)\n</pre> # Remove rows with missing Price labels car_sales_missing.dropna(inplace=True) <p>That should be no more missing values!</p> In\u00a0[63]: Copied! <pre># Check the number of missing values\ncar_sales_missing.isna().sum()\n</pre> # Check the number of missing values car_sales_missing.isna().sum() Out[63]: <pre>Make             0\nColour           0\nOdometer (KM)    0\nDoors            0\nPrice            0\ndtype: int64</pre> <p>Since we removed samples missing a <code>Price</code> value, there's now less overall samples but none of them have missing values.</p> In\u00a0[64]: Copied! <pre># Check the number of total samples (previously was 1000)\nlen(car_sales_missing)\n</pre> # Check the number of total samples (previously was 1000) len(car_sales_missing) Out[64]: <pre>950</pre> <p>Can we fit a model now?</p> <p>Let's try!</p> <p>First we'll create the features and labels.</p> <p>Then we'll convert categorical variables into numbers via one-hot encoding.</p> <p>Then we'll split the data into training and test sets just like before.</p> <p>Finally, we'll try to fit a <code>RandomForestRegressor()</code> model to the newly filled data.</p> In\u00a0[65]: Copied! <pre># Create features\nX_missing = car_sales_missing.drop(\"Price\", axis=1)\nprint(f\"Number of missing X values:\\n{X_missing.isna().sum()}\")\n\n# Create labels\ny_missing = car_sales_missing[\"Price\"]\nprint(f\"Number of missing y values: {y_missing.isna().sum()}\")\n</pre> # Create features X_missing = car_sales_missing.drop(\"Price\", axis=1) print(f\"Number of missing X values:\\n{X_missing.isna().sum()}\")  # Create labels y_missing = car_sales_missing[\"Price\"] print(f\"Number of missing y values: {y_missing.isna().sum()}\") <pre>Number of missing X values:\nMake             0\nColour           0\nOdometer (KM)    0\nDoors            0\ndtype: int64\nNumber of missing y values: 0\n</pre> In\u00a0[66]: Copied! <pre>from sklearn.preprocessing import OneHotEncoder\nfrom sklearn.compose import ColumnTransformer\n\ncategorical_features = [\"Make\", \"Colour\", \"Doors\"]\n\none_hot = OneHotEncoder()\n\ntransformer = ColumnTransformer([(\"one_hot\", \n                                  one_hot, \n                                  categorical_features)],\n                                remainder=\"passthrough\",\n                                sparse_threshold=0) # return a sparse matrix or not\n\ntransformed_X_missing = transformer.fit_transform(X_missing)\ntransformed_X_missing\n</pre> from sklearn.preprocessing import OneHotEncoder from sklearn.compose import ColumnTransformer  categorical_features = [\"Make\", \"Colour\", \"Doors\"]  one_hot = OneHotEncoder()  transformer = ColumnTransformer([(\"one_hot\",                                    one_hot,                                    categorical_features)],                                 remainder=\"passthrough\",                                 sparse_threshold=0) # return a sparse matrix or not  transformed_X_missing = transformer.fit_transform(X_missing) transformed_X_missing Out[66]: <pre>array([[0.00000e+00, 1.00000e+00, 0.00000e+00, ..., 1.00000e+00,\n        0.00000e+00, 3.54310e+04],\n       [1.00000e+00, 0.00000e+00, 0.00000e+00, ..., 0.00000e+00,\n        1.00000e+00, 1.92714e+05],\n       [0.00000e+00, 1.00000e+00, 0.00000e+00, ..., 1.00000e+00,\n        0.00000e+00, 8.47140e+04],\n       ...,\n       [0.00000e+00, 0.00000e+00, 1.00000e+00, ..., 1.00000e+00,\n        0.00000e+00, 6.66040e+04],\n       [0.00000e+00, 1.00000e+00, 0.00000e+00, ..., 1.00000e+00,\n        0.00000e+00, 2.15883e+05],\n       [0.00000e+00, 0.00000e+00, 0.00000e+00, ..., 1.00000e+00,\n        0.00000e+00, 2.48360e+05]])</pre> In\u00a0[67]: Copied! <pre># Split data into training and test sets\nnp.random.seed(42)\nX_train, X_test, y_train, y_test = train_test_split(transformed_X_missing,\n                                                    y_missing,\n                                                    test_size=0.2)\n\n# Fit and score a model\nmodel = RandomForestRegressor()\nmodel.fit(X_train, y_train)\nmodel.score(X_test, y_test)\n</pre> # Split data into training and test sets np.random.seed(42) X_train, X_test, y_train, y_test = train_test_split(transformed_X_missing,                                                     y_missing,                                                     test_size=0.2)  # Fit and score a model model = RandomForestRegressor() model.fit(X_train, y_train) model.score(X_test, y_test) Out[67]: <pre>0.22011714008302485</pre> <p>Fantastic!!!</p> <p>Looks like filling the missing values with pandas worked!</p> <p>Our model can be fit to the data without issues.</p> In\u00a0[68]: Copied! <pre>car_sales_missing.isna().sum()\n</pre> car_sales_missing.isna().sum() Out[68]: <pre>Make             0\nColour           0\nOdometer (KM)    0\nDoors            0\nPrice            0\ndtype: int64</pre> <p>Let's reimport it so it has missing values and we can fill them with Scikit-Learn.</p> In\u00a0[69]: Copied! <pre># Reimport the DataFrame (so that all the missing values are back)\n# car_sales_missing = pd.read_csv(\"../data/car-sales-extended-missing-data.csv\") # read from local directory\ncar_sales_missing = pd.read_csv(\"https://raw.githubusercontent.com/mrdbourke/zero-to-mastery-ml/master/data/car-sales-extended-missing-data.csv\") # read directly from URL (source: https://github.com/mrdbourke/zero-to-mastery-ml/blob/master/data/car-sales-extended-missing-data.csv)\ncar_sales_missing.isna().sum()\n</pre> # Reimport the DataFrame (so that all the missing values are back) # car_sales_missing = pd.read_csv(\"../data/car-sales-extended-missing-data.csv\") # read from local directory car_sales_missing = pd.read_csv(\"https://raw.githubusercontent.com/mrdbourke/zero-to-mastery-ml/master/data/car-sales-extended-missing-data.csv\") # read directly from URL (source: https://github.com/mrdbourke/zero-to-mastery-ml/blob/master/data/car-sales-extended-missing-data.csv) car_sales_missing.isna().sum() Out[69]: <pre>Make             49\nColour           50\nOdometer (KM)    50\nDoors            50\nPrice            50\ndtype: int64</pre> <p>To begin, we'll remove the rows which are missing a <code>Price</code> value.</p> In\u00a0[70]: Copied! <pre># Drop the rows with missing in the Price column\ncar_sales_missing.dropna(subset=[\"Price\"], inplace=True)\n</pre> # Drop the rows with missing in the Price column car_sales_missing.dropna(subset=[\"Price\"], inplace=True) <p>Now there are no rows missing a <code>Price</code> value.</p> In\u00a0[71]: Copied! <pre>car_sales_missing.isna().sum()\n</pre> car_sales_missing.isna().sum() Out[71]: <pre>Make             47\nColour           46\nOdometer (KM)    48\nDoors            47\nPrice             0\ndtype: int64</pre> <p>Since we don't have to fill any <code>Price</code> values, let's split our data into features (<code>X</code>) and labels (<code>y</code>).</p> <p>We'll also split the data into training and test sets.</p> In\u00a0[72]: Copied! <pre># Split into X and y\nX = car_sales_missing.drop(\"Price\", axis=1)\ny = car_sales_missing[\"Price\"]\n\n# Split data into train and test\nnp.random.seed(42)\nX_train, X_test, y_train, y_test = train_test_split(X,\n                                                    y,\n                                                    test_size=0.2)\n</pre> # Split into X and y X = car_sales_missing.drop(\"Price\", axis=1) y = car_sales_missing[\"Price\"]  # Split data into train and test np.random.seed(42) X_train, X_test, y_train, y_test = train_test_split(X,                                                     y,                                                     test_size=0.2) <p>Note: We've split the data into train &amp; test sets here first to perform filling missing values on them separately. This is best practice as the test set is supposed to emulate data the model has never seen before. For categorical variables, it's generally okay to fill values across the whole dataset. However, for numerical vairables, you should only fill values on the test set that have been computed from the training set.</p> <p>Training and test sets created!</p> <p>Let's now setup a few instances of <code>SimpleImputer()</code> to fill various missing values.</p> <p>We'll use the following strategies and fill values:</p> <ul> <li>For categorical columns (<code>Make</code>, <code>Colour</code>), <code>strategy=\"constant\"</code>, <code>fill_value=\"missing\"</code> (fill the missing samples with a consistent value of <code>\"missing\"</code>.</li> <li>For the <code>Door</code> column, <code>strategy=\"constant\"</code>, <code>fill_value=4</code> (fill the missing samples with a consistent value of <code>4</code>).</li> <li>For the numerical column (<code>Odometer (KM)</code>), <code>strategy=\"mean\"</code> (fill the missing samples with the mean of the target column).<ul> <li>Note: There are more <code>strategy</code> and fill options in the <code>SimpleImputer()</code> documentation.</li> </ul> </li> </ul> In\u00a0[73]: Copied! <pre>from sklearn.impute import SimpleImputer\n\n# Create categorical variable imputer\ncat_imputer = SimpleImputer(strategy=\"constant\", fill_value=\"missing\")\n\n# Create Door column imputer\ndoor_imputer = SimpleImputer(strategy=\"constant\", fill_value=4)\n\n# Create Odometer (KM) column imputer\nnum_imputer = SimpleImputer(strategy=\"mean\")\n</pre> from sklearn.impute import SimpleImputer  # Create categorical variable imputer cat_imputer = SimpleImputer(strategy=\"constant\", fill_value=\"missing\")  # Create Door column imputer door_imputer = SimpleImputer(strategy=\"constant\", fill_value=4)  # Create Odometer (KM) column imputer num_imputer = SimpleImputer(strategy=\"mean\") <p>Imputers created!</p> <p>Now let's define which columns we'd like to impute on.</p> <p>Why?</p> <p>Because we'll need these shortly (I'll explain in the next text cell).</p> In\u00a0[74]: Copied! <pre># Define different column features\ncategorical_features = [\"Make\", \"Colour\"]\ndoor_feature = [\"Doors\"]\nnumerical_feature = [\"Odometer (KM)\"]\n</pre> # Define different column features categorical_features = [\"Make\", \"Colour\"] door_feature = [\"Doors\"] numerical_feature = [\"Odometer (KM)\"] <p>Columns defined!</p> <p>Now how might we transform our columns?</p> <p>Hint: we can use the <code>sklearn.compose.ColumnTransformer</code> class from Scikit-Learn, in a similar way to what we did before to get our data to all numeric values.</p> <p>That's the reason we defined the columns we'd like to transform.</p> <p>So we can use the <code>ColumnTransformer()</code> class.</p> <p><code>ColumnTransformer()</code> takes as input a list of tuples in the form <code>(name_of_transform, transformer_to_use, columns_to_transform)</code> specifying which columns to transform and how to transform them.</p> <p>For example:</p> <pre>imputer = ColumnTransformer([\n    (\"cat_imputer\", cat_imputer, categorical_features)\n])\n</pre> <p>In this case, the variables in the tuple are:</p> <ul> <li><code>name_of_transform</code> = <code>\"cat_imputer\"</code></li> <li><code>transformer_to_use</code> = <code>cat_imputer</code> (the instance of <code>SimpleImputer()</code> we defined above)</li> <li><code>columns_to_transform</code> = <code>categorical_features</code> (the list of categorical features we defined above).</li> </ul> <p>Let's exapnd upon this by extending the example.</p> In\u00a0[75]: Copied! <pre>from sklearn.compose import ColumnTransformer\n\n# Create series of column transforms to perform\nimputer = ColumnTransformer([\n    (\"cat_imputer\", cat_imputer, categorical_features),\n    (\"door_imputer\", door_imputer, door_feature),\n    (\"num_imputer\", num_imputer, numerical_feature)])\n</pre> from sklearn.compose import ColumnTransformer  # Create series of column transforms to perform imputer = ColumnTransformer([     (\"cat_imputer\", cat_imputer, categorical_features),     (\"door_imputer\", door_imputer, door_feature),     (\"num_imputer\", num_imputer, numerical_feature)]) <p>Nice!</p> <p>The next step is to fit our <code>ColumnTransformer()</code> instance (<code>imputer</code>) to the training data and transform the testing data.</p> <p>In other words we want to:</p> <ol> <li>Learn the imputation values from the training set.</li> <li>Fill the missing values in the training set with the values learned in 1.</li> <li>Fill the missing values in the testing set with the values learned in 1.</li> </ol> <p>Why this way?</p> <p>In our case, we're not calculating many variables (except the mean of the <code>Odometer (KM)</code> column), however, remember that the test set should always remain as unseen data.</p> <p>So when filling values in the test set, they should only be with values calculated or imputed from the training sets.</p> <p>We can achieve steps 1 &amp; 2 simultaneously with the <code>ColumnTransformer.fit_transform()</code> method (<code>fit</code> = find the values to fill, <code>transform</code> = fill them).</p> <p>And then we can perform step 3 with the <code>ColumnTransformer.transform()</code> method (we only want to transform the test set, not learn different values to fill).</p> In\u00a0[76]: Copied! <pre># Find values to fill and transform training data\nfilled_X_train = imputer.fit_transform(X_train)\n\n# Fill values in to the test set with values learned from the training set\nfilled_X_test = imputer.transform(X_test)\n\n# Check filled X_train\nfilled_X_train\n</pre> # Find values to fill and transform training data filled_X_train = imputer.fit_transform(X_train)  # Fill values in to the test set with values learned from the training set filled_X_test = imputer.transform(X_test)  # Check filled X_train filled_X_train Out[76]: <pre>array([['Honda', 'White', 4.0, 71934.0],\n       ['Toyota', 'Red', 4.0, 162665.0],\n       ['Honda', 'White', 4.0, 42844.0],\n       ...,\n       ['Toyota', 'White', 4.0, 196225.0],\n       ['Honda', 'Blue', 4.0, 133117.0],\n       ['Honda', 'missing', 4.0, 150582.0]], dtype=object)</pre> <p>Wonderful!</p> <p>Let's now turn our <code>filled_X_train</code> and <code>filled_X_test</code> arrays into DataFrames to inspect their missing values.</p> In\u00a0[77]: Copied! <pre># Get our transformed data array's back into DataFrame's\nfilled_X_train_df = pd.DataFrame(filled_X_train, \n                                 columns=[\"Make\", \"Colour\", \"Doors\", \"Odometer (KM)\"])\n\nfilled_X_test_df = pd.DataFrame(filled_X_test, \n                                columns=[\"Make\", \"Colour\", \"Doors\", \"Odometer (KM)\"])\n\n# Check missing data in training set\nfilled_X_train_df.isna().sum()\n</pre> # Get our transformed data array's back into DataFrame's filled_X_train_df = pd.DataFrame(filled_X_train,                                   columns=[\"Make\", \"Colour\", \"Doors\", \"Odometer (KM)\"])  filled_X_test_df = pd.DataFrame(filled_X_test,                                  columns=[\"Make\", \"Colour\", \"Doors\", \"Odometer (KM)\"])  # Check missing data in training set filled_X_train_df.isna().sum() Out[77]: <pre>Make             0\nColour           0\nDoors            0\nOdometer (KM)    0\ndtype: int64</pre> <p>And is there any missing data in the test set?</p> In\u00a0[78]: Copied! <pre># Check missing data in the testing set\nfilled_X_test_df.isna().sum()\n</pre> # Check missing data in the testing set filled_X_test_df.isna().sum() Out[78]: <pre>Make             0\nColour           0\nDoors            0\nOdometer (KM)    0\ndtype: int64</pre> <p>What about the original?</p> In\u00a0[79]: Copied! <pre># Check to see the original... still missing values\ncar_sales_missing.isna().sum()\n</pre> # Check to see the original... still missing values car_sales_missing.isna().sum() Out[79]: <pre>Make             47\nColour           46\nOdometer (KM)    48\nDoors            47\nPrice             0\ndtype: int64</pre> <p>Perfect!</p> <p>No more missing values!</p> <p>But wait...</p> <p>Is our data all numerical?</p> In\u00a0[80]: Copied! <pre>filled_X_train_df.head()\n</pre> filled_X_train_df.head() Out[80]: Make Colour Doors Odometer (KM) 0 Honda White 4.0 71934.0 1 Toyota Red 4.0 162665.0 2 Honda White 4.0 42844.0 3 Honda White 4.0 195829.0 4 Honda Blue 4.0 219217.0 <p>Ahh... looks like our <code>Make</code> and <code>Colour</code> columns are still strings.</p> <p>Let's one-hot encode them along with the <code>Doors</code> column to make sure they're numerical, just as we did previously.</p> In\u00a0[81]: Copied! <pre># Now let's one hot encode the features with the same code as before \nfrom sklearn.preprocessing import OneHotEncoder\nfrom sklearn.compose import ColumnTransformer\n\ncategorical_features = [\"Make\", \"Colour\", \"Doors\"]\n\none_hot = OneHotEncoder()\n\ntransformer = ColumnTransformer([(\"one_hot\", \n                                  one_hot, \n                                  categorical_features)],\n                                remainder=\"passthrough\",\n                                sparse_threshold=0) # return a sparse matrix or not\n\n# Fill train and test values separately\ntransformed_X_train = transformer.fit_transform(filled_X_train_df)\ntransformed_X_test = transformer.transform(filled_X_test_df)\n\n# Check transformed and filled X_train\ntransformed_X_train\n</pre> # Now let's one hot encode the features with the same code as before  from sklearn.preprocessing import OneHotEncoder from sklearn.compose import ColumnTransformer  categorical_features = [\"Make\", \"Colour\", \"Doors\"]  one_hot = OneHotEncoder()  transformer = ColumnTransformer([(\"one_hot\",                                    one_hot,                                    categorical_features)],                                 remainder=\"passthrough\",                                 sparse_threshold=0) # return a sparse matrix or not  # Fill train and test values separately transformed_X_train = transformer.fit_transform(filled_X_train_df) transformed_X_test = transformer.transform(filled_X_test_df)  # Check transformed and filled X_train transformed_X_train Out[81]: <pre>array([[0.0, 1.0, 0.0, ..., 1.0, 0.0, 71934.0],\n       [0.0, 0.0, 0.0, ..., 1.0, 0.0, 162665.0],\n       [0.0, 1.0, 0.0, ..., 1.0, 0.0, 42844.0],\n       ...,\n       [0.0, 0.0, 0.0, ..., 1.0, 0.0, 196225.0],\n       [0.0, 1.0, 0.0, ..., 1.0, 0.0, 133117.0],\n       [0.0, 1.0, 0.0, ..., 1.0, 0.0, 150582.0]], dtype=object)</pre> <p>Nice!</p> <p>Now our data is:</p> <ol> <li>All numerical</li> <li>No missing values</li> </ol> <p>Let's try and fit a model!</p> In\u00a0[82]: Copied! <pre># Now we've transformed X, let's see if we can fit a model\nnp.random.seed(42)\nfrom sklearn.ensemble import RandomForestRegressor\n\nmodel = RandomForestRegressor()\n\n# Make sure to use the transformed data (filled and one-hot encoded X data)\nmodel.fit(transformed_X_train, y_train)\nmodel.score(transformed_X_test, y_test)\n</pre> # Now we've transformed X, let's see if we can fit a model np.random.seed(42) from sklearn.ensemble import RandomForestRegressor  model = RandomForestRegressor()  # Make sure to use the transformed data (filled and one-hot encoded X data) model.fit(transformed_X_train, y_train) model.score(transformed_X_test, y_test) Out[82]: <pre>0.21229043336119102</pre> <p>You might have noticed this result is slightly different to before.</p> <p>Why do you think this is?</p> <p>It's because we've created our training and testing sets differently.</p> <p>We split the data into training and test sets before filling the missing values.</p> <p>Previously, we did the reverse, filled missing values before splitting the data into training and test sets.</p> <p>Doing this can lead to information from the training set leaking into the testing set.</p> <p>Remember, one of the most important concepts in machine learning is making sure your model doesn't see any testing data before evaluation.</p> <p>We'll keep practicing but for now, some of the main takeaways are:</p> <ul> <li>Keep your training and test sets separate.</li> <li>Most datasets you come across won't be in a form ready to immediately start using them with machine learning models. And some may take more preparation than others to get ready to use.</li> <li>For most machine learning models, your data has to be numerical. This will involve converting whatever you're working with into numbers. This process is often referred to as feature engineering or feature encoding.</li> <li>Some machine learning models aren't compatible with missing data. The process of filling missing data is referred to as data imputation.</li> </ul> In\u00a0[83]: Copied! <pre># Get California Housing dataset\nfrom sklearn.datasets import fetch_california_housing\nhousing = fetch_california_housing()\nhousing; # gets downloaded as dictionary\n</pre> # Get California Housing dataset from sklearn.datasets import fetch_california_housing housing = fetch_california_housing() housing; # gets downloaded as dictionary <p>Since it's in a dictionary, let's turn it into a DataFrame so we can inspect it better.</p> In\u00a0[84]: Copied! <pre>housing_df = pd.DataFrame(housing[\"data\"], columns=housing[\"feature_names\"])\nhousing_df[\"target\"] = pd.Series(housing[\"target\"])\nhousing_df.head()\n</pre> housing_df = pd.DataFrame(housing[\"data\"], columns=housing[\"feature_names\"]) housing_df[\"target\"] = pd.Series(housing[\"target\"]) housing_df.head() Out[84]: MedInc HouseAge AveRooms AveBedrms Population AveOccup Latitude Longitude target 0 8.3252 41.0 6.984127 1.023810 322.0 2.555556 37.88 -122.23 4.526 1 8.3014 21.0 6.238137 0.971880 2401.0 2.109842 37.86 -122.22 3.585 2 7.2574 52.0 8.288136 1.073446 496.0 2.802260 37.85 -122.24 3.521 3 5.6431 52.0 5.817352 1.073059 558.0 2.547945 37.85 -122.25 3.413 4 3.8462 52.0 6.281853 1.081081 565.0 2.181467 37.85 -122.25 3.422 In\u00a0[85]: Copied! <pre># How many samples?\nlen(housing_df)\n</pre> # How many samples? len(housing_df) Out[85]: <pre>20640</pre> <p>Beautiful, our goal here is to use the feature columns, such as:</p> <ul> <li><code>MedInc</code> - median income in block group</li> <li><code>HouseAge</code> - median house age in block group</li> <li><code>AveRooms</code> - average number of rooms per household</li> <li><code>AveBedrms</code> - average number of bedrooms per household</li> </ul> <p>To predict the <code>target</code> column which expresses the median house value for specfici California districts in hundreds of thousands of dollars (e.g. 4.526 = $452,600).</p> <p>In essence, each row is a different district in California (the data) and we're trying to build a model to predict the median house value in that distract (the target/label) given a series of attributes about the houses in that district.</p> <p>Since we have data and labels, this is a supervised learning problem.</p> <p>And since we're trying to predict a number, it's a regression problem.</p> <p>Knowing these two things, how do they line up on the Scikit-Learn machine learning algorithm cheat-sheet?</p> <p>Following the map through, knowing what we know, it suggests we try <code>RidgeRegression</code>. Let's chek it out.</p> In\u00a0[86]: Copied! <pre># Import the Ridge model class from the linear_model module\nfrom sklearn.linear_model import Ridge\n\n# Setup random seed\nnp.random.seed(42)\n\n# Split the data into features (X) and labels (y)\nX = housing_df.drop(\"target\", axis=1)\ny = housing_df[\"target\"]\n\n# Split into train and test sets\nX_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2)\n\n# Institate and fit the model (on the training set)\nmodel = Ridge()\nmodel.fit(X_train, y_train)\n\n# Check the score of the model (on the test set)\n# The default score() metirc of regression aglorithms is R^2\nmodel.score(X_test, y_test)\n</pre> # Import the Ridge model class from the linear_model module from sklearn.linear_model import Ridge  # Setup random seed np.random.seed(42)  # Split the data into features (X) and labels (y) X = housing_df.drop(\"target\", axis=1) y = housing_df[\"target\"]  # Split into train and test sets X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2)  # Institate and fit the model (on the training set) model = Ridge() model.fit(X_train, y_train)  # Check the score of the model (on the test set) # The default score() metirc of regression aglorithms is R^2 model.score(X_test, y_test) Out[86]: <pre>0.5758549611440125</pre> <p>What if <code>RidgeRegression</code> didn't work? Or what if we wanted to improve our results?</p> <p>Following the diagram, the next step would be to try <code>EnsembleRegressors</code>.</p> <p>Ensemble is another word for multiple models put together to make a decision.</p> <p>One of the most common and useful ensemble methods is the Random Forest. Known for its fast training and prediction times and adaptibility to different problems.</p> <p>The basic premise of the Random Forest is to combine a number of different decision trees, each one random from the other and make a prediction on a sample by averaging the result of each decision tree.</p> <p>An in-depth discussion of the Random Forest algorithm is beyond the scope of this notebook but if you're interested in learning more, An Implementation and Explanation of the Random Forest in Python by Will Koehrsen is a great read.</p> <p>Since we're working with regression, we'll use Scikit-Learn's <code>RandomForestRegressor</code>.</p> <p>We can use the exact same workflow as above. Except for changing the model.</p> In\u00a0[87]: Copied! <pre># Import the RandomForestRegressor model class from the ensemble module\nfrom sklearn.ensemble import RandomForestRegressor\n\n# Setup random seed\nnp.random.seed(42)\n\n# Split the data into features (X) and labels (y)\nX = housing_df.drop(\"target\", axis=1)\ny = housing_df[\"target\"]\n\n# Split into train and test sets\nX_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2)\n\n# Institate and fit the model (on the training set)\nmodel = RandomForestRegressor()\nmodel.fit(X_train, y_train)\n\n# Check the score of the model (on the test set)\n# The default score metirc of regression aglorithms is R^2\nmodel.score(X_test, y_test)\n</pre> # Import the RandomForestRegressor model class from the ensemble module from sklearn.ensemble import RandomForestRegressor  # Setup random seed np.random.seed(42)  # Split the data into features (X) and labels (y) X = housing_df.drop(\"target\", axis=1) y = housing_df[\"target\"]  # Split into train and test sets X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2)  # Institate and fit the model (on the training set) model = RandomForestRegressor() model.fit(X_train, y_train)  # Check the score of the model (on the test set) # The default score metirc of regression aglorithms is R^2 model.score(X_test, y_test) Out[87]: <pre>0.8059809073051385</pre> <p>Woah!</p> <p>We get a good boost in score on the test set by changing the model.</p> <p>This is another incredibly important concept in machine learning, if at first something doesn't achieve what you'd like, experiment, experiment, experiment!</p> <p>At first, the Scikit-Learn algorithm diagram can seem confusing.</p> <p>But once you get a little practice applying different models to different problems, you'll start to pick up which sorts of algorithms do better with different types of data.</p> In\u00a0[90]: Copied! <pre># heart_disease = pd.read_csv(\"../data/heart-disease.csv\") # load from local directory\nheart_disease = pd.read_csv(\"https://raw.githubusercontent.com/mrdbourke/zero-to-mastery-ml/master/data/heart-disease.csv\") # load directly from URL (source: https://github.com/mrdbourke/zero-to-mastery-ml/blob/master/data/heart-disease.csv)\nheart_disease.head()\n</pre> # heart_disease = pd.read_csv(\"../data/heart-disease.csv\") # load from local directory heart_disease = pd.read_csv(\"https://raw.githubusercontent.com/mrdbourke/zero-to-mastery-ml/master/data/heart-disease.csv\") # load directly from URL (source: https://github.com/mrdbourke/zero-to-mastery-ml/blob/master/data/heart-disease.csv) heart_disease.head() Out[90]: age sex cp trestbps chol fbs restecg thalach exang oldpeak slope ca thal target 0 63 1 3 145 233 1 0 150 0 2.3 0 0 1 1 1 37 1 2 130 250 0 1 187 0 3.5 0 0 2 1 2 41 0 1 130 204 0 0 172 0 1.4 2 0 2 1 3 56 1 1 120 236 0 1 178 0 0.8 2 0 2 1 4 57 0 0 120 354 0 1 163 1 0.6 2 0 2 1 In\u00a0[91]: Copied! <pre># How many samples are there?\nlen(heart_disease)\n</pre> # How many samples are there? len(heart_disease) Out[91]: <pre>303</pre> <p>Similar to the California Housing dataset, here we want to use all of the available data to predict the target column (1 for if a patient has heart disease and 0 for if they don't).</p> <p>So what do we know?</p> <p>We've got 303 samples (1 row = 1 sample) and we're trying to predict whether or not a patient has heart disease.</p> <p>Because we're trying to predict whether each sample is one thing or another, we've got a classification problem.</p> <p>Let's see how it lines up with our Scikit-Learn algorithm cheat-sheet.</p> <p>Following the cheat-sheet we end up at <code>LinearSVC</code> which stands for Linear Support Vector Classifier. Let's try it on our data.</p> In\u00a0[92]: Copied! <pre># Import LinearSVC from the svm module\nfrom sklearn.svm import LinearSVC\n\n# Setup random seed\nnp.random.seed(42)\n\n# Split the data into X (features/data) and y (target/labels)\nX = heart_disease.drop(\"target\", axis=1)\ny = heart_disease[\"target\"]\n\n# Split into train and test sets\nX_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2)\n\n# Instantiate and fit the model (on the training set)\nclf = LinearSVC(max_iter=1000, # iterations on the data, 1000 is the default\n                dual=\"auto\") # dual=\"auto\" chooses best parameters for the model automatically\nclf.fit(X_train, y_train)\n\n# Check the score of the model (on the test set)\nclf.score(X_test, y_test)\n</pre> # Import LinearSVC from the svm module from sklearn.svm import LinearSVC  # Setup random seed np.random.seed(42)  # Split the data into X (features/data) and y (target/labels) X = heart_disease.drop(\"target\", axis=1) y = heart_disease[\"target\"]  # Split into train and test sets X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2)  # Instantiate and fit the model (on the training set) clf = LinearSVC(max_iter=1000, # iterations on the data, 1000 is the default                 dual=\"auto\") # dual=\"auto\" chooses best parameters for the model automatically clf.fit(X_train, y_train)  # Check the score of the model (on the test set) clf.score(X_test, y_test) Out[92]: <pre>0.8688524590163934</pre> <p>Straight out of the box (with no tuning or improvements) our model achieves over 85% accruacy!</p> <p>Although this is a sensational result to begin with, let's check out the diagram and see what other models we might use.</p> <p>Following the path (and skipping a few, don't worry, we'll get to this) we come up to <code>EnsembleMethods</code> again.</p> <p>Except this time, we'll be looking at ensemble classifiers instead of regressors.</p> <p>Remember our <code>RandomForestRegressor</code> from above?</p> <p>We'll it has a dance partner, <code>RandomForestClassifier</code> which is an ensemble based machine model learning model for classification.</p> <p>You might be able to guess what we can use it for (hint: classification problems).</p> <p>Let's try!</p> In\u00a0[93]: Copied! <pre># Import the RandomForestClassifier model class from the ensemble module\nfrom sklearn.ensemble import RandomForestClassifier\n\n# Setup random seed\nnp.random.seed(42)\n\n# Split the data into X (features/data) and y (target/labels)\nX = heart_disease.drop(\"target\", axis=1)\ny = heart_disease[\"target\"]\n\n# Split into train and test sets\nX_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2)\n\n# Instantiate and fit the model (on the training set)\nclf = RandomForestClassifier(n_estimators=100) # 100 is the default, but you could try 1000 and see what happens\nclf.fit(X_train, y_train)\n\n# Check the score of the model (on the test set)\nclf.score(X_test, y_test)\n</pre> # Import the RandomForestClassifier model class from the ensemble module from sklearn.ensemble import RandomForestClassifier  # Setup random seed np.random.seed(42)  # Split the data into X (features/data) and y (target/labels) X = heart_disease.drop(\"target\", axis=1) y = heart_disease[\"target\"]  # Split into train and test sets X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2)  # Instantiate and fit the model (on the training set) clf = RandomForestClassifier(n_estimators=100) # 100 is the default, but you could try 1000 and see what happens clf.fit(X_train, y_train)  # Check the score of the model (on the test set) clf.score(X_test, y_test) Out[93]: <pre>0.8524590163934426</pre> <p>Hmmm, it looks like the default hyperparameters of <code>RandomForestClassifier</code> don't perform as well as <code>LinearSVC</code>.</p> <p>Other than trying another classification model, we could start to run experiments to try and improve these models via hyperparameter tuning.</p> <p>Hyperparameter tuning is fancy term for adjusting some settings on a model to try and make it better.</p> <p>It usually happens once you've found a decent baseline model that you'd like to improve upon.</p> <p>In this case, we could take either the <code>RandomForestClassifier</code> or the <code>LinearSVC</code> and try and improve it with hyperparameter tuning (which we'll see later on).</p> <p>For example, you could try and take the <code>n_estimators</code> parameter (the number of trees in the forest) of <code>RandomForestClassifier</code> and change it from <code>100</code> (default) to <code>1000</code> and see what happens.</p> In\u00a0[94]: Copied! <pre># Import the RandomForestClassifier model class from the ensemble module\nfrom sklearn.ensemble import RandomForestClassifier\n\n# Setup random seed\nnp.random.seed(42)\n\n# Split the data into X (features/data) and y (target/labels)\nX = heart_disease.drop(\"target\", axis=1)\ny = heart_disease[\"target\"]\n\n# Split into train and test sets\nX_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2)\n\n# Instantiate the model (on the training set)\nclf = RandomForestClassifier(n_estimators=100)\n\n# Call the fit method on the model and pass it training data\nclf.fit(X_train, y_train)\n\n# Check the score of the model (on the test set)\nclf.score(X_test, y_test)\n</pre> # Import the RandomForestClassifier model class from the ensemble module from sklearn.ensemble import RandomForestClassifier  # Setup random seed np.random.seed(42)  # Split the data into X (features/data) and y (target/labels) X = heart_disease.drop(\"target\", axis=1) y = heart_disease[\"target\"]  # Split into train and test sets X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2)  # Instantiate the model (on the training set) clf = RandomForestClassifier(n_estimators=100)  # Call the fit method on the model and pass it training data clf.fit(X_train, y_train)  # Check the score of the model (on the test set) clf.score(X_test, y_test) Out[94]: <pre>0.8524590163934426</pre> <p>What's happening here?</p> <p>Calling the <code>fit()</code> method will cause the machine learning algorithm to attempt to find patterns between <code>X</code> and <code>y</code>. Or if there's no <code>y</code>, it'll only find the patterns within <code>X</code>.</p> <p>Let's see <code>X</code>.</p> In\u00a0[95]: Copied! <pre>X.head()\n</pre> X.head() Out[95]: age sex cp trestbps chol fbs restecg thalach exang oldpeak slope ca thal 0 63 1 3 145 233 1 0 150 0 2.3 0 0 1 1 37 1 2 130 250 0 1 187 0 3.5 0 0 2 2 41 0 1 130 204 0 0 172 0 1.4 2 0 2 3 56 1 1 120 236 0 1 178 0 0.8 2 0 2 4 57 0 0 120 354 0 1 163 1 0.6 2 0 2 <p>And <code>y</code>.</p> In\u00a0[96]: Copied! <pre>y.head()\n</pre> y.head() Out[96]: <pre>0    1\n1    1\n2    1\n3    1\n4    1\nName: target, dtype: int64</pre> <p>Passing <code>X</code> and <code>y</code> to <code>fit()</code> will cause the model to go through all of the examples in <code>X</code> (data) and see what their corresponding <code>y</code> (label) is.</p> <p>How the model does this is different depending on the model you use.</p> <p>Explaining the details of each would take an entire textbook.</p> <p>For now, you could imagine it similar to how you would figure out patterns if you had enough time.</p> <p>You'd look at the feature variables, <code>X</code>, the <code>age</code>, <code>sex</code>, <code>chol</code> (cholesterol) and see what different values led to the labels, <code>y</code>, <code>1</code> for heart disease, <code>0</code> for not heart disease.</p> <p>This concept, regardless of the problem, is similar throughout all of machine learning.</p> <p>During training (finding patterns in data):</p> <p>A machine learning algorithm looks at a dataset, finds patterns, tries to use those patterns to predict something and corrects itself as best it can with the available data and labels. It stores these patterns for later use.</p> <p>During testing or in production (using learned patterns):</p> <p>A machine learning algorithm uses the patterns its previously learned in a dataset to make a prediction on some unseen data.</p> In\u00a0[97]: Copied! <pre># Use a trained model to make predictions\nclf.predict(X_test)\n</pre> # Use a trained model to make predictions clf.predict(X_test) Out[97]: <pre>array([0, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1, 0, 1, 0, 1, 1, 1, 0, 0, 0, 0, 0,\n       1, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1,\n       1, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0])</pre> <p>Given data in the form of <code>X</code>, the <code>predict()</code> function returns labels in the form of <code>y</code>.</p> <p>Note: For the <code>predict()</code> function to work, it must be passed <code>X</code> (data) in the same format the model was trained on. For example, if a model was trained on 10 features formatted in a certain way, predictions should be made on data with 10 features fortmatted in a certain way. Anything different and it will return an error.</p> <p>It's standard practice to save these predictions to a variable named something like <code>y_preds</code> for later comparison to <code>y_test</code> or <code>y_true</code> (usually same as <code>y_test</code> just another name).</p> In\u00a0[98]: Copied! <pre># Compare predictions to truth\ny_preds = clf.predict(X_test)\nnp.mean(y_preds == y_test)\n</pre> # Compare predictions to truth y_preds = clf.predict(X_test) np.mean(y_preds == y_test) Out[98]: <pre>np.float64(0.8524590163934426)</pre> <p>Another way evaluating predictions (comparing them to the truth labels) is with Scikit-Learn's <code>sklearn.metrics</code> module.</p> <p>Inside, you'll find method such as <code>accuracy_score()</code>, which is the default evaluation metric for classification problems.</p> In\u00a0[100]: Copied! <pre>from sklearn.metrics import accuracy_score\naccuracy_score(y_test, y_preds)\n</pre> from sklearn.metrics import accuracy_score accuracy_score(y_test, y_preds) Out[100]: <pre>0.8524590163934426</pre> <p><code>predict_proba()</code> returns the probabilities (proba is short for probability) of a classification label.</p> In\u00a0[101]: Copied! <pre># Return probabilities rather than labels\nclf.predict_proba(X_test[:5])\n</pre> # Return probabilities rather than labels clf.predict_proba(X_test[:5]) Out[101]: <pre>array([[0.89, 0.11],\n       [0.49, 0.51],\n       [0.43, 0.57],\n       [0.84, 0.16],\n       [0.18, 0.82]])</pre> <p>Let's see the difference.</p> In\u00a0[102]: Copied! <pre># Return labels\nclf.predict(X_test[:5])\n</pre> # Return labels clf.predict(X_test[:5]) Out[102]: <pre>array([0, 1, 1, 0, 1])</pre> <p><code>predict_proba()</code> returns an array of five arrays each containing two values.</p> <p>Each number is the probability of a label given a sample.</p> In\u00a0[103]: Copied! <pre># Find prediction probabilities for 1 sample\nclf.predict_proba(X_test[:1])\n</pre> # Find prediction probabilities for 1 sample clf.predict_proba(X_test[:1]) Out[103]: <pre>array([[0.89, 0.11]])</pre> <p>This output means for the sample <code>X_test[:1]</code>, the model is predicting label 0 (index 0) with a probability score of 0.9.</p> <p>Because the highest probability score is at index <code>0</code> (and it's over 0.5), when using <code>predict()</code>, a label of <code>0</code> is assigned.</p> In\u00a0[104]: Copied! <pre># Return the label for 1 sample\nclf.predict(X_test[:1])\n</pre> # Return the label for 1 sample clf.predict(X_test[:1]) Out[104]: <pre>array([0])</pre> <p>Where does 0.5 come from?</p> <p>Because our problem is a binary classification task (heart disease or not heart disease), predicting a label with 0.5 probability every time would be the same as a coin toss (guessing 50/50 every time).</p> <p>Therefore, once the prediction probability of a sample passes 0.5 for a certain label, it's assigned that label.</p> <p><code>predict()</code> can also be used for regression models.</p> In\u00a0[105]: Copied! <pre># Import the RandomForestRegressor model class from the ensemble module\nfrom sklearn.ensemble import RandomForestRegressor\n\n# Setup random seed\nnp.random.seed(42)\n\n# Split the data into features (X) and labels (y)\nX = housing_df.drop(\"target\", axis=1)\ny = housing_df[\"target\"]\n\n# Split into train and test sets\nX_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2)\n\n# Institate and fit the model (on the training set)\nmodel = RandomForestRegressor()\nmodel.fit(X_train, y_train)\n\n# Make predictions\ny_preds = model.predict(X_test)\n</pre> # Import the RandomForestRegressor model class from the ensemble module from sklearn.ensemble import RandomForestRegressor  # Setup random seed np.random.seed(42)  # Split the data into features (X) and labels (y) X = housing_df.drop(\"target\", axis=1) y = housing_df[\"target\"]  # Split into train and test sets X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2)  # Institate and fit the model (on the training set) model = RandomForestRegressor() model.fit(X_train, y_train)  # Make predictions y_preds = model.predict(X_test) <p>Now we can evaluate our regression model by using <code>sklearn.metrics.mean_absolute_error</code> which returns the average error across all samples.</p> In\u00a0[106]: Copied! <pre># Compare the predictions to the truth\nfrom sklearn.metrics import mean_absolute_error\nmean_absolute_error(y_test, y_preds)\n</pre> # Compare the predictions to the truth from sklearn.metrics import mean_absolute_error mean_absolute_error(y_test, y_preds) Out[106]: <pre>np.float64(0.3270458119670544)</pre> <p>Now we've seen how to get a model how to find patterns in data using the <code>fit()</code> function and make predictions using what its learned using the <code>predict()</code> and <code>predict_proba()</code> functions, it's time to evaluate those predictions.</p> In\u00a0[107]: Copied! <pre># Import the RandomForestClassifier model class from the ensemble module\nfrom sklearn.ensemble import RandomForestClassifier\n\n# Setup random seed\nnp.random.seed(42)\n\n# Split the data into X (features/data) and y (target/labels)\nX = heart_disease.drop(\"target\", axis=1)\ny = heart_disease[\"target\"]\n\n# Split into train and test sets\nX_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2)\n\n# Instantiate the model (on the training set)\nclf = RandomForestClassifier(n_estimators=100)\n\n# Call the fit method on the model and pass it training data\nclf.fit(X_train, y_train);\n</pre> # Import the RandomForestClassifier model class from the ensemble module from sklearn.ensemble import RandomForestClassifier  # Setup random seed np.random.seed(42)  # Split the data into X (features/data) and y (target/labels) X = heart_disease.drop(\"target\", axis=1) y = heart_disease[\"target\"]  # Split into train and test sets X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2)  # Instantiate the model (on the training set) clf = RandomForestClassifier(n_estimators=100)  # Call the fit method on the model and pass it training data clf.fit(X_train, y_train); <p>Once the model has been fit on the training data (<code>X_train</code>, <code>y_train</code>), we can call the <code>score()</code> method on it and evaluate our model on the test data, data the model has never seen before (<code>X_test</code>, <code>y_test</code>).</p> In\u00a0[108]: Copied! <pre># Check the score of the model (on the test set)\nclf.score(X_test, y_test)\n</pre> # Check the score of the model (on the test set) clf.score(X_test, y_test) Out[108]: <pre>0.8524590163934426</pre> <p>Each model in Scikit-Learn implements a default metric for <code>score()</code> which is suitable for the problem.</p> <p>For example:</p> <ul> <li>Classifier models generally use <code>metrics.accuracy_score()</code> as the default <code>score()</code> metric.</li> <li>Regression models generally use <code>metrics.r2_score</code> as the default <code>score()</code> metric.</li> <li>There many more classification and regression specific metrics implemented in <code>sklearn.metrics</code>.</li> </ul> <p>Because <code>clf</code> is an instance of <code>RandomForestClassifier</code>, the <code>score()</code> method uses mean accuracy as its score method.</p> <p>You can find this by pressing SHIFT + TAB (inside a Jupyter Notebook, may be different elsewhere) within the brackets of <code>score()</code> when called on a model instance.</p> <p>Behind the scenes, <code>score()</code> makes predictions on <code>X_test</code> using the trained model and then compares those predictions to the actual labels <code>y_test</code>.</p> <p>A classification model which predicts everything 100% correct would receive an accuracy score of 1.0 (or 100%).</p> <p>Our model doesn't get everything correct, but at ~85% accuracy (0.85 * 100), it's still far better than guessing.</p> <p>Let's do the same but with the regression code from above.</p> In\u00a0[109]: Copied! <pre># Import the RandomForestRegressor model class from the ensemble module\nfrom sklearn.ensemble import RandomForestRegressor\n\n# Setup random seed\nnp.random.seed(42)\n\n# Split the data into features (X) and labels (y)\nX = housing_df.drop(\"target\", axis=1)\ny = housing_df[\"target\"]\n\n# Split into train and test sets\nX_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2)\n\n# Institate and fit the model (on the training set)\nmodel = RandomForestRegressor()\nmodel.fit(X_train, y_train);\n</pre> # Import the RandomForestRegressor model class from the ensemble module from sklearn.ensemble import RandomForestRegressor  # Setup random seed np.random.seed(42)  # Split the data into features (X) and labels (y) X = housing_df.drop(\"target\", axis=1) y = housing_df[\"target\"]  # Split into train and test sets X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2)  # Institate and fit the model (on the training set) model = RandomForestRegressor() model.fit(X_train, y_train); <p>Due to the consistent design of the Scikit-Learn library, we can call the same <code>score()</code> method on <code>model</code>.</p> In\u00a0[110]: Copied! <pre># Check the score of the model (on the test set)\nmodel.score(X_test, y_test)\n</pre> # Check the score of the model (on the test set) model.score(X_test, y_test) Out[110]: <pre>0.8059809073051385</pre> <p>Here, <code>model</code> is an instance of <code>RandomForestRegressor</code>.</p> <p>And since it's a regression model, the default metric built into <code>score()</code> is the coefficient of determination or R^2 (pronounced R-sqaured).</p> <p>Remember, you can find this by pressing SHIFT + TAB within the brackets of <code>score()</code> when called on a model instance.</p> <p>The best possible value here is 1.0, this means the model predicts the target regression values exactly.</p> <p>Calling the <code>score()</code> method on any model instance and passing it test data is a good quick way to see how your model is going.</p> <p>However, when you get further into a problem, it's likely you'll want to start using more powerful metrics to evaluate your models performance.</p> In\u00a0[111]: Copied! <pre># Import cross_val_score from the model_selection module\nfrom sklearn.model_selection import cross_val_score\n\n# Import the RandomForestClassifier model class from the ensemble module\nfrom sklearn.ensemble import RandomForestClassifier\n\n# Setup random seed\nnp.random.seed(42)\n\n# Split the data into X (features/data) and y (target/labels)\nX = heart_disease.drop(\"target\", axis=1)\ny = heart_disease[\"target\"]\n\n# Split into train and test sets\nX_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2)\n\n# Instantiate the model (on the training set)\nclf = RandomForestClassifier(n_estimators=100)\n\n# Call the fit method on the model and pass it training data\nclf.fit(X_train, y_train);\n</pre> # Import cross_val_score from the model_selection module from sklearn.model_selection import cross_val_score  # Import the RandomForestClassifier model class from the ensemble module from sklearn.ensemble import RandomForestClassifier  # Setup random seed np.random.seed(42)  # Split the data into X (features/data) and y (target/labels) X = heart_disease.drop(\"target\", axis=1) y = heart_disease[\"target\"]  # Split into train and test sets X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2)  # Instantiate the model (on the training set) clf = RandomForestClassifier(n_estimators=100)  # Call the fit method on the model and pass it training data clf.fit(X_train, y_train); <p>Using <code>cross_val_score()</code> is slightly different to <code>score()</code>.</p> <p>Let's see a code example first and then we'll go through the details.</p> In\u00a0[112]: Copied! <pre># Using score()\nclf.score(X_test, y_test)\n</pre> # Using score() clf.score(X_test, y_test) Out[112]: <pre>0.8524590163934426</pre> In\u00a0[113]: Copied! <pre># Using cross_val_score()\ncross_val_score(clf, X, y, cv=5) # cv = number of splits to test (5 by default)\n</pre> # Using cross_val_score() cross_val_score(clf, X, y, cv=5) # cv = number of splits to test (5 by default) Out[113]: <pre>array([0.81967213, 0.86885246, 0.81967213, 0.78333333, 0.76666667])</pre> <p>What's happening here?</p> <p>The first difference you might notice is <code>cross_val_score()</code> returns an array where as <code>score()</code> only returns a single number.</p> <p><code>cross_val_score()</code> returns an array because of a parameter called <code>cv</code>, which stands for cross-validation.</p> <p>When <code>cv</code> isn't set, <code>cross_val_score()</code> will return an array of 5 numbers by default (<code>cv=None</code> is the same as setting <code>cv=5</code>).</p> <p>Remember, you can see the parameters of a function using SHIFT + TAB (inside a Jupyter Notebook) from within the brackets.</p> <p>But wait, you might be thinking, what even is cross-validation?</p> <p>A visual might be able to help.</p> <p>We've dealt with Figure 1.0 before using <code>score(X_test, y_test)</code>.</p> <p>But looking deeper into this, if a model is trained using the training data or 80% of samples, this means 20% of samples aren't used for the model to learn anything.</p> <p>This also means depending on what 80% is used to train on and what 20% is used to evaluate the model, it may achieve a score which doesn't reflect the entire dataset.</p> <p>For example, if a lot of easy examples are in the 80% training data, when it comes to test on the 20%, your model may perform poorly.</p> <p>The same goes for the reverse.</p> <p>Figure 2.0 shows 5-fold cross-validation, a method which tries to provide a solution to:</p> <ol> <li>Not training on all the data (always keeping training and test sets separate).</li> <li>Avoiding getting lucky scores on single splits of the data.</li> </ol> <p>Instead of training only on 1 training split and evaluating on 1 testing split, 5-fold cross-validation does it 5 times.</p> <p>On a different split each time, returning a score for each.</p> <p>Why 5-fold?</p> <p>The actual name of this setup K-fold cross-validation. Where K is an abitrary number. We've used 5 because it looks nice visually, and it is the default value in <code>sklearn.model_selection.cross_val_score</code>.</p> <p>Figure 2.0 is what happens when we run the following.</p> In\u00a0[114]: Copied! <pre># 5-fold cross-validation\ncross_val_score(clf, X, y, cv=5) # cv is equivalent to K\n</pre> # 5-fold cross-validation cross_val_score(clf, X, y, cv=5) # cv is equivalent to K Out[114]: <pre>array([0.83606557, 0.8852459 , 0.7704918 , 0.8       , 0.8       ])</pre> <p>Since we set <code>cv=5</code> (5-fold cross-validation), we get back 5 different scores instead of 1.</p> <p>Taking the mean of this array gives us a more in-depth idea of how our model is performing by converting the 5 scores into one.</p> In\u00a0[115]: Copied! <pre>np.random.seed(42)\n\n# Single training and test split score\nclf_single_score = clf.score(X_test, y_test)\n\n# Take mean of 5-fold cross-validation\nclf_cross_val_score = np.mean(cross_val_score(clf, X, y, cv=5))\n\nclf_single_score, clf_cross_val_score\n</pre> np.random.seed(42)  # Single training and test split score clf_single_score = clf.score(X_test, y_test)  # Take mean of 5-fold cross-validation clf_cross_val_score = np.mean(cross_val_score(clf, X, y, cv=5))  clf_single_score, clf_cross_val_score Out[115]: <pre>(0.8524590163934426, np.float64(0.8248087431693989))</pre> <p>Notice, the average <code>cross_val_score()</code> is slightly lower than single value returned by <code>score()</code>.</p> <p>In this case, if you were asked to report the accuracy of your model, even though it's lower, you'd prefer the cross-validated metric over the non-cross-validated metric.</p> <p>Wait?</p> <p>We haven't used the <code>scoring</code> parameter at all.</p> <p>By default, it's set to <code>None</code>.</p> In\u00a0[116]: Copied! <pre>cross_val_score(clf, X, y, cv=5, scoring=None) # default scoring value, this can be set to other scoring metrics\n</pre> cross_val_score(clf, X, y, cv=5, scoring=None) # default scoring value, this can be set to other scoring metrics Out[116]: <pre>array([0.78688525, 0.86885246, 0.80327869, 0.78333333, 0.76666667])</pre> <p>Note: If you notice different scores each time you call <code>cross_val_score</code>, this is because each data split is random every time. So the model may achieve higher/lower scores on different splits of the data. To get reproducible scores, you can set the random seed.</p> <p>When <code>scoring</code> is set to <code>None</code> (by default), it uses the same metric as <code>score()</code> for whatever model is passed to <code>cross_val_score()</code>.</p> <p>In this case, our model is <code>clf</code> which is an instance of <code>RandomForestClassifier</code> which uses mean accuracy as the default <code>score()</code> metric.</p> <p>You can change the evaluation score <code>cross_val_score()</code> uses by changing the <code>scoring</code> parameter.</p> <p>And as you might have guessed, different problems call for different evaluation scores.</p> <p>The Scikit-Learn documentation outlines a vast range of evaluation metrics for different problems but let's have a look at a few.</p> In\u00a0[117]: Copied! <pre># Import cross_val_score from the model_selection module\nfrom sklearn.model_selection import cross_val_score\nfrom sklearn.ensemble import RandomForestClassifier\n\nnp.random.seed(42)\n\nX = heart_disease.drop(\"target\", axis=1)\ny = heart_disease[\"target\"]\n\nX_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2)\n\nclf = RandomForestClassifier()\nclf.fit(X_train, y_train)\nclf.score(X_test, y_test)\n</pre> # Import cross_val_score from the model_selection module from sklearn.model_selection import cross_val_score from sklearn.ensemble import RandomForestClassifier  np.random.seed(42)  X = heart_disease.drop(\"target\", axis=1) y = heart_disease[\"target\"]  X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2)  clf = RandomForestClassifier() clf.fit(X_train, y_train) clf.score(X_test, y_test) Out[117]: <pre>0.8524590163934426</pre> In\u00a0[118]: Copied! <pre># Accuracy as percentage\nprint(f\"Heart Disease Classifier Accuracy: {clf.score(X_test, y_test) * 100:.2f}%\")\n</pre> # Accuracy as percentage print(f\"Heart Disease Classifier Accuracy: {clf.score(X_test, y_test) * 100:.2f}%\") <pre>Heart Disease Classifier Accuracy: 85.25%\n</pre> In\u00a0[119]: Copied! <pre>from sklearn.metrics import roc_curve\n\n# Make predictions with probabilities\ny_probs = clf.predict_proba(X_test)\n\n# Keep the probabilites of the positive class only\ny_probs = y_probs[:, 1]\n\n# Calculate fpr, tpr and thresholds\nfpr, tpr, thresholds = roc_curve(y_test, y_probs)\n\n# Check the false positive rate\nfpr\n</pre> from sklearn.metrics import roc_curve  # Make predictions with probabilities y_probs = clf.predict_proba(X_test)  # Keep the probabilites of the positive class only y_probs = y_probs[:, 1]  # Calculate fpr, tpr and thresholds fpr, tpr, thresholds = roc_curve(y_test, y_probs)  # Check the false positive rate fpr Out[119]: <pre>array([0.        , 0.        , 0.        , 0.        , 0.        ,\n       0.03448276, 0.03448276, 0.03448276, 0.03448276, 0.06896552,\n       0.06896552, 0.10344828, 0.13793103, 0.13793103, 0.17241379,\n       0.17241379, 0.27586207, 0.4137931 , 0.48275862, 0.55172414,\n       0.65517241, 0.72413793, 0.72413793, 0.82758621, 1.        ])</pre> <p>Looking at these on their own doesn't make much sense. It's much easier to see their value visually.</p> <p>Let's create a helper function to make a ROC curve given the false positive rates (<code>fpr</code>) and true positive rates (<code>tpr</code>).</p> <p>Note: As of Scikit-Learn 1.2+, there is functionality of plotting a ROC curve. You can find this under <code>sklearn.metrics.RocCurveDisplay</code>.</p> In\u00a0[120]: Copied! <pre>import matplotlib.pyplot as plt\n\ndef plot_roc_curve(fpr, tpr):\n    \"\"\"\n    Plots a ROC curve given the false positve rate (fpr) and \n    true postive rate (tpr) of a classifier.\n    \"\"\"\n    # Plot ROC curve\n    plt.plot(fpr, tpr, color='orange', label='ROC')\n    # Plot line with no predictive power (baseline)\n    plt.plot([0, 1], [0, 1], color='darkblue', linestyle='--', label='Guessing')\n    # Customize the plot\n    plt.xlabel('False Positive Rate')\n    plt.ylabel('True Positive Rate')\n    plt.title('Receiver Operating Characteristic (ROC) Curve')\n    plt.legend()\n    plt.show()\n    \nplot_roc_curve(fpr, tpr)\n</pre> import matplotlib.pyplot as plt  def plot_roc_curve(fpr, tpr):     \"\"\"     Plots a ROC curve given the false positve rate (fpr) and      true postive rate (tpr) of a classifier.     \"\"\"     # Plot ROC curve     plt.plot(fpr, tpr, color='orange', label='ROC')     # Plot line with no predictive power (baseline)     plt.plot([0, 1], [0, 1], color='darkblue', linestyle='--', label='Guessing')     # Customize the plot     plt.xlabel('False Positive Rate')     plt.ylabel('True Positive Rate')     plt.title('Receiver Operating Characteristic (ROC) Curve')     plt.legend()     plt.show()      plot_roc_curve(fpr, tpr) <p>Looking at the plot for the first time, it might seem a bit confusing.</p> <p>The main thing to take away here is our model is doing far better than guessing.</p> <p>A metric you can use to quantify the ROC curve in a single number is AUC (Area Under Curve).</p> <p>Scikit-Learn implements a function to caculate this called <code>sklearn.metrics.roc_auc_score</code>.</p> <p>The maximum ROC AUC score you can achieve is 1.0 and generally, the closer to 1.0, the better the model.</p> In\u00a0[122]: Copied! <pre>from sklearn.metrics import roc_auc_score\n\nroc_auc_score_value = roc_auc_score(y_test, y_probs)\nroc_auc_score_value\n</pre> from sklearn.metrics import roc_auc_score  roc_auc_score_value = roc_auc_score(y_test, y_probs) roc_auc_score_value Out[122]: <pre>np.float64(0.9304956896551724)</pre> <p>I'll let you in a secret...</p> <p>Although it was good practice, we didn't actually need to create our own <code>plot_roc_curve</code> function.</p> <p>Scikit-Learn allows us to plot a ROC curve directly from our estimator/model by using the class method <code>sklearn.metrics.RocCurveDisplay.from_estimator</code> and passing it our <code>estimator</code>, <code>X_test</code> and <code>y_test</code>.</p> In\u00a0[123]: Copied! <pre>from sklearn.metrics import RocCurveDisplay\nroc_curve_display = RocCurveDisplay.from_estimator(estimator=clf, \n                                                   X=X_test, \n                                                   y=y_test)\n</pre> from sklearn.metrics import RocCurveDisplay roc_curve_display = RocCurveDisplay.from_estimator(estimator=clf,                                                     X=X_test,                                                     y=y_test) <p>The most ideal position for a ROC curve to run along the top left corner of the plot.</p> <p>This would mean the model predicts only true positives and no false positives. And would result in a ROC AUC score of 1.0.</p> <p>You can see this by creating a ROC curve using only the <code>y_test</code> labels.</p> In\u00a0[124]: Copied! <pre># Plot perfect ROC curve\nfpr, tpr, thresholds = roc_curve(y_test, y_test)\nplot_roc_curve(fpr, tpr)\n</pre> # Plot perfect ROC curve fpr, tpr, thresholds = roc_curve(y_test, y_test) plot_roc_curve(fpr, tpr) In\u00a0[125]: Copied! <pre># Perfect ROC AUC score\nroc_auc_score(y_test, y_test)\n</pre> # Perfect ROC AUC score roc_auc_score(y_test, y_test) Out[125]: <pre>np.float64(1.0)</pre> <p>In reality, a perfect ROC curve is unlikely.</p> In\u00a0[126]: Copied! <pre>from sklearn.metrics import confusion_matrix\n\ny_preds = clf.predict(X_test)\n\nconfusion_matrix(y_test, y_preds)\n</pre> from sklearn.metrics import confusion_matrix  y_preds = clf.predict(X_test)  confusion_matrix(y_test, y_preds) Out[126]: <pre>array([[24,  5],\n       [ 4, 28]])</pre> <p>Again, this is probably easier visualized.</p> <p>One way to do it is with <code>pd.crosstab()</code>.</p> In\u00a0[127]: Copied! <pre>pd.crosstab(y_test, \n            y_preds, \n            rownames=[\"Actual Label\"], \n            colnames=[\"Predicted Label\"])\n</pre> pd.crosstab(y_test,              y_preds,              rownames=[\"Actual Label\"],              colnames=[\"Predicted Label\"]) Out[127]: Predicted Label 0 1 Actual Label 0 24 5 1 4 28 In\u00a0[128]: Copied! <pre>from sklearn.metrics import ConfusionMatrixDisplay\n\nConfusionMatrixDisplay.from_estimator(estimator=clf, X=X, y=y);\n</pre> from sklearn.metrics import ConfusionMatrixDisplay  ConfusionMatrixDisplay.from_estimator(estimator=clf, X=X, y=y); In\u00a0[129]: Copied! <pre># Plot confusion matrix from predictions\nConfusionMatrixDisplay.from_predictions(y_true=y_test, \n                                        y_pred=y_preds);\n</pre> # Plot confusion matrix from predictions ConfusionMatrixDisplay.from_predictions(y_true=y_test,                                          y_pred=y_preds); In\u00a0[130]: Copied! <pre>from sklearn.metrics import classification_report\n\nprint(classification_report(y_test, y_preds))\n</pre> from sklearn.metrics import classification_report  print(classification_report(y_test, y_preds)) <pre>              precision    recall  f1-score   support\n\n           0       0.86      0.83      0.84        29\n           1       0.85      0.88      0.86        32\n\n    accuracy                           0.85        61\n   macro avg       0.85      0.85      0.85        61\nweighted avg       0.85      0.85      0.85        61\n\n</pre> <p>It returns four columns: precision, recall, f1-score and support.</p> <p>The number of rows will depend on how many different classes there are. But there will always be three rows labell accuracy, macro avg and weighted avg.</p> <p>Each term measures something slightly different:</p> <ul> <li>Precision - Indicates the proportion of positive identifications (model predicted class <code>1</code>) which were actually correct. A model which produces no false positives has a precision of 1.0.</li> <li>Recall - Indicates the proportion of actual positives which were correctly classified. A model which produces no false negatives has a recall of 1.0.</li> <li>F1 score - A combination of precision and recall. A perfect model achieves an F1 score of 1.0.</li> <li>Support - The number of samples each metric was calculated on.</li> <li>Accuracy - The accuracy of the model in decimal form. Perfect accuracy is equal to 1.0, in other words, getting the prediction right 100% of the time.</li> <li>Macro avg - Short for macro average, the average precision, recall and F1 score between classes. Macro avg doesn't take class imbalance into effect. So if you do have class imbalances (more examples of one class than another), you should pay attention to this.</li> <li>Weighted avg - Short for weighted average, the weighted average precision, recall and F1 score between classes. Weighted means each metric is calculated with respect to how many samples there are in each class. This metric will favour the majority class (e.g. it will give a high value when one class out performs another due to having more samples).</li> </ul> <p>When should you use each?</p> <p>It can be tempting to base your classification models perfomance only on accuracy. And accuracy is a good metric to report, except when you have very imbalanced classes.</p> <p>For example, let's say there were 10,000 people. And 1 of them had a disease. You're asked to build a model to predict who has it.</p> <p>You build the model and find your model to be 99.99% accurate. Which sounds great! ...until you realise, all its doing is predicting no one has the disease, in other words all 10,000 predictions are false.</p> <p>In this case, you'd want to turn to metrics such as precision, recall and F1 score.</p> In\u00a0[131]: Copied! <pre># Where precision and recall become valuable\ndisease_true = np.zeros(10000)\ndisease_true[0] = 1 # only one case\n\ndisease_preds = np.zeros(10000) # every prediction is 0\n\npd.DataFrame(classification_report(disease_true, \n                                   disease_preds, \n                                   output_dict=True,\n                                   zero_division=0))\n</pre> # Where precision and recall become valuable disease_true = np.zeros(10000) disease_true[0] = 1 # only one case  disease_preds = np.zeros(10000) # every prediction is 0  pd.DataFrame(classification_report(disease_true,                                     disease_preds,                                     output_dict=True,                                    zero_division=0)) Out[131]: 0.0 1.0 accuracy macro avg weighted avg precision 0.99990 0.0 0.9999 0.499950 0.99980 recall 1.00000 0.0 0.9999 0.500000 0.99990 f1-score 0.99995 0.0 0.9999 0.499975 0.99985 support 9999.00000 1.0 0.9999 10000.000000 10000.00000 <p>You can see here, we've got an accuracy of 0.9999 (99.99%), great precision and recall on class 0.0 but nothing for class 1.0.</p> <p>Ask yourself, although the model achieves 99.99% accuracy, is it useful?</p> <p>To summarize:</p> <ul> <li>Accuracy is a good measure to start with if all classes are balanced (e.g. same amount of samples which are labelled with 0 or 1)</li> <li>Precision and recall become more important when classes are imbalanced.</li> <li>If false positive predictions are worse than false negatives, aim for higher precision.</li> <li>If false negative predictions are worse than false positives, aim for higher recall.</li> </ul> <p>Resource: For more on precision and recall and the tradeoffs between them, I'd suggest going through the Scikit-Learn Precision-Recall guide.</p> In\u00a0[132]: Copied! <pre># Import the RandomForestRegressor model class from the ensemble module\nfrom sklearn.ensemble import RandomForestRegressor\n\n# Setup random seed\nnp.random.seed(42)\n\n# Split data into features (X) and labels (y)\nX = housing_df.drop(\"target\", axis=1)\ny = housing_df[\"target\"]\n\n# Split into train and test sets\nX_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2)\n\n# Institate and fit the model (on the training set)\nmodel = RandomForestRegressor()\nmodel.fit(X_train, y_train);\n</pre> # Import the RandomForestRegressor model class from the ensemble module from sklearn.ensemble import RandomForestRegressor  # Setup random seed np.random.seed(42)  # Split data into features (X) and labels (y) X = housing_df.drop(\"target\", axis=1) y = housing_df[\"target\"]  # Split into train and test sets X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2)  # Institate and fit the model (on the training set) model = RandomForestRegressor() model.fit(X_train, y_train); <p>R^2 Score (coefficient of determination)</p> <p>Once you've got a trained regression model, the default evaluation metric in the <code>score()</code> function is R^2.</p> In\u00a0[133]: Copied! <pre># Calculate the models R^2 score\nmodel.score(X_test, y_test)\n</pre> # Calculate the models R^2 score model.score(X_test, y_test) Out[133]: <pre>0.8059809073051385</pre> <p>Outside of the <code>score()</code> function, R^2 can be calculated using Scikit-Learn's <code>r2_score()</code> function.</p> <p>A model which only predicted the mean would get a score of 0.</p> In\u00a0[134]: Copied! <pre>from sklearn.metrics import r2_score\n\n# Fill an array with y_test mean\ny_test_mean = np.full(len(y_test), y_test.mean())\n\nr2_score(y_test, y_test_mean)\n</pre> from sklearn.metrics import r2_score  # Fill an array with y_test mean y_test_mean = np.full(len(y_test), y_test.mean())  r2_score(y_test, y_test_mean) Out[134]: <pre>0.0</pre> <p>And a perfect model would get a score of 1.</p> In\u00a0[135]: Copied! <pre>r2_score(y_test, y_test)\n</pre> r2_score(y_test, y_test) Out[135]: <pre>1.0</pre> <p>For your regression models, you'll want to maximise R^2, whilst minimising MAE and MSE.</p> <p>Mean Absolute Error (MAE)</p> <p>A model's mean absolute error can be calculated with Scikit-Learn's <code>sklearn.metrics.mean_absolute_error</code> method.</p> In\u00a0[136]: Copied! <pre># Mean absolute error\nfrom sklearn.metrics import mean_absolute_error\n\ny_preds = model.predict(X_test)\nmae = mean_absolute_error(y_test, y_preds)\nmae\n</pre> # Mean absolute error from sklearn.metrics import mean_absolute_error  y_preds = model.predict(X_test) mae = mean_absolute_error(y_test, y_preds) mae Out[136]: <pre>np.float64(0.3270458119670544)</pre> <p>Our model achieves an MAE of 0.327.</p> <p>This means, on average our models predictions are 0.327 units away from the actual value.</p> <p>Let's make it a little more visual.</p> In\u00a0[137]: Copied! <pre>df = pd.DataFrame(data={\"actual values\": y_test, \n                   \"predictions\": y_preds})\n\ndf\n</pre> df = pd.DataFrame(data={\"actual values\": y_test,                     \"predictions\": y_preds})  df Out[137]: actual values predictions 20046 0.47700 0.490580 3024 0.45800 0.759890 15663 5.00001 4.935016 20484 2.18600 2.558640 9814 2.78000 2.334610 ... ... ... 15362 2.63300 2.225000 16623 2.66800 1.972540 18086 5.00001 4.853989 2144 0.72300 0.714910 3665 1.51500 1.665680 <p>4128 rows \u00d7 2 columns</p> <p>You can see the predictions are slightly different to the actual values.</p> <p>Depending what problem you're working on, having a difference like we do now, might be okay. On the flip side, it may also not be okay, meaning the predictions would have to be closer.</p> In\u00a0[138]: Copied! <pre>fig, ax = plt.subplots()\nx = np.arange(0, len(df), 1)\nax.scatter(x, df[\"actual values\"], c='b', label=\"Acutual Values\")\nax.scatter(x, df[\"predictions\"], c='r', label=\"Predictions\")\nax.legend(loc=(1, 0.5));\n</pre> fig, ax = plt.subplots() x = np.arange(0, len(df), 1) ax.scatter(x, df[\"actual values\"], c='b', label=\"Acutual Values\") ax.scatter(x, df[\"predictions\"], c='r', label=\"Predictions\") ax.legend(loc=(1, 0.5)); <p>Mean Squared Error (MSE)</p> <p>How about MSE?</p> <p>We can calculate it with Scikit-Learn's <code>sklearn.metrics.mean_squared_error</code>.</p> In\u00a0[139]: Copied! <pre># Mean squared error\nfrom sklearn.metrics import mean_squared_error\n\nmse = mean_squared_error(y_test, y_preds)\nmse\n</pre> # Mean squared error from sklearn.metrics import mean_squared_error  mse = mean_squared_error(y_test, y_preds) mse Out[139]: <pre>np.float64(0.2542443610174998)</pre> <p>MSE will often be higher than MAE because is squares the errors rather than only taking the absolute difference into account.</p> <p>Now you might be thinking, which regression evaluation metric should you use?</p> <ul> <li>R^2 is similar to accuracy. It gives you a quick indication of how well your model might be doing. Generally, the closer your R^2 value is to 1.0, the better the model. But it doesn't really tell exactly how wrong your model is in terms of how far off each prediction is.</li> <li>MAE gives a better indication of how far off each of your model's predictions are on average.</li> <li>As for MAE or MSE, because of the way MSE is calculated, squaring the differences between predicted values and actual values, it amplifies larger differences. Let's say we're predicting the value of houses (which we are).<ul> <li>Pay more attention to MAE: When being $10,000 off is twice as bad as being $5,000 off.</li> <li>Pay more attention to MSE: When being $10,000 off is more than twice as bad as being $5,000 off.</li> </ul> </li> </ul> <p>Note: What we've covered here is only a handful of potential metrics you can use to evaluate your models. If you're after a complete list, check out the Scikit-Learn metrics and scoring documentation.</p> In\u00a0[140]: Copied! <pre>from sklearn.model_selection import cross_val_score\nfrom sklearn.ensemble import RandomForestClassifier\n\nnp.random.seed(42)\n\nX = heart_disease.drop(\"target\", axis=1)\ny = heart_disease[\"target\"]\n\nclf = RandomForestClassifier(n_estimators=100)\n</pre> from sklearn.model_selection import cross_val_score from sklearn.ensemble import RandomForestClassifier  np.random.seed(42)  X = heart_disease.drop(\"target\", axis=1) y = heart_disease[\"target\"]  clf = RandomForestClassifier(n_estimators=100) <p>First, we'll use the default, which is mean accuracy.</p> In\u00a0[141]: Copied! <pre>np.random.seed(42)\ncv_acc = cross_val_score(clf, X, y, cv=5)\ncv_acc\n</pre> np.random.seed(42) cv_acc = cross_val_score(clf, X, y, cv=5) cv_acc Out[141]: <pre>array([0.81967213, 0.90163934, 0.83606557, 0.78333333, 0.78333333])</pre> <p>We've seen this before, now we got 5 different accuracy scores on different test splits of the data.</p> <p>Averaging this gives the cross-validated accuracy.</p> In\u00a0[142]: Copied! <pre># Cross-validated accuracy\nprint(f\"The cross-validated accuracy is: {np.mean(cv_acc)*100:.2f}%\")\n</pre> # Cross-validated accuracy print(f\"The cross-validated accuracy is: {np.mean(cv_acc)*100:.2f}%\") <pre>The cross-validated accuracy is: 82.48%\n</pre> <p>We can find the same using the <code>scoring</code> parameter and passing it <code>\"accuracy\"</code>.</p> In\u00a0[143]: Copied! <pre>np.random.seed(42)\ncv_acc = cross_val_score(clf, X, y, cv=5, scoring=\"accuracy\")\nprint(f\"The cross-validated accuracy is: {np.mean(cv_acc)*100:.2f}%\")\n</pre> np.random.seed(42) cv_acc = cross_val_score(clf, X, y, cv=5, scoring=\"accuracy\") print(f\"The cross-validated accuracy is: {np.mean(cv_acc)*100:.2f}%\") <pre>The cross-validated accuracy is: 82.48%\n</pre> <p>The same goes for the other metrics we've been using for classification.</p> <p>Let's try <code>\"precision\"</code>.</p> In\u00a0[144]: Copied! <pre>np.random.seed(42)\ncv_precision = cross_val_score(clf, X, y, cv=5, scoring=\"precision\")\nprint(f\"The cross-validated precision is: {np.mean(cv_precision):.2f}\")\n</pre> np.random.seed(42) cv_precision = cross_val_score(clf, X, y, cv=5, scoring=\"precision\") print(f\"The cross-validated precision is: {np.mean(cv_precision):.2f}\") <pre>The cross-validated precision is: 0.83\n</pre> <p>How about <code>\"recall\"</code>?</p> In\u00a0[145]: Copied! <pre>np.random.seed(42)\ncv_recall = cross_val_score(clf, X, y, cv=5, scoring=\"recall\")\nprint(f\"The cross-validated recall is: {np.mean(cv_recall):.2f}\")\n</pre> np.random.seed(42) cv_recall = cross_val_score(clf, X, y, cv=5, scoring=\"recall\") print(f\"The cross-validated recall is: {np.mean(cv_recall):.2f}\") <pre>The cross-validated recall is: 0.85\n</pre> <p>And <code>\"f1\"</code> (for F1 score)?</p> In\u00a0[146]: Copied! <pre>np.random.seed(42)\ncv_f1 = cross_val_score(clf, X, y, cv=5, scoring=\"f1\")\nprint(f\"The cross-validated F1 score is: {np.mean(cv_f1):.2f}\")\n</pre> np.random.seed(42) cv_f1 = cross_val_score(clf, X, y, cv=5, scoring=\"f1\") print(f\"The cross-validated F1 score is: {np.mean(cv_f1):.2f}\") <pre>The cross-validated F1 score is: 0.84\n</pre> <p>We can repeat this process with our regression metrics.</p> <p>Let's revisit our regression model.</p> In\u00a0[147]: Copied! <pre>from sklearn.model_selection import cross_val_score\nfrom sklearn.ensemble import RandomForestRegressor\n\nnp.random.seed(42)\n\nX = housing_df.drop(\"target\", axis=1)\ny = housing_df[\"target\"]\n\nmodel = RandomForestRegressor(n_estimators=100)\n</pre> from sklearn.model_selection import cross_val_score from sklearn.ensemble import RandomForestRegressor  np.random.seed(42)  X = housing_df.drop(\"target\", axis=1) y = housing_df[\"target\"]  model = RandomForestRegressor(n_estimators=100) <p>The default is <code>\"r2\"</code>.</p> <p>Note: We can time how long a single cell of code takes to run using the <code>%%time</code> magic command.</p> In\u00a0[150]: Copied! <pre>%%time \nnp.random.seed(42)\ncv_r2 = cross_val_score(model, X, y, cv=5, scoring=\"r2\")\nprint(f\"The cross-validated R^2 score is: {np.mean(cv_r2):.2f}\")\n</pre> %%time  np.random.seed(42) cv_r2 = cross_val_score(model, X, y, cv=5, scoring=\"r2\") print(f\"The cross-validated R^2 score is: {np.mean(cv_r2):.2f}\") <pre>The cross-validated R^2 score is: 0.65\nCPU times: user 40.5 s, sys: 286 ms, total: 40.8 s\nWall time: 41.6 s\n</pre> <p>But we can use <code>\"neg_mean_absolute_error\"</code> for MAE (mean absolute error).</p> In\u00a0[151]: Copied! <pre>%%time\nnp.random.seed(42)\ncv_mae = cross_val_score(model, X, y, cv=5, scoring=\"neg_mean_absolute_error\")\nprint(f\"The cross-validated MAE score is: {np.mean(cv_mae):.2f}\")\n</pre> %%time np.random.seed(42) cv_mae = cross_val_score(model, X, y, cv=5, scoring=\"neg_mean_absolute_error\") print(f\"The cross-validated MAE score is: {np.mean(cv_mae):.2f}\") <pre>The cross-validated MAE score is: -0.47\nCPU times: user 40.4 s, sys: 246 ms, total: 40.7 s\nWall time: 41.6 s\n</pre> <p>Why the <code>\"neg_\"</code>?</p> <p>Because Scikit-Learn documentation states:</p> <p>\"All scorer objects follow the convention that higher return values are better than lower return values.\"</p> <p>Which in this case, means a lower negative value (closer to 0) is better.</p> <p>What about <code>\"neg_mean_squared_error\"</code> for MSE (mean squared error)?</p> In\u00a0[159]: Copied! <pre>np.random.seed(42)\ncv_mse = cross_val_score(model, \n                         X, \n                         y, \n                         cv=5,\n                         scoring=\"neg_mean_squared_error\")\nprint(f\"The cross-validated MSE score is: {np.mean(cv_mse):.2f}\")\n</pre> np.random.seed(42) cv_mse = cross_val_score(model,                           X,                           y,                           cv=5,                          scoring=\"neg_mean_squared_error\") print(f\"The cross-validated MSE score is: {np.mean(cv_mse):.2f}\") <pre>The cross-validated MSE score is: -0.43\n</pre> In\u00a0[160]: Copied! <pre>from sklearn.metrics import accuracy_score, precision_score, recall_score, f1_score\nfrom sklearn.ensemble import RandomForestClassifier\nfrom sklearn.model_selection import train_test_split\n\nnp.random.seed(42)\n\nX = heart_disease.drop(\"target\", axis=1)\ny = heart_disease[\"target\"]\n\nX_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2)\n\nclf = RandomForestClassifier(n_estimators=100)\nclf.fit(X_train, y_train)\n\n# Make predictions\ny_preds = clf.predict(X_test)\n\n# Evaluate the classifier\nprint(\"Classifier metrics on the test set:\")\nprint(f\"Accuracy: {accuracy_score(y_test, y_preds) * 100:.2f}%\")\nprint(f\"Precision: {precision_score(y_test, y_preds):.2f}\")\nprint(f\"Recall: {recall_score(y_test, y_preds):.2f}\")\nprint(f\"F1: {f1_score(y_test, y_preds):.2f}\")\n</pre> from sklearn.metrics import accuracy_score, precision_score, recall_score, f1_score from sklearn.ensemble import RandomForestClassifier from sklearn.model_selection import train_test_split  np.random.seed(42)  X = heart_disease.drop(\"target\", axis=1) y = heart_disease[\"target\"]  X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2)  clf = RandomForestClassifier(n_estimators=100) clf.fit(X_train, y_train)  # Make predictions y_preds = clf.predict(X_test)  # Evaluate the classifier print(\"Classifier metrics on the test set:\") print(f\"Accuracy: {accuracy_score(y_test, y_preds) * 100:.2f}%\") print(f\"Precision: {precision_score(y_test, y_preds):.2f}\") print(f\"Recall: {recall_score(y_test, y_preds):.2f}\") print(f\"F1: {f1_score(y_test, y_preds):.2f}\") <pre>Classifier metrics on the test set:\nAccuracy: 85.25%\nPrecision: 0.85\nRecall: 0.88\nF1: 0.86\n</pre> In\u00a0[161]: Copied! <pre>from sklearn.metrics import r2_score, mean_absolute_error, mean_squared_error\nfrom sklearn.ensemble import RandomForestRegressor\nfrom sklearn.model_selection import train_test_split\n\nnp.random.seed(42)\n\nX = housing_df.drop(\"target\", axis=1)\ny = housing_df[\"target\"]\n\nX_train, X_test, y_train, y_test = train_test_split(X, \n                                                    y, \n                                                    test_size=0.2)\n\nmodel = RandomForestRegressor(n_estimators=100, \n                              n_jobs=-1)\nmodel.fit(X_train, y_train)\n\n# Make predictions\ny_preds = model.predict(X_test)\n\n# Evaluate the model\nprint(\"Regression model metrics on the test set:\")\nprint(f\"R^2: {r2_score(y_test, y_preds):.2f}\")\nprint(f\"MAE: {mean_absolute_error(y_test, y_preds):.2f}\")\nprint(f\"MSE: {mean_squared_error(y_test, y_preds):.2f}\")\n</pre> from sklearn.metrics import r2_score, mean_absolute_error, mean_squared_error from sklearn.ensemble import RandomForestRegressor from sklearn.model_selection import train_test_split  np.random.seed(42)  X = housing_df.drop(\"target\", axis=1) y = housing_df[\"target\"]  X_train, X_test, y_train, y_test = train_test_split(X,                                                      y,                                                      test_size=0.2)  model = RandomForestRegressor(n_estimators=100,                                n_jobs=-1) model.fit(X_train, y_train)  # Make predictions y_preds = model.predict(X_test)  # Evaluate the model print(\"Regression model metrics on the test set:\") print(f\"R^2: {r2_score(y_test, y_preds):.2f}\") print(f\"MAE: {mean_absolute_error(y_test, y_preds):.2f}\") print(f\"MSE: {mean_squared_error(y_test, y_preds):.2f}\") <pre>Regression model metrics on the test set:\nR^2: 0.81\nMAE: 0.33\nMSE: 0.25\n</pre> <p>Wow!</p> <p>We've covered a lot!</p> <p>But it's worth it.</p> <p>Because evaluating a model's predictions is as important as training a model in any machine learning project.</p> <p>There's nothing worse than training a machine learning model and optimizing for the wrong evaluation metric.</p> <p>Keep the metrics and evaluation methods we've gone through when training your future models.</p> <p>If you're after extra reading, I'd go through the Scikit-Learn guide for model evaluation.</p> <p>Now we've seen some different metrics we can use to evaluate a model, let's see some ways we can improve those metrics.</p> In\u00a0[162]: Copied! <pre>from sklearn.ensemble import RandomForestClassifier\n\nclf = RandomForestClassifier()\n</pre> from sklearn.ensemble import RandomForestClassifier  clf = RandomForestClassifier() <p>When we instantiate a model like above, we're using the default hyperparameters.</p> <p>These get printed out when you call the model instance and <code>get_params()</code>.</p> In\u00a0[163]: Copied! <pre>clf.get_params()\n</pre> clf.get_params() Out[163]: <pre>{'bootstrap': True,\n 'ccp_alpha': 0.0,\n 'class_weight': None,\n 'criterion': 'gini',\n 'max_depth': None,\n 'max_features': 'sqrt',\n 'max_leaf_nodes': None,\n 'max_samples': None,\n 'min_impurity_decrease': 0.0,\n 'min_samples_leaf': 1,\n 'min_samples_split': 2,\n 'min_weight_fraction_leaf': 0.0,\n 'monotonic_cst': None,\n 'n_estimators': 100,\n 'n_jobs': None,\n 'oob_score': False,\n 'random_state': None,\n 'verbose': 0,\n 'warm_start': False}</pre> <p>You'll see things like <code>max_depth</code>, <code>min_samples_split</code>, <code>n_estimators</code>.</p> <p>Each of these is a hyperparameter of the <code>RandomForestClassifier</code> you can adjust.</p> <p>You can think of hyperparameters as being similar to dials on an oven.</p> <p>On the default setting your oven might do an okay job cooking your favourite meal. But with a little experimentation, you find it does better when you adjust the settings.</p> <p>The same goes for imporving a machine learning model by hyperparameter tuning.</p> <p>The default hyperparameters on a machine learning model may find patterns in data well. But there's a chance a adjusting the hyperparameters may improve a models performance.</p> <p>Every machine learning model will have different hyperparameters you can tune.</p> <p>You might be thinking, \"how the hell do I remember all of these?\"</p> <p>Another good question.</p> <p>It's why we're focused on the Random Forest.</p> <p>Instead of memorizing all of the hyperparameters for every model, we'll see how it's done with one.</p> <p>And then knowing these principles, you can apply them to a different model if needed.</p> <p>Reading the Scikit-Learn documentation for the Random Forest, you'll find they suggest trying to change <code>n_estimators</code> (the number of trees in the forest) and <code>min_samples_split</code> (the minimum number of samples required to split an internal node).</p> <p>We'll try tuning these as well as:</p> <ul> <li><code>max_features</code> (the number of features to consider when looking for the best split)</li> <li><code>max_depth</code> (the maximum depth of the tree)</li> <li><code>min_samples_leaf</code> (the minimum number of samples required to be at a leaf node)</li> </ul> <p>If this still sounds like a lot, the good news is, the process we're taking with the Random Forest and tuning its hyperparameters, can be used for other machine learning models in Scikit-Learn. The only difference is, with a different model, the hyperparameters you tune will be different.</p> <p>Adjusting hyperparameters is usually an experimental process to figure out which are best. As there's no real way of knowing which hyperparameters will be best when starting out.</p> <p>To get familar with hyparameter tuning, we'll take our RandomForestClassifier and adjust its hyperparameters in 3 ways.</p> <ol> <li>By hand</li> <li>Randomly with <code>sklearn.model_selection.RandomizedSearchCV</code></li> <li>Exhaustively with <code>sklearn.model_selection.GridSearchCV</code></li> </ol> In\u00a0[164]: Copied! <pre>clf.get_params()\n</pre> clf.get_params() Out[164]: <pre>{'bootstrap': True,\n 'ccp_alpha': 0.0,\n 'class_weight': None,\n 'criterion': 'gini',\n 'max_depth': None,\n 'max_features': 'sqrt',\n 'max_leaf_nodes': None,\n 'max_samples': None,\n 'min_impurity_decrease': 0.0,\n 'min_samples_leaf': 1,\n 'min_samples_split': 2,\n 'min_weight_fraction_leaf': 0.0,\n 'monotonic_cst': None,\n 'n_estimators': 100,\n 'n_jobs': None,\n 'oob_score': False,\n 'random_state': None,\n 'verbose': 0,\n 'warm_start': False}</pre> <p>And we're going to adjust:</p> <ul> <li><code>max_depth</code></li> <li><code>max_features</code></li> <li><code>min_samples_leaf</code></li> <li><code>min_samples_split</code></li> <li><code>n_estimators</code></li> </ul> <p>We'll use the same code as before, except this time we'll create a training, validation and test split.</p> <p>With the training set containing 70% of the data and the validation and test sets each containing 15%.</p> <p>Let's get some baseline results, then we'll tune the model.</p> <p>And since we're going to be evaluating a few models, let's make an evaluation function.</p> In\u00a0[165]: Copied! <pre>def evaluate_preds(y_true: np.array, \n                   y_preds: np.array) -&gt; dict:\n    \"\"\"\n    Performs evaluation comparison on y_true labels vs. y_pred labels.\n\n    Returns several metrics in the form of a dictionary.\n    \"\"\"\n    accuracy = accuracy_score(y_true, y_preds)\n    precision = precision_score(y_true, y_preds)\n    recall = recall_score(y_true, y_preds)\n    f1 = f1_score(y_true, y_preds)\n    metric_dict = {\"accuracy\": round(accuracy, 2),\n                   \"precision\": round(precision, 2), \n                   \"recall\": round(recall, 2),\n                   \"f1\": round(f1, 2)}\n    print(f\"Acc: {accuracy * 100:.2f}%\")\n    print(f\"Precision: {precision:.2f}\")\n    print(f\"Recall: {recall:.2f}\")\n    print(f\"F1 score: {f1:.2f}\")\n\n    return metric_dict\n</pre> def evaluate_preds(y_true: np.array,                     y_preds: np.array) -&gt; dict:     \"\"\"     Performs evaluation comparison on y_true labels vs. y_pred labels.      Returns several metrics in the form of a dictionary.     \"\"\"     accuracy = accuracy_score(y_true, y_preds)     precision = precision_score(y_true, y_preds)     recall = recall_score(y_true, y_preds)     f1 = f1_score(y_true, y_preds)     metric_dict = {\"accuracy\": round(accuracy, 2),                    \"precision\": round(precision, 2),                     \"recall\": round(recall, 2),                    \"f1\": round(f1, 2)}     print(f\"Acc: {accuracy * 100:.2f}%\")     print(f\"Precision: {precision:.2f}\")     print(f\"Recall: {recall:.2f}\")     print(f\"F1 score: {f1:.2f}\")      return metric_dict <p>Wonderful!</p> <p>Now let's recreate a previous workflow, except we'll add in the creation of a validation set.</p> In\u00a0[166]: Copied! <pre>from sklearn.metrics import accuracy_score, precision_score, recall_score, f1_score\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.ensemble import RandomForestClassifier\n\n# Set the seed\nnp.random.seed(42)\n\n# Read in the data\n# heart_disease = pd.read_csv(\"../data/heart-disease.csv\") # load in from local directory\nheart_disease = pd.read_csv(\"https://raw.githubusercontent.com/mrdbourke/zero-to-mastery-ml/master/data/heart-disease.csv\") # load directly from URL (source: https://github.com/mrdbourke/zero-to-mastery-ml/blob/master/data/heart-disease.csv)\n\n# Split into X (features) &amp; y (labels)\nX = heart_disease.drop(\"target\", axis=1)\ny = heart_disease[\"target\"]\n\n# Training and test split (70% train, 30% test)\nX_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3)\n\n# Create validation and test split by spliting testing data in half (30% test -&gt; 15% validation, 15% test)\nX_valid, X_test, y_valid, y_test = train_test_split(X_test, y_test, test_size=0.5)\n\nclf = RandomForestClassifier()\nclf.fit(X_train, y_train)\n\n# Make predictions\ny_preds = clf.predict(X_valid)\n\n# Evaluate the classifier\nbaseline_metrics = evaluate_preds(y_valid, y_preds)\nbaseline_metrics\n</pre> from sklearn.metrics import accuracy_score, precision_score, recall_score, f1_score from sklearn.model_selection import train_test_split from sklearn.ensemble import RandomForestClassifier  # Set the seed np.random.seed(42)  # Read in the data # heart_disease = pd.read_csv(\"../data/heart-disease.csv\") # load in from local directory heart_disease = pd.read_csv(\"https://raw.githubusercontent.com/mrdbourke/zero-to-mastery-ml/master/data/heart-disease.csv\") # load directly from URL (source: https://github.com/mrdbourke/zero-to-mastery-ml/blob/master/data/heart-disease.csv)  # Split into X (features) &amp; y (labels) X = heart_disease.drop(\"target\", axis=1) y = heart_disease[\"target\"]  # Training and test split (70% train, 30% test) X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3)  # Create validation and test split by spliting testing data in half (30% test -&gt; 15% validation, 15% test) X_valid, X_test, y_valid, y_test = train_test_split(X_test, y_test, test_size=0.5)  clf = RandomForestClassifier() clf.fit(X_train, y_train)  # Make predictions y_preds = clf.predict(X_valid)  # Evaluate the classifier baseline_metrics = evaluate_preds(y_valid, y_preds) baseline_metrics <pre>Acc: 80.00%\nPrecision: 0.78\nRecall: 0.88\nF1 score: 0.82\n</pre> Out[166]: <pre>{'accuracy': 0.8,\n 'precision': np.float64(0.78),\n 'recall': np.float64(0.88),\n 'f1': np.float64(0.82)}</pre> In\u00a0[167]: Copied! <pre># Check the sizes of the splits\nprint(f\"Training data: {len(X_train)} samples, {len(y_train)} labels\")\nprint(f\"Validation data: {len(X_valid)} samples, {len(y_valid)} labels\")\nprint(f\"Testing data: {len(X_test)} samples, {len(y_test)} labels\")\n</pre> # Check the sizes of the splits print(f\"Training data: {len(X_train)} samples, {len(y_train)} labels\") print(f\"Validation data: {len(X_valid)} samples, {len(y_valid)} labels\") print(f\"Testing data: {len(X_test)} samples, {len(y_test)} labels\") <pre>Training data: 212 samples, 212 labels\nValidation data: 45 samples, 45 labels\nTesting data: 46 samples, 46 labels\n</pre> <p>Beautiful, now let's try and improve the results.</p> <p>We'll change 1 of the hyperparameters, <code>n_estimators=100</code> (default) to <code>n_estimators=200</code> and see if it improves on the validation set.</p> In\u00a0[168]: Copied! <pre>np.random.seed(42)\n\n# Create a second classifier\nclf_2 = RandomForestClassifier(n_estimators=200)\nclf_2.fit(X_train, y_train)\n\n# Make predictions\ny_preds_2 = clf_2.predict(X_valid)\n\n# Evaluate the 2nd classifier\nclf_2_metrics = evaluate_preds(y_valid, y_preds_2)\n</pre> np.random.seed(42)  # Create a second classifier clf_2 = RandomForestClassifier(n_estimators=200) clf_2.fit(X_train, y_train)  # Make predictions y_preds_2 = clf_2.predict(X_valid)  # Evaluate the 2nd classifier clf_2_metrics = evaluate_preds(y_valid, y_preds_2) <pre>Acc: 77.78%\nPrecision: 0.77\nRecall: 0.83\nF1 score: 0.80\n</pre> <p>Hmm, it looks like doubling the <code>n_estimators</code> value performs worse than the default, perhaps there's a better value for <code>n_estimators</code>?</p> <p>And what other hyperparameters could we change?</p> <p>Wait...</p> <p>This could take a while if all we're doing is building new models with new hyperparameters each time.</p> <p>Surely there's a better way?</p> <p>There is.</p> In\u00a0[169]: Copied! <pre># Hyperparameter grid RandomizedSearchCV will search over\nparam_distributions = {\"n_estimators\": [10, 100, 200, 500, 1000, 1200],\n                       \"max_depth\": [None, 5, 10, 20, 30],\n                       \"max_features\": [\"sqrt\", \"log2\", None],\n                       \"min_samples_split\": [2, 4, 6, 8],\n                       \"min_samples_leaf\": [1, 2, 4, 8]}\n</pre> # Hyperparameter grid RandomizedSearchCV will search over param_distributions = {\"n_estimators\": [10, 100, 200, 500, 1000, 1200],                        \"max_depth\": [None, 5, 10, 20, 30],                        \"max_features\": [\"sqrt\", \"log2\", None],                        \"min_samples_split\": [2, 4, 6, 8],                        \"min_samples_leaf\": [1, 2, 4, 8]} <p>Where did these values come from?</p> <p>They're made up.</p> <p>Made up?</p> <p>Yes.</p> <p>Not completely pulled out of the air but after reading the Scikit-Learn documentation on Random Forest's you'll see some of these values have certain values which usually perform well and certain hyperparameters take strings rather than integers.</p> <p>Now we've got the parameter distribution dictionary setup, Scikit-Learn's <code>RandomizedSearchCV</code> will look at it, pick a random value from each, instantiate a model with those values and test each model.</p> <p>How many models will it test?</p> <p>As many as there are for each combination of hyperparameters to be tested. Let's add them up.</p> In\u00a0[170]: Copied! <pre># Count the total number of hyperparameter combinations to test\ntotal_randomized_hyperparameter_combintions_to_test = np.prod([len(value) for value in param_distributions.values()])\nprint(f\"There are {total_randomized_hyperparameter_combintions_to_test} potential combinations of hyperparameters to test.\")\n</pre> # Count the total number of hyperparameter combinations to test total_randomized_hyperparameter_combintions_to_test = np.prod([len(value) for value in param_distributions.values()]) print(f\"There are {total_randomized_hyperparameter_combintions_to_test} potential combinations of hyperparameters to test.\") <pre>There are 1440 potential combinations of hyperparameters to test.\n</pre> <p>Woah!</p> <p>That's a lot of combinations!</p> <p>Or...</p> <p>We can set the <code>n_iter</code> parameter to limit the number of models <code>RandomizedSearchCV</code> tests (e.g. <code>n_iter=20</code> means to try <code>20</code> different random combintations of hyperparameters and will cross-validate each set, so if <code>cv=5</code>, 5x20 = 100 total fits).</p> <p>The best thing?</p> <p>The results we get will be cross-validated (hence the CV in <code>RandomizedSearchCV</code>) so we can use <code>train_test_split()</code>.</p> <p>And since we're going over so many different models, we'll set <code>n_jobs=-1</code> in our <code>RandomForestClassifier</code> so Scikit-Learn takes advantage of all the cores (processors) on our computers.</p> <p>Let's see it in action.</p> <p>Note: Depending on <code>n_iter</code> (how many models you test), the different values in the hyperparameter grid, and the power of your computer, running the cell below may take a while (for reference, it took about ~1-minute on my M1 Pro MacBook Pro).</p> In\u00a0[171]: Copied! <pre># Start the timer\nimport time\nstart_time = time.time()\n\nfrom sklearn.model_selection import RandomizedSearchCV, train_test_split\n\nnp.random.seed(42)\n\n# Split into X &amp; y\nX = heart_disease.drop(\"target\", axis=1)\ny = heart_disease[\"target\"]\n\n# Split into train and test sets\nX_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2)\n\n# Set n_jobs to -1 to use all available cores on your machine (if this causes errors, try n_jobs=1)\nclf = RandomForestClassifier(n_jobs=-1)\n\n# Setup RandomizedSearchCV \nn_iter = 30 # try 30 models total\nrs_clf = RandomizedSearchCV(estimator=clf,\n                            param_distributions=param_distributions,\n                            n_iter=n_iter, \n                            cv=5, # 5-fold cross-validation\n                            verbose=2) # print out results\n\n# Fit the RandomizedSearchCV version of clf (does cross-validation for us, so no need to use a validation set)\nrs_clf.fit(X_train, y_train);\n\n# Finish the timer\nend_time = time.time()\nprint(f\"[INFO] Total time taken for {n_iter} random combinations of hyperparameters: {end_time - start_time:.2f} seconds.\")\n</pre> # Start the timer import time start_time = time.time()  from sklearn.model_selection import RandomizedSearchCV, train_test_split  np.random.seed(42)  # Split into X &amp; y X = heart_disease.drop(\"target\", axis=1) y = heart_disease[\"target\"]  # Split into train and test sets X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2)  # Set n_jobs to -1 to use all available cores on your machine (if this causes errors, try n_jobs=1) clf = RandomForestClassifier(n_jobs=-1)  # Setup RandomizedSearchCV  n_iter = 30 # try 30 models total rs_clf = RandomizedSearchCV(estimator=clf,                             param_distributions=param_distributions,                             n_iter=n_iter,                              cv=5, # 5-fold cross-validation                             verbose=2) # print out results  # Fit the RandomizedSearchCV version of clf (does cross-validation for us, so no need to use a validation set) rs_clf.fit(X_train, y_train);  # Finish the timer end_time = time.time() print(f\"[INFO] Total time taken for {n_iter} random combinations of hyperparameters: {end_time - start_time:.2f} seconds.\") <pre>Fitting 5 folds for each of 30 candidates, totalling 150 fits\n[CV] END max_depth=30, max_features=log2, min_samples_leaf=4, min_samples_split=6, n_estimators=200; total time=   0.1s\n[CV] END max_depth=30, max_features=log2, min_samples_leaf=4, min_samples_split=6, n_estimators=200; total time=   0.1s\n[CV] END max_depth=30, max_features=log2, min_samples_leaf=4, min_samples_split=6, n_estimators=200; total time=   0.1s\n[CV] END max_depth=30, max_features=log2, min_samples_leaf=4, min_samples_split=6, n_estimators=200; total time=   0.1s\n[CV] END max_depth=30, max_features=log2, min_samples_leaf=4, min_samples_split=6, n_estimators=200; total time=   0.1s\n[CV] END max_depth=10, max_features=None, min_samples_leaf=8, min_samples_split=2, n_estimators=500; total time=   0.3s\n[CV] END max_depth=10, max_features=None, min_samples_leaf=8, min_samples_split=2, n_estimators=500; total time=   0.3s\n[CV] END max_depth=10, max_features=None, min_samples_leaf=8, min_samples_split=2, n_estimators=500; total time=   0.3s\n[CV] END max_depth=10, max_features=None, min_samples_leaf=8, min_samples_split=2, n_estimators=500; total time=   0.3s\n[CV] END max_depth=10, max_features=None, min_samples_leaf=8, min_samples_split=2, n_estimators=500; total time=   0.3s\n[CV] END max_depth=5, max_features=None, min_samples_leaf=1, min_samples_split=4, n_estimators=10; total time=   0.0s\n[CV] END max_depth=5, max_features=None, min_samples_leaf=1, min_samples_split=4, n_estimators=10; total time=   0.0s\n[CV] END max_depth=5, max_features=None, min_samples_leaf=1, min_samples_split=4, n_estimators=10; total time=   0.0s\n[CV] END max_depth=5, max_features=None, min_samples_leaf=1, min_samples_split=4, n_estimators=10; total time=   0.0s\n[CV] END max_depth=5, max_features=None, min_samples_leaf=1, min_samples_split=4, n_estimators=10; total time=   0.0s\n[CV] END max_depth=5, max_features=log2, min_samples_leaf=2, min_samples_split=8, n_estimators=100; total time=   0.1s\n[CV] END max_depth=5, max_features=log2, min_samples_leaf=2, min_samples_split=8, n_estimators=100; total time=   0.1s\n[CV] END max_depth=5, max_features=log2, min_samples_leaf=2, min_samples_split=8, n_estimators=100; total time=   0.1s\n[CV] END max_depth=5, max_features=log2, min_samples_leaf=2, min_samples_split=8, n_estimators=100; total time=   0.1s\n[CV] END max_depth=5, max_features=log2, min_samples_leaf=2, min_samples_split=8, n_estimators=100; total time=   0.1s\n[CV] END max_depth=10, max_features=log2, min_samples_leaf=2, min_samples_split=4, n_estimators=200; total time=   0.1s\n[CV] END max_depth=10, max_features=log2, min_samples_leaf=2, min_samples_split=4, n_estimators=200; total time=   0.1s\n[CV] END max_depth=10, max_features=log2, min_samples_leaf=2, min_samples_split=4, n_estimators=200; total time=   0.2s\n[CV] END max_depth=10, max_features=log2, min_samples_leaf=2, min_samples_split=4, n_estimators=200; total time=   0.1s\n[CV] END max_depth=10, max_features=log2, min_samples_leaf=2, min_samples_split=4, n_estimators=200; total time=   0.1s\n[CV] END max_depth=10, max_features=log2, min_samples_leaf=8, min_samples_split=6, n_estimators=10; total time=   0.0s\n[CV] END max_depth=10, max_features=log2, min_samples_leaf=8, min_samples_split=6, n_estimators=10; total time=   0.0s\n[CV] END max_depth=10, max_features=log2, min_samples_leaf=8, min_samples_split=6, n_estimators=10; total time=   0.0s\n[CV] END max_depth=10, max_features=log2, min_samples_leaf=8, min_samples_split=6, n_estimators=10; total time=   0.0s\n[CV] END max_depth=10, max_features=log2, min_samples_leaf=8, min_samples_split=6, n_estimators=10; total time=   0.0s\n[CV] END max_depth=30, max_features=sqrt, min_samples_leaf=8, min_samples_split=4, n_estimators=1200; total time=   0.7s\n[CV] END max_depth=30, max_features=sqrt, min_samples_leaf=8, min_samples_split=4, n_estimators=1200; total time=   0.7s\n[CV] END max_depth=30, max_features=sqrt, min_samples_leaf=8, min_samples_split=4, n_estimators=1200; total time=   0.7s\n[CV] END max_depth=30, max_features=sqrt, min_samples_leaf=8, min_samples_split=4, n_estimators=1200; total time=   0.8s\n[CV] END max_depth=30, max_features=sqrt, min_samples_leaf=8, min_samples_split=4, n_estimators=1200; total time=   0.7s\n[CV] END max_depth=10, max_features=sqrt, min_samples_leaf=1, min_samples_split=4, n_estimators=10; total time=   0.0s\n[CV] END max_depth=10, max_features=sqrt, min_samples_leaf=1, min_samples_split=4, n_estimators=10; total time=   0.0s\n[CV] END max_depth=10, max_features=sqrt, min_samples_leaf=1, min_samples_split=4, n_estimators=10; total time=   0.0s\n[CV] END max_depth=10, max_features=sqrt, min_samples_leaf=1, min_samples_split=4, n_estimators=10; total time=   0.0s\n[CV] END max_depth=10, max_features=sqrt, min_samples_leaf=1, min_samples_split=4, n_estimators=10; total time=   0.0s\n[CV] END max_depth=20, max_features=log2, min_samples_leaf=8, min_samples_split=6, n_estimators=100; total time=   0.1s\n[CV] END max_depth=20, max_features=log2, min_samples_leaf=8, min_samples_split=6, n_estimators=100; total time=   0.1s\n[CV] END max_depth=20, max_features=log2, min_samples_leaf=8, min_samples_split=6, n_estimators=100; total time=   0.1s\n[CV] END max_depth=20, max_features=log2, min_samples_leaf=8, min_samples_split=6, n_estimators=100; total time=   0.1s\n[CV] END max_depth=20, max_features=log2, min_samples_leaf=8, min_samples_split=6, n_estimators=100; total time=   0.1s\n[CV] END max_depth=5, max_features=log2, min_samples_leaf=8, min_samples_split=4, n_estimators=10; total time=   0.0s\n[CV] END max_depth=5, max_features=log2, min_samples_leaf=8, min_samples_split=4, n_estimators=10; total time=   0.0s\n[CV] END max_depth=5, max_features=log2, min_samples_leaf=8, min_samples_split=4, n_estimators=10; total time=   0.0s\n[CV] END max_depth=5, max_features=log2, min_samples_leaf=8, min_samples_split=4, n_estimators=10; total time=   0.0s\n[CV] END max_depth=5, max_features=log2, min_samples_leaf=8, min_samples_split=4, n_estimators=10; total time=   0.0s\n[CV] END max_depth=20, max_features=None, min_samples_leaf=4, min_samples_split=6, n_estimators=1000; total time=   0.6s\n[CV] END max_depth=20, max_features=None, min_samples_leaf=4, min_samples_split=6, n_estimators=1000; total time=   0.6s\n[CV] END max_depth=20, max_features=None, min_samples_leaf=4, min_samples_split=6, n_estimators=1000; total time=   0.6s\n[CV] END max_depth=20, max_features=None, min_samples_leaf=4, min_samples_split=6, n_estimators=1000; total time=   0.6s\n[CV] END max_depth=20, max_features=None, min_samples_leaf=4, min_samples_split=6, n_estimators=1000; total time=   0.6s\n[CV] END max_depth=None, max_features=None, min_samples_leaf=4, min_samples_split=4, n_estimators=1200; total time=   0.7s\n[CV] END max_depth=None, max_features=None, min_samples_leaf=4, min_samples_split=4, n_estimators=1200; total time=   0.7s\n[CV] END max_depth=None, max_features=None, min_samples_leaf=4, min_samples_split=4, n_estimators=1200; total time=   0.8s\n[CV] END max_depth=None, max_features=None, min_samples_leaf=4, min_samples_split=4, n_estimators=1200; total time=   0.8s\n[CV] END max_depth=None, max_features=None, min_samples_leaf=4, min_samples_split=4, n_estimators=1200; total time=   0.7s\n[CV] END max_depth=5, max_features=None, min_samples_leaf=2, min_samples_split=8, n_estimators=1000; total time=   0.6s\n[CV] END max_depth=5, max_features=None, min_samples_leaf=2, min_samples_split=8, n_estimators=1000; total time=   0.6s\n[CV] END max_depth=5, max_features=None, min_samples_leaf=2, min_samples_split=8, n_estimators=1000; total time=   0.6s\n[CV] END max_depth=5, max_features=None, min_samples_leaf=2, min_samples_split=8, n_estimators=1000; total time=   0.6s\n[CV] END max_depth=5, max_features=None, min_samples_leaf=2, min_samples_split=8, n_estimators=1000; total time=   0.6s\n[CV] END max_depth=5, max_features=sqrt, min_samples_leaf=2, min_samples_split=6, n_estimators=10; total time=   0.0s\n[CV] END max_depth=5, max_features=sqrt, min_samples_leaf=2, min_samples_split=6, n_estimators=10; total time=   0.0s\n[CV] END max_depth=5, max_features=sqrt, min_samples_leaf=2, min_samples_split=6, n_estimators=10; total time=   0.0s\n[CV] END max_depth=5, max_features=sqrt, min_samples_leaf=2, min_samples_split=6, n_estimators=10; total time=   0.0s\n[CV] END max_depth=5, max_features=sqrt, min_samples_leaf=2, min_samples_split=6, n_estimators=10; total time=   0.0s\n[CV] END max_depth=20, max_features=None, min_samples_leaf=2, min_samples_split=8, n_estimators=1200; total time=   0.8s\n[CV] END max_depth=20, max_features=None, min_samples_leaf=2, min_samples_split=8, n_estimators=1200; total time=   0.7s\n[CV] END max_depth=20, max_features=None, min_samples_leaf=2, min_samples_split=8, n_estimators=1200; total time=   0.8s\n[CV] END max_depth=20, max_features=None, min_samples_leaf=2, min_samples_split=8, n_estimators=1200; total time=   0.7s\n[CV] END max_depth=20, max_features=None, min_samples_leaf=2, min_samples_split=8, n_estimators=1200; total time=   0.7s\n[CV] END max_depth=20, max_features=sqrt, min_samples_leaf=8, min_samples_split=2, n_estimators=1000; total time=   0.6s\n[CV] END max_depth=20, max_features=sqrt, min_samples_leaf=8, min_samples_split=2, n_estimators=1000; total time=   0.7s\n[CV] END max_depth=20, max_features=sqrt, min_samples_leaf=8, min_samples_split=2, n_estimators=1000; total time=   0.6s\n[CV] END max_depth=20, max_features=sqrt, min_samples_leaf=8, min_samples_split=2, n_estimators=1000; total time=   0.6s\n[CV] END max_depth=20, max_features=sqrt, min_samples_leaf=8, min_samples_split=2, n_estimators=1000; total time=   0.6s\n[CV] END max_depth=30, max_features=sqrt, min_samples_leaf=2, min_samples_split=6, n_estimators=10; total time=   0.0s\n[CV] END max_depth=30, max_features=sqrt, min_samples_leaf=2, min_samples_split=6, n_estimators=10; total time=   0.0s\n[CV] END max_depth=30, max_features=sqrt, min_samples_leaf=2, min_samples_split=6, n_estimators=10; total time=   0.0s\n[CV] END max_depth=30, max_features=sqrt, min_samples_leaf=2, min_samples_split=6, n_estimators=10; total time=   0.0s\n[CV] END max_depth=30, max_features=sqrt, min_samples_leaf=2, min_samples_split=6, n_estimators=10; total time=   0.0s\n[CV] END max_depth=20, max_features=sqrt, min_samples_leaf=4, min_samples_split=6, n_estimators=100; total time=   0.1s\n[CV] END max_depth=20, max_features=sqrt, min_samples_leaf=4, min_samples_split=6, n_estimators=100; total time=   0.1s\n[CV] END max_depth=20, max_features=sqrt, min_samples_leaf=4, min_samples_split=6, n_estimators=100; total time=   0.1s\n[CV] END max_depth=20, max_features=sqrt, min_samples_leaf=4, min_samples_split=6, n_estimators=100; total time=   0.1s\n[CV] END max_depth=20, max_features=sqrt, min_samples_leaf=4, min_samples_split=6, n_estimators=100; total time=   0.1s\n[CV] END max_depth=20, max_features=None, min_samples_leaf=4, min_samples_split=8, n_estimators=500; total time=   0.3s\n[CV] END max_depth=20, max_features=None, min_samples_leaf=4, min_samples_split=8, n_estimators=500; total time=   0.3s\n[CV] END max_depth=20, max_features=None, min_samples_leaf=4, min_samples_split=8, n_estimators=500; total time=   0.3s\n[CV] END max_depth=20, max_features=None, min_samples_leaf=4, min_samples_split=8, n_estimators=500; total time=   0.3s\n[CV] END max_depth=20, max_features=None, min_samples_leaf=4, min_samples_split=8, n_estimators=500; total time=   0.3s\n[CV] END max_depth=20, max_features=None, min_samples_leaf=1, min_samples_split=4, n_estimators=200; total time=   0.1s\n[CV] END max_depth=20, max_features=None, min_samples_leaf=1, min_samples_split=4, n_estimators=200; total time=   0.1s\n[CV] END max_depth=20, max_features=None, min_samples_leaf=1, min_samples_split=4, n_estimators=200; total time=   0.1s\n[CV] END max_depth=20, max_features=None, min_samples_leaf=1, min_samples_split=4, n_estimators=200; total time=   0.1s\n[CV] END max_depth=20, max_features=None, min_samples_leaf=1, min_samples_split=4, n_estimators=200; total time=   0.1s\n[CV] END max_depth=5, max_features=None, min_samples_leaf=1, min_samples_split=6, n_estimators=500; total time=   0.3s\n[CV] END max_depth=5, max_features=None, min_samples_leaf=1, min_samples_split=6, n_estimators=500; total time=   0.3s\n[CV] END max_depth=5, max_features=None, min_samples_leaf=1, min_samples_split=6, n_estimators=500; total time=   0.3s\n[CV] END max_depth=5, max_features=None, min_samples_leaf=1, min_samples_split=6, n_estimators=500; total time=   0.3s\n[CV] END max_depth=5, max_features=None, min_samples_leaf=1, min_samples_split=6, n_estimators=500; total time=   0.3s\n[CV] END max_depth=30, max_features=sqrt, min_samples_leaf=1, min_samples_split=8, n_estimators=200; total time=   0.1s\n[CV] END max_depth=30, max_features=sqrt, min_samples_leaf=1, min_samples_split=8, n_estimators=200; total time=   0.2s\n[CV] END max_depth=30, max_features=sqrt, min_samples_leaf=1, min_samples_split=8, n_estimators=200; total time=   0.1s\n[CV] END max_depth=30, max_features=sqrt, min_samples_leaf=1, min_samples_split=8, n_estimators=200; total time=   0.1s\n[CV] END max_depth=30, max_features=sqrt, min_samples_leaf=1, min_samples_split=8, n_estimators=200; total time=   0.1s\n[CV] END max_depth=20, max_features=log2, min_samples_leaf=1, min_samples_split=8, n_estimators=10; total time=   0.0s\n[CV] END max_depth=20, max_features=log2, min_samples_leaf=1, min_samples_split=8, n_estimators=10; total time=   0.0s\n[CV] END max_depth=20, max_features=log2, min_samples_leaf=1, min_samples_split=8, n_estimators=10; total time=   0.0s\n[CV] END max_depth=20, max_features=log2, min_samples_leaf=1, min_samples_split=8, n_estimators=10; total time=   0.0s\n[CV] END max_depth=20, max_features=log2, min_samples_leaf=1, min_samples_split=8, n_estimators=10; total time=   0.0s\n[CV] END max_depth=20, max_features=None, min_samples_leaf=1, min_samples_split=8, n_estimators=1000; total time=   0.6s\n[CV] END max_depth=20, max_features=None, min_samples_leaf=1, min_samples_split=8, n_estimators=1000; total time=   0.6s\n[CV] END max_depth=20, max_features=None, min_samples_leaf=1, min_samples_split=8, n_estimators=1000; total time=   0.6s\n[CV] END max_depth=20, max_features=None, min_samples_leaf=1, min_samples_split=8, n_estimators=1000; total time=   0.6s\n[CV] END max_depth=20, max_features=None, min_samples_leaf=1, min_samples_split=8, n_estimators=1000; total time=   0.6s\n[CV] END max_depth=None, max_features=log2, min_samples_leaf=2, min_samples_split=6, n_estimators=200; total time=   0.1s\n[CV] END max_depth=None, max_features=log2, min_samples_leaf=2, min_samples_split=6, n_estimators=200; total time=   0.1s\n[CV] END max_depth=None, max_features=log2, min_samples_leaf=2, min_samples_split=6, n_estimators=200; total time=   0.1s\n[CV] END max_depth=None, max_features=log2, min_samples_leaf=2, min_samples_split=6, n_estimators=200; total time=   0.1s\n[CV] END max_depth=None, max_features=log2, min_samples_leaf=2, min_samples_split=6, n_estimators=200; total time=   0.1s\n[CV] END max_depth=None, max_features=None, min_samples_leaf=1, min_samples_split=8, n_estimators=10; total time=   0.0s\n[CV] END max_depth=None, max_features=None, min_samples_leaf=1, min_samples_split=8, n_estimators=10; total time=   0.0s\n[CV] END max_depth=None, max_features=None, min_samples_leaf=1, min_samples_split=8, n_estimators=10; total time=   0.0s\n[CV] END max_depth=None, max_features=None, min_samples_leaf=1, min_samples_split=8, n_estimators=10; total time=   0.0s\n[CV] END max_depth=None, max_features=None, min_samples_leaf=1, min_samples_split=8, n_estimators=10; total time=   0.0s\n[CV] END max_depth=10, max_features=sqrt, min_samples_leaf=1, min_samples_split=4, n_estimators=100; total time=   0.1s\n[CV] END max_depth=10, max_features=sqrt, min_samples_leaf=1, min_samples_split=4, n_estimators=100; total time=   0.1s\n[CV] END max_depth=10, max_features=sqrt, min_samples_leaf=1, min_samples_split=4, n_estimators=100; total time=   0.1s\n[CV] END max_depth=10, max_features=sqrt, min_samples_leaf=1, min_samples_split=4, n_estimators=100; total time=   0.1s\n[CV] END max_depth=10, max_features=sqrt, min_samples_leaf=1, min_samples_split=4, n_estimators=100; total time=   0.1s\n[CV] END max_depth=20, max_features=sqrt, min_samples_leaf=2, min_samples_split=2, n_estimators=500; total time=   0.3s\n[CV] END max_depth=20, max_features=sqrt, min_samples_leaf=2, min_samples_split=2, n_estimators=500; total time=   0.3s\n[CV] END max_depth=20, max_features=sqrt, min_samples_leaf=2, min_samples_split=2, n_estimators=500; total time=   0.3s\n[CV] END max_depth=20, max_features=sqrt, min_samples_leaf=2, min_samples_split=2, n_estimators=500; total time=   0.3s\n[CV] END max_depth=20, max_features=sqrt, min_samples_leaf=2, min_samples_split=2, n_estimators=500; total time=   0.4s\n[CV] END max_depth=None, max_features=None, min_samples_leaf=8, min_samples_split=4, n_estimators=10; total time=   0.0s\n[CV] END max_depth=None, max_features=None, min_samples_leaf=8, min_samples_split=4, n_estimators=10; total time=   0.0s\n[CV] END max_depth=None, max_features=None, min_samples_leaf=8, min_samples_split=4, n_estimators=10; total time=   0.0s\n[CV] END max_depth=None, max_features=None, min_samples_leaf=8, min_samples_split=4, n_estimators=10; total time=   0.0s\n[CV] END max_depth=None, max_features=None, min_samples_leaf=8, min_samples_split=4, n_estimators=10; total time=   0.0s\n[CV] END max_depth=None, max_features=log2, min_samples_leaf=4, min_samples_split=8, n_estimators=10; total time=   0.0s\n[CV] END max_depth=None, max_features=log2, min_samples_leaf=4, min_samples_split=8, n_estimators=10; total time=   0.0s\n[CV] END max_depth=None, max_features=log2, min_samples_leaf=4, min_samples_split=8, n_estimators=10; total time=   0.0s\n[CV] END max_depth=None, max_features=log2, min_samples_leaf=4, min_samples_split=8, n_estimators=10; total time=   0.0s\n[CV] END max_depth=None, max_features=log2, min_samples_leaf=4, min_samples_split=8, n_estimators=10; total time=   0.0s\n[INFO] Total time taken for 30 random combinations of hyperparameters: 36.02 seconds.\n</pre> <p>When <code>RandomizedSearchCV</code> goes through <code>n_iter</code> combinations of of hyperparameter search space, it stores the best ones in the attribute <code>best_params_</code>.</p> In\u00a0[174]: Copied! <pre># Find the best hyperparameters found by RandomizedSearchCV\nrs_clf.best_params_\n</pre> # Find the best hyperparameters found by RandomizedSearchCV rs_clf.best_params_ Out[174]: <pre>{'n_estimators': 200,\n 'min_samples_split': 6,\n 'min_samples_leaf': 4,\n 'max_features': 'log2',\n 'max_depth': 30}</pre> <p>Now when we call <code>predict()</code> on <code>rs_clf</code> (our <code>RandomizedSearchCV</code> version of our classifier), it'll use the best hyperparameters it found.</p> In\u00a0[175]: Copied! <pre># Make predictions with the best hyperparameters\nrs_y_preds = rs_clf.predict(X_test)\n\n# Evaluate the predictions\nrs_metrics = evaluate_preds(y_test, rs_y_preds)\n</pre> # Make predictions with the best hyperparameters rs_y_preds = rs_clf.predict(X_test)  # Evaluate the predictions rs_metrics = evaluate_preds(y_test, rs_y_preds) <pre>Acc: 85.25%\nPrecision: 0.85\nRecall: 0.88\nF1 score: 0.86\n</pre> <p>Excellent!</p> <p>Thanks to <code>RandomizedSearchCV</code> testing out a bunch of different hyperparameters, we get a nice boost to all of the evaluation metrics for our classification model.</p> In\u00a0[176]: Copied! <pre>param_distributions\n</pre> param_distributions Out[176]: <pre>{'n_estimators': [10, 100, 200, 500, 1000, 1200],\n 'max_depth': [None, 5, 10, 20, 30],\n 'max_features': ['sqrt', 'log2', None],\n 'min_samples_split': [2, 4, 6, 8],\n 'min_samples_leaf': [1, 2, 4, 8]}</pre> <p><code>RandomizedSearchCV</code> tries <code>n_iter</code> combinations of different values.</p> <p>Where as, <code>GridSearchCV</code> will try every single possible combination.</p> <p>And if you remember from before when we did the calculation: <code>max_depth</code> has 4 values, <code>max_features</code> has 2, <code>min_samples_leaf</code> has 3, <code>min_samples_split</code> has 3, <code>n_estimators</code> has 5.</p> <p>That's 4x2x3x3x5 = 360 models!</p> <p>This could take a long time depending on the power of the computer you're using, the amount of data you have and the complexity of the hyperparamters (usually higher values means a more complex model).</p> <p>In our case, the data we're using is relatively small (only ~300 samples).</p> <p>Since we've already tried to find some ideal hyperparameters using <code>RandomizedSearchCV</code>, we'll create another hyperparameter grid based on the <code>best_params_</code> of <code>rs_clf</code> with less options and then try to use <code>GridSearchCV</code> to find a more ideal set.</p> <p>In essence, the workflow could be:</p> <ol> <li>Tune hyperparameters by hand to get a feel of the data/model.</li> <li>Create a large set of hyperparameter distributions and search across them randomly with <code>RandomizedSearchCV</code>.</li> <li>Find the best hyperparameters from 2 and reduce the search space before searching across a smaller subset exhaustively with <code>GridSearchCV</code>.</li> </ol> <p>Note: Based on the <code>best_params_</code> of <code>rs_clf</code> implies the next set of hyperparameters we'll try are roughly in the same range of the best set found by <code>RandomizedSearchCV</code>.</p> In\u00a0[177]: Copied! <pre># Create hyperparameter grid similar to rs_clf.best_params_\nparam_grid = {\"n_estimators\": [200, 1000],\n              \"max_depth\": [30, 40, 50],\n              \"max_features\": [\"log2\"],\n              \"min_samples_split\": [2, 4, 6, 8],\n              \"min_samples_leaf\": [4]}\n</pre> # Create hyperparameter grid similar to rs_clf.best_params_ param_grid = {\"n_estimators\": [200, 1000],               \"max_depth\": [30, 40, 50],               \"max_features\": [\"log2\"],               \"min_samples_split\": [2, 4, 6, 8],               \"min_samples_leaf\": [4]} <p>We've created another grid of hyperparameters to search over, this time with less total.</p> In\u00a0[178]: Copied! <pre># Count the total number of hyperparameter combinations to test\ntotal_grid_search_hyperparameter_combinations_to_test = np.prod([len(value) for value in param_grid.values()])\nprint(f\"There are {total_grid_search_hyperparameter_combinations_to_test} combinations of hyperparameters to test.\")\nprint(f\"This is {total_randomized_hyperparameter_combintions_to_test/total_grid_search_hyperparameter_combinations_to_test} times less\\\n than before (previous: {total_randomized_hyperparameter_combintions_to_test}).\")\n</pre> # Count the total number of hyperparameter combinations to test total_grid_search_hyperparameter_combinations_to_test = np.prod([len(value) for value in param_grid.values()]) print(f\"There are {total_grid_search_hyperparameter_combinations_to_test} combinations of hyperparameters to test.\") print(f\"This is {total_randomized_hyperparameter_combintions_to_test/total_grid_search_hyperparameter_combinations_to_test} times less\\  than before (previous: {total_randomized_hyperparameter_combintions_to_test}).\") <pre>There are 24 combinations of hyperparameters to test.\nThis is 60.0 times less than before (previous: 1440).\n</pre> <p>Now when we run <code>GridSearchCV</code>, passing it our classifier (<code>clf</code>), parameter grid (<code>param_grid</code>) and the number of cross-validation folds we'd like to use (<code>cv=5</code>), it'll create a model with every single combination of hyperparameters, and then cross-validate each 5 times (for example, 36 hyperparameter combinations * 5 = 135 fits in total) and check the results.</p> <p>Note: Depending on the compute power of the machine you're using, the following cell may take a few minutes to run (for reference, it took ~60 seconds on my M1 Pro MacBook Pro).</p> In\u00a0[179]: Copied! <pre># Start the timer\nimport time\nstart_time = time.time()\n\nfrom sklearn.model_selection import GridSearchCV, train_test_split\n\nnp.random.seed(42)\n\n# Split into X &amp; y\nX = heart_disease.drop(\"target\", axis=1)\ny = heart_disease[\"target\"]\n\n# Split into train and test sets\nX_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2)\n\n# Set n_jobs to -1 to use all available machine cores (if this produces errors, try n_jobs=1)\nclf = RandomForestClassifier(n_jobs=-1)\n\n# Setup GridSearchCV\ngs_clf = GridSearchCV(estimator=clf,\n                      param_grid=param_grid,\n                      cv=5, # 5-fold cross-validation\n                      verbose=2) # print out progress\n\n# Fit the RandomizedSearchCV version of clf\ngs_clf.fit(X_train, y_train);\n\n# Find the running time\nend_time = time.time()\n</pre> # Start the timer import time start_time = time.time()  from sklearn.model_selection import GridSearchCV, train_test_split  np.random.seed(42)  # Split into X &amp; y X = heart_disease.drop(\"target\", axis=1) y = heart_disease[\"target\"]  # Split into train and test sets X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2)  # Set n_jobs to -1 to use all available machine cores (if this produces errors, try n_jobs=1) clf = RandomForestClassifier(n_jobs=-1)  # Setup GridSearchCV gs_clf = GridSearchCV(estimator=clf,                       param_grid=param_grid,                       cv=5, # 5-fold cross-validation                       verbose=2) # print out progress  # Fit the RandomizedSearchCV version of clf gs_clf.fit(X_train, y_train);  # Find the running time end_time = time.time() <pre>Fitting 5 folds for each of 24 candidates, totalling 120 fits\n[CV] END max_depth=30, max_features=log2, min_samples_leaf=4, min_samples_split=2, n_estimators=200; total time=   0.2s\n[CV] END max_depth=30, max_features=log2, min_samples_leaf=4, min_samples_split=2, n_estimators=200; total time=   0.1s\n[CV] END max_depth=30, max_features=log2, min_samples_leaf=4, min_samples_split=2, n_estimators=200; total time=   0.1s\n[CV] END max_depth=30, max_features=log2, min_samples_leaf=4, min_samples_split=2, n_estimators=200; total time=   0.1s\n[CV] END max_depth=30, max_features=log2, min_samples_leaf=4, min_samples_split=2, n_estimators=200; total time=   0.1s\n[CV] END max_depth=30, max_features=log2, min_samples_leaf=4, min_samples_split=2, n_estimators=1000; total time=   0.6s\n[CV] END max_depth=30, max_features=log2, min_samples_leaf=4, min_samples_split=2, n_estimators=1000; total time=   0.6s\n[CV] END max_depth=30, max_features=log2, min_samples_leaf=4, min_samples_split=2, n_estimators=1000; total time=   0.5s\n[CV] END max_depth=30, max_features=log2, min_samples_leaf=4, min_samples_split=2, n_estimators=1000; total time=   0.5s\n[CV] END max_depth=30, max_features=log2, min_samples_leaf=4, min_samples_split=2, n_estimators=1000; total time=   0.5s\n[CV] END max_depth=30, max_features=log2, min_samples_leaf=4, min_samples_split=4, n_estimators=200; total time=   0.1s\n[CV] END max_depth=30, max_features=log2, min_samples_leaf=4, min_samples_split=4, n_estimators=200; total time=   0.1s\n[CV] END max_depth=30, max_features=log2, min_samples_leaf=4, min_samples_split=4, n_estimators=200; total time=   0.1s\n[CV] END max_depth=30, max_features=log2, min_samples_leaf=4, min_samples_split=4, n_estimators=200; total time=   0.1s\n[CV] END max_depth=30, max_features=log2, min_samples_leaf=4, min_samples_split=4, n_estimators=200; total time=   0.1s\n[CV] END max_depth=30, max_features=log2, min_samples_leaf=4, min_samples_split=4, n_estimators=1000; total time=   0.6s\n[CV] END max_depth=30, max_features=log2, min_samples_leaf=4, min_samples_split=4, n_estimators=1000; total time=   0.6s\n[CV] END max_depth=30, max_features=log2, min_samples_leaf=4, min_samples_split=4, n_estimators=1000; total time=   0.6s\n[CV] END max_depth=30, max_features=log2, min_samples_leaf=4, min_samples_split=4, n_estimators=1000; total time=   0.5s\n[CV] END max_depth=30, max_features=log2, min_samples_leaf=4, min_samples_split=4, n_estimators=1000; total time=   0.6s\n[CV] END max_depth=30, max_features=log2, min_samples_leaf=4, min_samples_split=6, n_estimators=200; total time=   0.1s\n[CV] END max_depth=30, max_features=log2, min_samples_leaf=4, min_samples_split=6, n_estimators=200; total time=   0.1s\n[CV] END max_depth=30, max_features=log2, min_samples_leaf=4, min_samples_split=6, n_estimators=200; total time=   0.1s\n[CV] END max_depth=30, max_features=log2, min_samples_leaf=4, min_samples_split=6, n_estimators=200; total time=   0.2s\n[CV] END max_depth=30, max_features=log2, min_samples_leaf=4, min_samples_split=6, n_estimators=200; total time=   0.1s\n[CV] END max_depth=30, max_features=log2, min_samples_leaf=4, min_samples_split=6, n_estimators=1000; total time=   0.5s\n[CV] END max_depth=30, max_features=log2, min_samples_leaf=4, min_samples_split=6, n_estimators=1000; total time=   0.6s\n[CV] END max_depth=30, max_features=log2, min_samples_leaf=4, min_samples_split=6, n_estimators=1000; total time=   0.5s\n[CV] END max_depth=30, max_features=log2, min_samples_leaf=4, min_samples_split=6, n_estimators=1000; total time=   0.6s\n[CV] END max_depth=30, max_features=log2, min_samples_leaf=4, min_samples_split=6, n_estimators=1000; total time=   0.6s\n[CV] END max_depth=30, max_features=log2, min_samples_leaf=4, min_samples_split=8, n_estimators=200; total time=   0.1s\n[CV] END max_depth=30, max_features=log2, min_samples_leaf=4, min_samples_split=8, n_estimators=200; total time=   0.1s\n[CV] END max_depth=30, max_features=log2, min_samples_leaf=4, min_samples_split=8, n_estimators=200; total time=   0.1s\n[CV] END max_depth=30, max_features=log2, min_samples_leaf=4, min_samples_split=8, n_estimators=200; total time=   0.1s\n[CV] END max_depth=30, max_features=log2, min_samples_leaf=4, min_samples_split=8, n_estimators=200; total time=   0.1s\n[CV] END max_depth=30, max_features=log2, min_samples_leaf=4, min_samples_split=8, n_estimators=1000; total time=   0.6s\n[CV] END max_depth=30, max_features=log2, min_samples_leaf=4, min_samples_split=8, n_estimators=1000; total time=   0.6s\n[CV] END max_depth=30, max_features=log2, min_samples_leaf=4, min_samples_split=8, n_estimators=1000; total time=   0.5s\n[CV] END max_depth=30, max_features=log2, min_samples_leaf=4, min_samples_split=8, n_estimators=1000; total time=   0.6s\n[CV] END max_depth=30, max_features=log2, min_samples_leaf=4, min_samples_split=8, n_estimators=1000; total time=   0.5s\n[CV] END max_depth=40, max_features=log2, min_samples_leaf=4, min_samples_split=2, n_estimators=200; total time=   0.1s\n[CV] END max_depth=40, max_features=log2, min_samples_leaf=4, min_samples_split=2, n_estimators=200; total time=   0.1s\n[CV] END max_depth=40, max_features=log2, min_samples_leaf=4, min_samples_split=2, n_estimators=200; total time=   0.1s\n[CV] END max_depth=40, max_features=log2, min_samples_leaf=4, min_samples_split=2, n_estimators=200; total time=   0.1s\n[CV] END max_depth=40, max_features=log2, min_samples_leaf=4, min_samples_split=2, n_estimators=200; total time=   0.1s\n[CV] END max_depth=40, max_features=log2, min_samples_leaf=4, min_samples_split=2, n_estimators=1000; total time=   0.5s\n[CV] END max_depth=40, max_features=log2, min_samples_leaf=4, min_samples_split=2, n_estimators=1000; total time=   0.5s\n[CV] END max_depth=40, max_features=log2, min_samples_leaf=4, min_samples_split=2, n_estimators=1000; total time=   0.5s\n[CV] END max_depth=40, max_features=log2, min_samples_leaf=4, min_samples_split=2, n_estimators=1000; total time=   0.5s\n[CV] END max_depth=40, max_features=log2, min_samples_leaf=4, min_samples_split=2, n_estimators=1000; total time=   0.5s\n[CV] END max_depth=40, max_features=log2, min_samples_leaf=4, min_samples_split=4, n_estimators=200; total time=   0.1s\n[CV] END max_depth=40, max_features=log2, min_samples_leaf=4, min_samples_split=4, n_estimators=200; total time=   0.1s\n[CV] END max_depth=40, max_features=log2, min_samples_leaf=4, min_samples_split=4, n_estimators=200; total time=   0.1s\n[CV] END max_depth=40, max_features=log2, min_samples_leaf=4, min_samples_split=4, n_estimators=200; total time=   0.1s\n[CV] END max_depth=40, max_features=log2, min_samples_leaf=4, min_samples_split=4, n_estimators=200; total time=   0.1s\n[CV] END max_depth=40, max_features=log2, min_samples_leaf=4, min_samples_split=4, n_estimators=1000; total time=   0.5s\n[CV] END max_depth=40, max_features=log2, min_samples_leaf=4, min_samples_split=4, n_estimators=1000; total time=   0.6s\n[CV] END max_depth=40, max_features=log2, min_samples_leaf=4, min_samples_split=4, n_estimators=1000; total time=   0.5s\n[CV] END max_depth=40, max_features=log2, min_samples_leaf=4, min_samples_split=4, n_estimators=1000; total time=   0.5s\n[CV] END max_depth=40, max_features=log2, min_samples_leaf=4, min_samples_split=4, n_estimators=1000; total time=   0.5s\n[CV] END max_depth=40, max_features=log2, min_samples_leaf=4, min_samples_split=6, n_estimators=200; total time=   0.1s\n[CV] END max_depth=40, max_features=log2, min_samples_leaf=4, min_samples_split=6, n_estimators=200; total time=   0.1s\n[CV] END max_depth=40, max_features=log2, min_samples_leaf=4, min_samples_split=6, n_estimators=200; total time=   0.1s\n[CV] END max_depth=40, max_features=log2, min_samples_leaf=4, min_samples_split=6, n_estimators=200; total time=   0.1s\n[CV] END max_depth=40, max_features=log2, min_samples_leaf=4, min_samples_split=6, n_estimators=200; total time=   0.1s\n[CV] END max_depth=40, max_features=log2, min_samples_leaf=4, min_samples_split=6, n_estimators=1000; total time=   0.5s\n[CV] END max_depth=40, max_features=log2, min_samples_leaf=4, min_samples_split=6, n_estimators=1000; total time=   0.5s\n[CV] END max_depth=40, max_features=log2, min_samples_leaf=4, min_samples_split=6, n_estimators=1000; total time=   0.5s\n[CV] END max_depth=40, max_features=log2, min_samples_leaf=4, min_samples_split=6, n_estimators=1000; total time=   0.5s\n[CV] END max_depth=40, max_features=log2, min_samples_leaf=4, min_samples_split=6, n_estimators=1000; total time=   0.5s\n[CV] END max_depth=40, max_features=log2, min_samples_leaf=4, min_samples_split=8, n_estimators=200; total time=   0.1s\n[CV] END max_depth=40, max_features=log2, min_samples_leaf=4, min_samples_split=8, n_estimators=200; total time=   0.1s\n[CV] END max_depth=40, max_features=log2, min_samples_leaf=4, min_samples_split=8, n_estimators=200; total time=   0.1s\n[CV] END max_depth=40, max_features=log2, min_samples_leaf=4, min_samples_split=8, n_estimators=200; total time=   0.1s\n[CV] END max_depth=40, max_features=log2, min_samples_leaf=4, min_samples_split=8, n_estimators=200; total time=   0.1s\n[CV] END max_depth=40, max_features=log2, min_samples_leaf=4, min_samples_split=8, n_estimators=1000; total time=   0.6s\n[CV] END max_depth=40, max_features=log2, min_samples_leaf=4, min_samples_split=8, n_estimators=1000; total time=   0.7s\n[CV] END max_depth=40, max_features=log2, min_samples_leaf=4, min_samples_split=8, n_estimators=1000; total time=   0.7s\n[CV] END max_depth=40, max_features=log2, min_samples_leaf=4, min_samples_split=8, n_estimators=1000; total time=   0.6s\n[CV] END max_depth=40, max_features=log2, min_samples_leaf=4, min_samples_split=8, n_estimators=1000; total time=   0.6s\n[CV] END max_depth=50, max_features=log2, min_samples_leaf=4, min_samples_split=2, n_estimators=200; total time=   0.1s\n[CV] END max_depth=50, max_features=log2, min_samples_leaf=4, min_samples_split=2, n_estimators=200; total time=   0.2s\n[CV] END max_depth=50, max_features=log2, min_samples_leaf=4, min_samples_split=2, n_estimators=200; total time=   0.1s\n[CV] END max_depth=50, max_features=log2, min_samples_leaf=4, min_samples_split=2, n_estimators=200; total time=   0.2s\n[CV] END max_depth=50, max_features=log2, min_samples_leaf=4, min_samples_split=2, n_estimators=200; total time=   0.1s\n[CV] END max_depth=50, max_features=log2, min_samples_leaf=4, min_samples_split=2, n_estimators=1000; total time=   0.6s\n[CV] END max_depth=50, max_features=log2, min_samples_leaf=4, min_samples_split=2, n_estimators=1000; total time=   0.6s\n[CV] END max_depth=50, max_features=log2, min_samples_leaf=4, min_samples_split=2, n_estimators=1000; total time=   0.6s\n[CV] END max_depth=50, max_features=log2, min_samples_leaf=4, min_samples_split=2, n_estimators=1000; total time=   0.6s\n[CV] END max_depth=50, max_features=log2, min_samples_leaf=4, min_samples_split=2, n_estimators=1000; total time=   0.6s\n[CV] END max_depth=50, max_features=log2, min_samples_leaf=4, min_samples_split=4, n_estimators=200; total time=   0.1s\n[CV] END max_depth=50, max_features=log2, min_samples_leaf=4, min_samples_split=4, n_estimators=200; total time=   0.1s\n[CV] END max_depth=50, max_features=log2, min_samples_leaf=4, min_samples_split=4, n_estimators=200; total time=   0.1s\n[CV] END max_depth=50, max_features=log2, min_samples_leaf=4, min_samples_split=4, n_estimators=200; total time=   0.1s\n[CV] END max_depth=50, max_features=log2, min_samples_leaf=4, min_samples_split=4, n_estimators=200; total time=   0.1s\n[CV] END max_depth=50, max_features=log2, min_samples_leaf=4, min_samples_split=4, n_estimators=1000; total time=   0.6s\n[CV] END max_depth=50, max_features=log2, min_samples_leaf=4, min_samples_split=4, n_estimators=1000; total time=   0.6s\n[CV] END max_depth=50, max_features=log2, min_samples_leaf=4, min_samples_split=4, n_estimators=1000; total time=   0.5s\n[CV] END max_depth=50, max_features=log2, min_samples_leaf=4, min_samples_split=4, n_estimators=1000; total time=   0.6s\n[CV] END max_depth=50, max_features=log2, min_samples_leaf=4, min_samples_split=4, n_estimators=1000; total time=   0.6s\n[CV] END max_depth=50, max_features=log2, min_samples_leaf=4, min_samples_split=6, n_estimators=200; total time=   0.1s\n[CV] END max_depth=50, max_features=log2, min_samples_leaf=4, min_samples_split=6, n_estimators=200; total time=   0.1s\n[CV] END max_depth=50, max_features=log2, min_samples_leaf=4, min_samples_split=6, n_estimators=200; total time=   0.1s\n[CV] END max_depth=50, max_features=log2, min_samples_leaf=4, min_samples_split=6, n_estimators=200; total time=   0.1s\n[CV] END max_depth=50, max_features=log2, min_samples_leaf=4, min_samples_split=6, n_estimators=200; total time=   0.2s\n[CV] END max_depth=50, max_features=log2, min_samples_leaf=4, min_samples_split=6, n_estimators=1000; total time=   0.6s\n[CV] END max_depth=50, max_features=log2, min_samples_leaf=4, min_samples_split=6, n_estimators=1000; total time=   0.6s\n[CV] END max_depth=50, max_features=log2, min_samples_leaf=4, min_samples_split=6, n_estimators=1000; total time=   0.6s\n[CV] END max_depth=50, max_features=log2, min_samples_leaf=4, min_samples_split=6, n_estimators=1000; total time=   0.6s\n[CV] END max_depth=50, max_features=log2, min_samples_leaf=4, min_samples_split=6, n_estimators=1000; total time=   0.7s\n[CV] END max_depth=50, max_features=log2, min_samples_leaf=4, min_samples_split=8, n_estimators=200; total time=   0.1s\n[CV] END max_depth=50, max_features=log2, min_samples_leaf=4, min_samples_split=8, n_estimators=200; total time=   0.1s\n[CV] END max_depth=50, max_features=log2, min_samples_leaf=4, min_samples_split=8, n_estimators=200; total time=   0.1s\n[CV] END max_depth=50, max_features=log2, min_samples_leaf=4, min_samples_split=8, n_estimators=200; total time=   0.1s\n[CV] END max_depth=50, max_features=log2, min_samples_leaf=4, min_samples_split=8, n_estimators=200; total time=   0.1s\n[CV] END max_depth=50, max_features=log2, min_samples_leaf=4, min_samples_split=8, n_estimators=1000; total time=   0.6s\n[CV] END max_depth=50, max_features=log2, min_samples_leaf=4, min_samples_split=8, n_estimators=1000; total time=   0.6s\n[CV] END max_depth=50, max_features=log2, min_samples_leaf=4, min_samples_split=8, n_estimators=1000; total time=   0.6s\n[CV] END max_depth=50, max_features=log2, min_samples_leaf=4, min_samples_split=8, n_estimators=1000; total time=   0.5s\n[CV] END max_depth=50, max_features=log2, min_samples_leaf=4, min_samples_split=8, n_estimators=1000; total time=   0.5s\n</pre> In\u00a0[181]: Copied! <pre># How long did it take? \ntotal_time = end_time - start_time\nprint(f\"[INFO] The total running time for running GridSearchCV was {total_time:.2f} seconds.\")\n</pre> # How long did it take?  total_time = end_time - start_time print(f\"[INFO] The total running time for running GridSearchCV was {total_time:.2f} seconds.\") <pre>[INFO] The total running time for running GridSearchCV was 41.95 seconds.\n</pre> <p>Once it completes, we can check the best hyperparameter combinations it found using the <code>best_params_</code> attribute.</p> In\u00a0[182]: Copied! <pre># Check the best hyperparameters found with GridSearchCV\ngs_clf.best_params_\n</pre> # Check the best hyperparameters found with GridSearchCV gs_clf.best_params_ Out[182]: <pre>{'max_depth': 30,\n 'max_features': 'log2',\n 'min_samples_leaf': 4,\n 'min_samples_split': 2,\n 'n_estimators': 200}</pre> <p>And by default when we call the <code>predict()</code> function on <code>gs_clf</code>, it'll use the best hyperparameters.</p> In\u00a0[183]: Copied! <pre># Max predictions with the GridSearchCV classifier\ngs_y_preds = gs_clf.predict(X_test)\n\n# Evaluate the predictions\ngs_metrics = evaluate_preds(y_test, gs_y_preds)\ngs_metrics\n</pre> # Max predictions with the GridSearchCV classifier gs_y_preds = gs_clf.predict(X_test)  # Evaluate the predictions gs_metrics = evaluate_preds(y_test, gs_y_preds) gs_metrics <pre>Acc: 88.52%\nPrecision: 0.88\nRecall: 0.91\nF1 score: 0.89\n</pre> Out[183]: <pre>{'accuracy': 0.89,\n 'precision': np.float64(0.88),\n 'recall': np.float64(0.91),\n 'f1': np.float64(0.89)}</pre> <p>Let's create a DataFrame to compare the different metrics.</p> In\u00a0[184]: Copied! <pre>compare_metrics = pd.DataFrame({\"baseline\": baseline_metrics,\n                                \"clf_2\": clf_2_metrics,\n                                \"random search\": rs_metrics,\n                                \"grid search\": gs_metrics})\ncompare_metrics.plot.bar(figsize=(10, 8));\n</pre> compare_metrics = pd.DataFrame({\"baseline\": baseline_metrics,                                 \"clf_2\": clf_2_metrics,                                 \"random search\": rs_metrics,                                 \"grid search\": gs_metrics}) compare_metrics.plot.bar(figsize=(10, 8)); <p>Nice!</p> <p>After trying many different combinations of hyperparamters, we get a slight improvement in results.</p> <p>However, sometimes you'll notice that your results don't change much.</p> <p>These things might happen.</p> <p>But it's important to remember, it's not over. There more things you can try.</p> <p>In a hyperparameter tuning sense, there may be a better set we could find through more extensive searching with <code>RandomizedSearchCV</code> and <code>GridSearchCV</code>, this would require more experimentation.</p> <p>Other techniques you could:</p> <ul> <li>Collecting more data - Based on the results our models are getting now, it seems like they're very capable of finding patterns. Collecting more data may improve a models ability to find patterns. However, your ability to do this will largely depend on the project you're working on.</li> <li>Try a more advanced model - Although our tuned Random Forest model is doing pretty well, a more advanced ensemble method such as XGBoost or CatBoost might perform better. I'll leave these for extra-curriculum.</li> </ul> <p>Since machine learning is part engineering, part science, these kind of experiments are common place in any machine learning project.</p> <p>Now we've got a tuned Random Forest model, let's find out how we might save it and export it so we can share it with others or potentially use it in an external application.</p> In\u00a0[185]: Copied! <pre>import pickle\n\n# Save an existing model to file\nbest_model_file_name_pickle = \"gs_random_forest_model_1.pkl\" # .pkl extension stands for \"pickle\"\npickle.dump(gs_clf, open(best_model_file_name_pickle, \"wb\"))\n</pre> import pickle  # Save an existing model to file best_model_file_name_pickle = \"gs_random_forest_model_1.pkl\" # .pkl extension stands for \"pickle\" pickle.dump(gs_clf, open(best_model_file_name_pickle, \"wb\")) <p>Once it's saved, we can import it using <code>pickle</code>'s <code>load()</code> function, passing it <code>open()</code> containing the filename as a string and <code>\"rb\"</code> standing for \"read binary\".</p> In\u00a0[186]: Copied! <pre># Load a saved model\nloaded_pickle_model = pickle.load(open(best_model_file_name_pickle, \"rb\"))\n</pre> # Load a saved model loaded_pickle_model = pickle.load(open(best_model_file_name_pickle, \"rb\")) <p>Once you've reimported your trained model using <code>pickle</code>, you can use it to make predictions as usual.</p> In\u00a0[187]: Copied! <pre># Make predictions and evaluate the loaded model\npickle_y_preds = loaded_pickle_model.predict(X_test)\nloaded_pickle_model_metrics = evaluate_preds(y_test, pickle_y_preds)\nloaded_pickle_model_metrics\n</pre> # Make predictions and evaluate the loaded model pickle_y_preds = loaded_pickle_model.predict(X_test) loaded_pickle_model_metrics = evaluate_preds(y_test, pickle_y_preds) loaded_pickle_model_metrics <pre>Acc: 88.52%\nPrecision: 0.88\nRecall: 0.91\nF1 score: 0.89\n</pre> Out[187]: <pre>{'accuracy': 0.89,\n 'precision': np.float64(0.88),\n 'recall': np.float64(0.91),\n 'f1': np.float64(0.89)}</pre> <p>You'll notice the reimported model evaluation metrics are the same as the model before we exported it.</p> In\u00a0[188]: Copied! <pre>loaded_pickle_model_metrics == gs_metrics\n</pre> loaded_pickle_model_metrics == gs_metrics Out[188]: <pre>True</pre> In\u00a0[189]: Copied! <pre>from joblib import dump, load\n\n# Save a model to file\nbest_model_file_name_joblib = \"gs_random_forest_model_1.joblib\"\ndump(gs_clf, filename=best_model_file_name_joblib)\n</pre> from joblib import dump, load  # Save a model to file best_model_file_name_joblib = \"gs_random_forest_model_1.joblib\" dump(gs_clf, filename=best_model_file_name_joblib)  Out[189]: <pre>['gs_random_forest_model_1.joblib']</pre> <p>Once you've saved a model using <code>dump()</code>, you can import it using <code>load()</code> and passing it the filename of the model.</p> In\u00a0[190]: Copied! <pre># Import a saved joblib model\nloaded_joblib_model = load(filename=best_model_file_name_joblib)\n</pre> # Import a saved joblib model loaded_joblib_model = load(filename=best_model_file_name_joblib) <p>Again, once imported, we can make predictions with our model.</p> In\u00a0[191]: Copied! <pre># Make and evaluate joblib predictions \njoblib_y_preds = loaded_joblib_model.predict(X_test)\nloaded_joblib_model_metrics = evaluate_preds(y_test, joblib_y_preds)\nloaded_joblib_model_metrics\n</pre> # Make and evaluate joblib predictions  joblib_y_preds = loaded_joblib_model.predict(X_test) loaded_joblib_model_metrics = evaluate_preds(y_test, joblib_y_preds) loaded_joblib_model_metrics <pre>Acc: 88.52%\nPrecision: 0.88\nRecall: 0.91\nF1 score: 0.89\n</pre> Out[191]: <pre>{'accuracy': 0.89,\n 'precision': np.float64(0.88),\n 'recall': np.float64(0.91),\n 'f1': np.float64(0.89)}</pre> <p>And once again, you'll notice the evaluation metrics are the same as before.</p> In\u00a0[192]: Copied! <pre>loaded_joblib_model_metrics == gs_metrics\n</pre> loaded_joblib_model_metrics == gs_metrics Out[192]: <pre>True</pre> <p>So which one should you use, <code>pickle</code> or <code>joblib</code>?</p> <p>According to Scikit-Learn's model persistence documentation, they suggest it may be more efficient to use <code>joblib</code> as it's more efficient with large numpy arrays (which is what may be contained in trained/fitted Scikit-Learn models).</p> In\u00a0[193]: Copied! <pre># data = pd.read_csv(\"../data/car-sales-extended-missing-data.csv\") # load from local directory\ndata = pd.read_csv(\"https://raw.githubusercontent.com/mrdbourke/zero-to-mastery-ml/master/data/car-sales-extended-missing-data.csv\") # load directly from URL\ndata.head()\n</pre> # data = pd.read_csv(\"../data/car-sales-extended-missing-data.csv\") # load from local directory data = pd.read_csv(\"https://raw.githubusercontent.com/mrdbourke/zero-to-mastery-ml/master/data/car-sales-extended-missing-data.csv\") # load directly from URL data.head() Out[193]: Make Colour Odometer (KM) Doors Price 0 Honda White 35431.0 4.0 15323.0 1 BMW Blue 192714.0 5.0 19943.0 2 Honda White 84714.0 4.0 28343.0 3 Toyota White 154365.0 4.0 13434.0 4 Nissan Blue 181577.0 3.0 14043.0 In\u00a0[194]: Copied! <pre>data.dtypes\n</pre> data.dtypes Out[194]: <pre>Make              object\nColour            object\nOdometer (KM)    float64\nDoors            float64\nPrice            float64\ndtype: object</pre> In\u00a0[195]: Copied! <pre>data.isna().sum()\n</pre> data.isna().sum() Out[195]: <pre>Make             49\nColour           50\nOdometer (KM)    50\nDoors            50\nPrice            50\ndtype: int64</pre> <p>There's 1000 rows, three features are categorical (<code>Make</code>, <code>Colour</code>, <code>Doors</code>), the other two are numerical (<code>Odometer (KM)</code>, <code>Price</code>) and there's 249 missing values.</p> <p>We're going to have to turn the categorical features into numbers and fill the missing values before we can fit a model.</p> <p>We'll build a <code>Pipeline</code> to do so.</p> <p><code>Pipeline</code>'s main input parameter is <code>steps</code> which is a list of tuples (<code>[(step_name, action_to_take)]</code>) of the step name, plus the action you'd like it to perform.</p> <p>In our case, you could think of the steps as:</p> <ol> <li>Fill missing data</li> <li>Convert data to numbers</li> <li>Build a model on the data</li> </ol> <p>Let's do it!</p> In\u00a0[199]: Copied! <pre># Getting data ready\nimport pandas as pd\nfrom sklearn.compose import ColumnTransformer\nfrom sklearn.pipeline import Pipeline\nfrom sklearn.impute import SimpleImputer\nfrom sklearn.preprocessing import OneHotEncoder\n\n# Modelling\nfrom sklearn.ensemble import RandomForestRegressor\nfrom sklearn.model_selection import train_test_split, GridSearchCV\n\n# Setup random seed\nimport numpy as np\nnp.random.seed(42)\n\n# Import data and drop the rows with missing labels\ndata = pd.read_csv(\"https://raw.githubusercontent.com/mrdbourke/zero-to-mastery-ml/master/data/car-sales-extended-missing-data.csv\")\ndata.dropna(subset=[\"Price\"], inplace=True)\n\n# Define different features and transformer pipelines\ncategorical_features = [\"Make\", \"Colour\"]\ncategorical_transformer = Pipeline(steps=[\n    (\"imputer\", SimpleImputer(strategy=\"constant\", fill_value=\"missing\")),\n    (\"onehot\", OneHotEncoder(handle_unknown=\"ignore\"))])\n\ndoor_feature = [\"Doors\"]\ndoor_transformer = Pipeline(steps=[\n    (\"imputer\", SimpleImputer(strategy=\"constant\", fill_value=4))])\n\nnumeric_features = [\"Odometer (KM)\"]\nnumeric_transformer = Pipeline(steps=[\n    (\"imputer\", SimpleImputer(strategy=\"mean\"))\n])\n\n# Setup preprocessing steps (fill missing values, then convert to numbers)\npreprocessor = ColumnTransformer(\n    transformers=[\n        (\"cat\", categorical_transformer, categorical_features),\n        (\"door\", door_transformer, door_feature),\n        (\"num\", numeric_transformer, numeric_features)])\n\n# Create a preprocessing and modelling pipeline\nmodel = Pipeline(steps=[(\"preprocessor\", preprocessor),\n                        (\"model\", RandomForestRegressor(n_jobs=-1))])\n\n# Split data\nX = data.drop(\"Price\", axis=1)\ny = data[\"Price\"]\nX_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2)\n\n# Fit and score the model\nmodel.fit(X_train, y_train)\nmodel.score(X_test, y_test)\n</pre> # Getting data ready import pandas as pd from sklearn.compose import ColumnTransformer from sklearn.pipeline import Pipeline from sklearn.impute import SimpleImputer from sklearn.preprocessing import OneHotEncoder  # Modelling from sklearn.ensemble import RandomForestRegressor from sklearn.model_selection import train_test_split, GridSearchCV  # Setup random seed import numpy as np np.random.seed(42)  # Import data and drop the rows with missing labels data = pd.read_csv(\"https://raw.githubusercontent.com/mrdbourke/zero-to-mastery-ml/master/data/car-sales-extended-missing-data.csv\") data.dropna(subset=[\"Price\"], inplace=True)  # Define different features and transformer pipelines categorical_features = [\"Make\", \"Colour\"] categorical_transformer = Pipeline(steps=[     (\"imputer\", SimpleImputer(strategy=\"constant\", fill_value=\"missing\")),     (\"onehot\", OneHotEncoder(handle_unknown=\"ignore\"))])  door_feature = [\"Doors\"] door_transformer = Pipeline(steps=[     (\"imputer\", SimpleImputer(strategy=\"constant\", fill_value=4))])  numeric_features = [\"Odometer (KM)\"] numeric_transformer = Pipeline(steps=[     (\"imputer\", SimpleImputer(strategy=\"mean\")) ])  # Setup preprocessing steps (fill missing values, then convert to numbers) preprocessor = ColumnTransformer(     transformers=[         (\"cat\", categorical_transformer, categorical_features),         (\"door\", door_transformer, door_feature),         (\"num\", numeric_transformer, numeric_features)])  # Create a preprocessing and modelling pipeline model = Pipeline(steps=[(\"preprocessor\", preprocessor),                         (\"model\", RandomForestRegressor(n_jobs=-1))])  # Split data X = data.drop(\"Price\", axis=1) y = data[\"Price\"] X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2)  # Fit and score the model model.fit(X_train, y_train) model.score(X_test, y_test) Out[199]: <pre>0.22188417408787875</pre> <p>What we've done is combine a series of data preprocessing steps (filling missing values, encoding numerical values) as well as a model into a <code>Pipeline</code>.</p> <p>Doing so not only cleans up the code, it ensures the same steps are taken every time the code is run rather than having multiple different processing steps happening in different stages.</p> <p>It's also possible to <code>GridSearchCV</code> or <code>RandomizedSearchCV</code> with a <code>Pipeline</code>.</p> <p>The main difference is when creating a hyperparameter grid, you have to add a prefix to each hyperparameter (see the documentation for <code>RandomForestRegressor</code> for a full list of possible hyperparameters to tune).</p> <p>The prefix is the name of the <code>Pipeline</code> step you'd like to alter, followed by two underscores.</p> <p>For example, to adjust <code>n_estimators</code> of <code>\"model\"</code> in the <code>Pipeline</code>, you'd use: <code>\"model__n_estimators\"</code> (note the double underscore after <code>model__</code> at the start).</p> <p>Let's see it!</p> <p>Note: Depending on your computer's processing power, the cell below may take a few minutes to run. For reference, it took about ~60 seconds on my M1 Pro MacBook Pro.</p> In\u00a0[200]: Copied! <pre>%%time\n\n# Using grid search with pipeline\npipe_grid = {\n    \"preprocessor__num__imputer__strategy\": [\"mean\", \"median\"], # note the double underscore after each prefix \"preprocessor__\"\n    \"model__n_estimators\": [100, 1000],\n    \"model__max_depth\": [None, 5],\n    \"model__max_features\": [\"sqrt\"],\n    \"model__min_samples_split\": [2, 4]\n}\n\ngs_model = GridSearchCV(model, pipe_grid, cv=5, verbose=2)\ngs_model.fit(X_train, y_train)\n</pre> %%time  # Using grid search with pipeline pipe_grid = {     \"preprocessor__num__imputer__strategy\": [\"mean\", \"median\"], # note the double underscore after each prefix \"preprocessor__\"     \"model__n_estimators\": [100, 1000],     \"model__max_depth\": [None, 5],     \"model__max_features\": [\"sqrt\"],     \"model__min_samples_split\": [2, 4] }  gs_model = GridSearchCV(model, pipe_grid, cv=5, verbose=2) gs_model.fit(X_train, y_train) <pre>Fitting 5 folds for each of 16 candidates, totalling 80 fits\n[CV] END model__max_depth=None, model__max_features=sqrt, model__min_samples_split=2, model__n_estimators=100, preprocessor__num__imputer__strategy=mean; total time=   0.1s\n[CV] END model__max_depth=None, model__max_features=sqrt, model__min_samples_split=2, model__n_estimators=100, preprocessor__num__imputer__strategy=mean; total time=   0.1s\n[CV] END model__max_depth=None, model__max_features=sqrt, model__min_samples_split=2, model__n_estimators=100, preprocessor__num__imputer__strategy=mean; total time=   0.1s\n[CV] END model__max_depth=None, model__max_features=sqrt, model__min_samples_split=2, model__n_estimators=100, preprocessor__num__imputer__strategy=mean; total time=   0.1s\n[CV] END model__max_depth=None, model__max_features=sqrt, model__min_samples_split=2, model__n_estimators=100, preprocessor__num__imputer__strategy=mean; total time=   0.1s\n[CV] END model__max_depth=None, model__max_features=sqrt, model__min_samples_split=2, model__n_estimators=100, preprocessor__num__imputer__strategy=median; total time=   0.1s\n[CV] END model__max_depth=None, model__max_features=sqrt, model__min_samples_split=2, model__n_estimators=100, preprocessor__num__imputer__strategy=median; total time=   0.1s\n[CV] END model__max_depth=None, model__max_features=sqrt, model__min_samples_split=2, model__n_estimators=100, preprocessor__num__imputer__strategy=median; total time=   0.1s\n[CV] END model__max_depth=None, model__max_features=sqrt, model__min_samples_split=2, model__n_estimators=100, preprocessor__num__imputer__strategy=median; total time=   0.1s\n[CV] END model__max_depth=None, model__max_features=sqrt, model__min_samples_split=2, model__n_estimators=100, preprocessor__num__imputer__strategy=median; total time=   0.1s\n[CV] END model__max_depth=None, model__max_features=sqrt, model__min_samples_split=2, model__n_estimators=1000, preprocessor__num__imputer__strategy=mean; total time=   0.6s\n[CV] END model__max_depth=None, model__max_features=sqrt, model__min_samples_split=2, model__n_estimators=1000, preprocessor__num__imputer__strategy=mean; total time=   0.6s\n[CV] END model__max_depth=None, model__max_features=sqrt, model__min_samples_split=2, model__n_estimators=1000, preprocessor__num__imputer__strategy=mean; total time=   0.6s\n[CV] END model__max_depth=None, model__max_features=sqrt, model__min_samples_split=2, model__n_estimators=1000, preprocessor__num__imputer__strategy=mean; total time=   0.6s\n[CV] END model__max_depth=None, model__max_features=sqrt, model__min_samples_split=2, model__n_estimators=1000, preprocessor__num__imputer__strategy=mean; total time=   0.6s\n[CV] END model__max_depth=None, model__max_features=sqrt, model__min_samples_split=2, model__n_estimators=1000, preprocessor__num__imputer__strategy=median; total time=   0.6s\n[CV] END model__max_depth=None, model__max_features=sqrt, model__min_samples_split=2, model__n_estimators=1000, preprocessor__num__imputer__strategy=median; total time=   0.6s\n[CV] END model__max_depth=None, model__max_features=sqrt, model__min_samples_split=2, model__n_estimators=1000, preprocessor__num__imputer__strategy=median; total time=   0.6s\n[CV] END model__max_depth=None, model__max_features=sqrt, model__min_samples_split=2, model__n_estimators=1000, preprocessor__num__imputer__strategy=median; total time=   0.5s\n[CV] END model__max_depth=None, model__max_features=sqrt, model__min_samples_split=2, model__n_estimators=1000, preprocessor__num__imputer__strategy=median; total time=   0.5s\n[CV] END model__max_depth=None, model__max_features=sqrt, model__min_samples_split=4, model__n_estimators=100, preprocessor__num__imputer__strategy=mean; total time=   0.1s\n[CV] END model__max_depth=None, model__max_features=sqrt, model__min_samples_split=4, model__n_estimators=100, preprocessor__num__imputer__strategy=mean; total time=   0.1s\n[CV] END model__max_depth=None, model__max_features=sqrt, model__min_samples_split=4, model__n_estimators=100, preprocessor__num__imputer__strategy=mean; total time=   0.1s\n[CV] END model__max_depth=None, model__max_features=sqrt, model__min_samples_split=4, model__n_estimators=100, preprocessor__num__imputer__strategy=mean; total time=   0.1s\n[CV] END model__max_depth=None, model__max_features=sqrt, model__min_samples_split=4, model__n_estimators=100, preprocessor__num__imputer__strategy=mean; total time=   0.1s\n[CV] END model__max_depth=None, model__max_features=sqrt, model__min_samples_split=4, model__n_estimators=100, preprocessor__num__imputer__strategy=median; total time=   0.1s\n[CV] END model__max_depth=None, model__max_features=sqrt, model__min_samples_split=4, model__n_estimators=100, preprocessor__num__imputer__strategy=median; total time=   0.1s\n[CV] END model__max_depth=None, model__max_features=sqrt, model__min_samples_split=4, model__n_estimators=100, preprocessor__num__imputer__strategy=median; total time=   0.1s\n[CV] END model__max_depth=None, model__max_features=sqrt, model__min_samples_split=4, model__n_estimators=100, preprocessor__num__imputer__strategy=median; total time=   0.1s\n[CV] END model__max_depth=None, model__max_features=sqrt, model__min_samples_split=4, model__n_estimators=100, preprocessor__num__imputer__strategy=median; total time=   0.1s\n[CV] END model__max_depth=None, model__max_features=sqrt, model__min_samples_split=4, model__n_estimators=1000, preprocessor__num__imputer__strategy=mean; total time=   0.6s\n[CV] END model__max_depth=None, model__max_features=sqrt, model__min_samples_split=4, model__n_estimators=1000, preprocessor__num__imputer__strategy=mean; total time=   0.6s\n[CV] END model__max_depth=None, model__max_features=sqrt, model__min_samples_split=4, model__n_estimators=1000, preprocessor__num__imputer__strategy=mean; total time=   0.5s\n[CV] END model__max_depth=None, model__max_features=sqrt, model__min_samples_split=4, model__n_estimators=1000, preprocessor__num__imputer__strategy=mean; total time=   0.5s\n[CV] END model__max_depth=None, model__max_features=sqrt, model__min_samples_split=4, model__n_estimators=1000, preprocessor__num__imputer__strategy=mean; total time=   0.5s\n[CV] END model__max_depth=None, model__max_features=sqrt, model__min_samples_split=4, model__n_estimators=1000, preprocessor__num__imputer__strategy=median; total time=   0.5s\n[CV] END model__max_depth=None, model__max_features=sqrt, model__min_samples_split=4, model__n_estimators=1000, preprocessor__num__imputer__strategy=median; total time=   0.6s\n[CV] END model__max_depth=None, model__max_features=sqrt, model__min_samples_split=4, model__n_estimators=1000, preprocessor__num__imputer__strategy=median; total time=   0.6s\n[CV] END model__max_depth=None, model__max_features=sqrt, model__min_samples_split=4, model__n_estimators=1000, preprocessor__num__imputer__strategy=median; total time=   0.6s\n[CV] END model__max_depth=None, model__max_features=sqrt, model__min_samples_split=4, model__n_estimators=1000, preprocessor__num__imputer__strategy=median; total time=   0.6s\n[CV] END model__max_depth=5, model__max_features=sqrt, model__min_samples_split=2, model__n_estimators=100, preprocessor__num__imputer__strategy=mean; total time=   0.1s\n[CV] END model__max_depth=5, model__max_features=sqrt, model__min_samples_split=2, model__n_estimators=100, preprocessor__num__imputer__strategy=mean; total time=   0.1s\n[CV] END model__max_depth=5, model__max_features=sqrt, model__min_samples_split=2, model__n_estimators=100, preprocessor__num__imputer__strategy=mean; total time=   0.1s\n[CV] END model__max_depth=5, model__max_features=sqrt, model__min_samples_split=2, model__n_estimators=100, preprocessor__num__imputer__strategy=mean; total time=   0.1s\n[CV] END model__max_depth=5, model__max_features=sqrt, model__min_samples_split=2, model__n_estimators=100, preprocessor__num__imputer__strategy=mean; total time=   0.1s\n[CV] END model__max_depth=5, model__max_features=sqrt, model__min_samples_split=2, model__n_estimators=100, preprocessor__num__imputer__strategy=median; total time=   0.1s\n[CV] END model__max_depth=5, model__max_features=sqrt, model__min_samples_split=2, model__n_estimators=100, preprocessor__num__imputer__strategy=median; total time=   0.1s\n[CV] END model__max_depth=5, model__max_features=sqrt, model__min_samples_split=2, model__n_estimators=100, preprocessor__num__imputer__strategy=median; total time=   0.1s\n[CV] END model__max_depth=5, model__max_features=sqrt, model__min_samples_split=2, model__n_estimators=100, preprocessor__num__imputer__strategy=median; total time=   0.1s\n[CV] END model__max_depth=5, model__max_features=sqrt, model__min_samples_split=2, model__n_estimators=100, preprocessor__num__imputer__strategy=median; total time=   0.1s\n[CV] END model__max_depth=5, model__max_features=sqrt, model__min_samples_split=2, model__n_estimators=1000, preprocessor__num__imputer__strategy=mean; total time=   0.6s\n[CV] END model__max_depth=5, model__max_features=sqrt, model__min_samples_split=2, model__n_estimators=1000, preprocessor__num__imputer__strategy=mean; total time=   0.5s\n[CV] END model__max_depth=5, model__max_features=sqrt, model__min_samples_split=2, model__n_estimators=1000, preprocessor__num__imputer__strategy=mean; total time=   0.5s\n[CV] END model__max_depth=5, model__max_features=sqrt, model__min_samples_split=2, model__n_estimators=1000, preprocessor__num__imputer__strategy=mean; total time=   0.5s\n[CV] END model__max_depth=5, model__max_features=sqrt, model__min_samples_split=2, model__n_estimators=1000, preprocessor__num__imputer__strategy=mean; total time=   0.6s\n[CV] END model__max_depth=5, model__max_features=sqrt, model__min_samples_split=2, model__n_estimators=1000, preprocessor__num__imputer__strategy=median; total time=   0.6s\n[CV] END model__max_depth=5, model__max_features=sqrt, model__min_samples_split=2, model__n_estimators=1000, preprocessor__num__imputer__strategy=median; total time=   0.6s\n[CV] END model__max_depth=5, model__max_features=sqrt, model__min_samples_split=2, model__n_estimators=1000, preprocessor__num__imputer__strategy=median; total time=   0.7s\n[CV] END model__max_depth=5, model__max_features=sqrt, model__min_samples_split=2, model__n_estimators=1000, preprocessor__num__imputer__strategy=median; total time=   0.5s\n[CV] END model__max_depth=5, model__max_features=sqrt, model__min_samples_split=2, model__n_estimators=1000, preprocessor__num__imputer__strategy=median; total time=   0.6s\n[CV] END model__max_depth=5, model__max_features=sqrt, model__min_samples_split=4, model__n_estimators=100, preprocessor__num__imputer__strategy=mean; total time=   0.1s\n[CV] END model__max_depth=5, model__max_features=sqrt, model__min_samples_split=4, model__n_estimators=100, preprocessor__num__imputer__strategy=mean; total time=   0.1s\n[CV] END model__max_depth=5, model__max_features=sqrt, model__min_samples_split=4, model__n_estimators=100, preprocessor__num__imputer__strategy=mean; total time=   0.1s\n[CV] END model__max_depth=5, model__max_features=sqrt, model__min_samples_split=4, model__n_estimators=100, preprocessor__num__imputer__strategy=mean; total time=   0.1s\n[CV] END model__max_depth=5, model__max_features=sqrt, model__min_samples_split=4, model__n_estimators=100, preprocessor__num__imputer__strategy=mean; total time=   0.1s\n[CV] END model__max_depth=5, model__max_features=sqrt, model__min_samples_split=4, model__n_estimators=100, preprocessor__num__imputer__strategy=median; total time=   0.1s\n[CV] END model__max_depth=5, model__max_features=sqrt, model__min_samples_split=4, model__n_estimators=100, preprocessor__num__imputer__strategy=median; total time=   0.1s\n[CV] END model__max_depth=5, model__max_features=sqrt, model__min_samples_split=4, model__n_estimators=100, preprocessor__num__imputer__strategy=median; total time=   0.1s\n[CV] END model__max_depth=5, model__max_features=sqrt, model__min_samples_split=4, model__n_estimators=100, preprocessor__num__imputer__strategy=median; total time=   0.1s\n[CV] END model__max_depth=5, model__max_features=sqrt, model__min_samples_split=4, model__n_estimators=100, preprocessor__num__imputer__strategy=median; total time=   0.1s\n[CV] END model__max_depth=5, model__max_features=sqrt, model__min_samples_split=4, model__n_estimators=1000, preprocessor__num__imputer__strategy=mean; total time=   0.5s\n[CV] END model__max_depth=5, model__max_features=sqrt, model__min_samples_split=4, model__n_estimators=1000, preprocessor__num__imputer__strategy=mean; total time=   0.6s\n[CV] END model__max_depth=5, model__max_features=sqrt, model__min_samples_split=4, model__n_estimators=1000, preprocessor__num__imputer__strategy=mean; total time=   0.6s\n[CV] END model__max_depth=5, model__max_features=sqrt, model__min_samples_split=4, model__n_estimators=1000, preprocessor__num__imputer__strategy=mean; total time=   0.5s\n[CV] END model__max_depth=5, model__max_features=sqrt, model__min_samples_split=4, model__n_estimators=1000, preprocessor__num__imputer__strategy=mean; total time=   0.5s\n[CV] END model__max_depth=5, model__max_features=sqrt, model__min_samples_split=4, model__n_estimators=1000, preprocessor__num__imputer__strategy=median; total time=   0.6s\n[CV] END model__max_depth=5, model__max_features=sqrt, model__min_samples_split=4, model__n_estimators=1000, preprocessor__num__imputer__strategy=median; total time=   0.5s\n[CV] END model__max_depth=5, model__max_features=sqrt, model__min_samples_split=4, model__n_estimators=1000, preprocessor__num__imputer__strategy=median; total time=   0.5s\n[CV] END model__max_depth=5, model__max_features=sqrt, model__min_samples_split=4, model__n_estimators=1000, preprocessor__num__imputer__strategy=median; total time=   0.5s\n[CV] END model__max_depth=5, model__max_features=sqrt, model__min_samples_split=4, model__n_estimators=1000, preprocessor__num__imputer__strategy=median; total time=   0.5s\n</pre> Out[200]: <pre>GridSearchCV(cv=5,\n             estimator=Pipeline(steps=[('preprocessor',\n                                        ColumnTransformer(transformers=[('cat',\n                                                                         Pipeline(steps=[('imputer',\n                                                                                          SimpleImputer(fill_value='missing',\n                                                                                                        strategy='constant')),\n                                                                                         ('onehot',\n                                                                                          OneHotEncoder(handle_unknown='ignore'))]),\n                                                                         ['Make',\n                                                                          'Colour']),\n                                                                        ('door',\n                                                                         Pipeline(steps=[('imputer',\n                                                                                          SimpleImputer(fill_value=4,\n                                                                                                        strategy='constant'))]),\n                                                                         ['Doors']),\n                                                                        ('num',\n                                                                         Pipeline(steps=[('imputer',\n                                                                                          SimpleImputer())]),\n                                                                         ['Odometer '\n                                                                          '(KM)'])])),\n                                       ('model',\n                                        RandomForestRegressor(n_jobs=-1))]),\n             param_grid={'model__max_depth': [None, 5],\n                         'model__max_features': ['sqrt'],\n                         'model__min_samples_split': [2, 4],\n                         'model__n_estimators': [100, 1000],\n                         'preprocessor__num__imputer__strategy': ['mean',\n                                                                  'median']},\n             verbose=2)</pre>In a Jupyter environment, please rerun this cell to show the HTML representation or trust the notebook. On GitHub, the HTML representation is unable to render, please try loading this page with nbviewer.org.\u00a0\u00a0GridSearchCV?Documentation for GridSearchCViFitted<pre>GridSearchCV(cv=5,\n             estimator=Pipeline(steps=[('preprocessor',\n                                        ColumnTransformer(transformers=[('cat',\n                                                                         Pipeline(steps=[('imputer',\n                                                                                          SimpleImputer(fill_value='missing',\n                                                                                                        strategy='constant')),\n                                                                                         ('onehot',\n                                                                                          OneHotEncoder(handle_unknown='ignore'))]),\n                                                                         ['Make',\n                                                                          'Colour']),\n                                                                        ('door',\n                                                                         Pipeline(steps=[('imputer',\n                                                                                          SimpleImputer(fill_value=4,\n                                                                                                        strategy='constant'))]),\n                                                                         ['Doors']),\n                                                                        ('num',\n                                                                         Pipeline(steps=[('imputer',\n                                                                                          SimpleImputer())]),\n                                                                         ['Odometer '\n                                                                          '(KM)'])])),\n                                       ('model',\n                                        RandomForestRegressor(n_jobs=-1))]),\n             param_grid={'model__max_depth': [None, 5],\n                         'model__max_features': ['sqrt'],\n                         'model__min_samples_split': [2, 4],\n                         'model__n_estimators': [100, 1000],\n                         'preprocessor__num__imputer__strategy': ['mean',\n                                                                  'median']},\n             verbose=2)</pre> best_estimator_: Pipeline<pre>Pipeline(steps=[('preprocessor',\n                 ColumnTransformer(transformers=[('cat',\n                                                  Pipeline(steps=[('imputer',\n                                                                   SimpleImputer(fill_value='missing',\n                                                                                 strategy='constant')),\n                                                                  ('onehot',\n                                                                   OneHotEncoder(handle_unknown='ignore'))]),\n                                                  ['Make', 'Colour']),\n                                                 ('door',\n                                                  Pipeline(steps=[('imputer',\n                                                                   SimpleImputer(fill_value=4,\n                                                                                 strategy='constant'))]),\n                                                  ['Doors']),\n                                                 ('num',\n                                                  Pipeline(steps=[('imputer',\n                                                                   SimpleImputer())]),\n                                                  ['Odometer (KM)'])])),\n                ('model',\n                 RandomForestRegressor(max_depth=5, max_features='sqrt',\n                                       n_jobs=-1))])</pre> \u00a0preprocessor: ColumnTransformer?Documentation for preprocessor: ColumnTransformer<pre>ColumnTransformer(transformers=[('cat',\n                                 Pipeline(steps=[('imputer',\n                                                  SimpleImputer(fill_value='missing',\n                                                                strategy='constant')),\n                                                 ('onehot',\n                                                  OneHotEncoder(handle_unknown='ignore'))]),\n                                 ['Make', 'Colour']),\n                                ('door',\n                                 Pipeline(steps=[('imputer',\n                                                  SimpleImputer(fill_value=4,\n                                                                strategy='constant'))]),\n                                 ['Doors']),\n                                ('num',\n                                 Pipeline(steps=[('imputer', SimpleImputer())]),\n                                 ['Odometer (KM)'])])</pre> cat<pre>['Make', 'Colour']</pre> \u00a0SimpleImputer?Documentation for SimpleImputer<pre>SimpleImputer(fill_value='missing', strategy='constant')</pre> \u00a0OneHotEncoder?Documentation for OneHotEncoder<pre>OneHotEncoder(handle_unknown='ignore')</pre> door<pre>['Doors']</pre> \u00a0SimpleImputer?Documentation for SimpleImputer<pre>SimpleImputer(fill_value=4, strategy='constant')</pre> num<pre>['Odometer (KM)']</pre> \u00a0SimpleImputer?Documentation for SimpleImputer<pre>SimpleImputer()</pre> \u00a0RandomForestRegressor?Documentation for RandomForestRegressor<pre>RandomForestRegressor(max_depth=5, max_features='sqrt', n_jobs=-1)</pre> <p>Now let's find the score of our model (by default <code>GridSearchCV</code> saves the best model to the <code>gs_model</code> object).</p> In\u00a0[201]: Copied! <pre># Score the best model\ngs_model.score(X_test, y_test)\n</pre> # Score the best model gs_model.score(X_test, y_test) Out[201]: <pre>0.2848784564026805</pre> <p>Beautiful!</p> <p>Using <code>GridSearchCV</code> we see a nice boost in our models score.</p> <p>And the best thing is, because it's all in a <code>Pipeline</code>, we could easily replicate these results.</p>"},{"location":"introduction-to-scikit-learn/#a-quick-machine-learning-modelling-tutorial-with-python-and-scikit-learn","title":"A Quick Machine Learning Modelling Tutorial with Python and Scikit-Learn\u00b6","text":"<p>This notebook goes through a range of common and useful featues of the Scikit-Learn library.</p> <p>There's a bunch here but I'm calling it quick because of how vast the Scikit-Learn library is.</p> <p>Covering everything requires a full-blown documentation, of which, if you ever get stuck, I'd highly recommend checking out.</p>"},{"location":"introduction-to-scikit-learn/#what-is-scikit-learn-sklearn","title":"What is Scikit-Learn (sklearn)?\u00b6","text":"<p>Scikit-Learn, also referred to as <code>sklearn</code>, is an open-source Python machine learning library.</p> <p>It's built on top on NumPy (Python library for numerical computing) and Matplotlib (Python library for data visualization).</p> <p></p>"},{"location":"introduction-to-scikit-learn/#why-scikit-learn","title":"Why Scikit-Learn?\u00b6","text":"<p>Although the fields of data science and machine learning are vast, the main goal is finding patterns within data and then using those patterns to make predictions.</p> <p>And there are certain categories which a majority of problems fall into.</p> <p>If you're trying to create a machine learning model to predict whether an email is spam and or not spam, you're working on a classification problem (whether something is one thing or another).</p> <p>If you're trying to create a machine learning model to predict the price of houses given their characteristics, you're working on a regression problem (predicting a number).</p> <p>If you're trying to get a machine learning algorithm to group together similar samples (that you don't necessarily know which should go together), you're working on a clustering problem.</p> <p>Once you know what kind of problem you're working on, there are also similar steps you'll take for each.</p> <p>Steps like splitting the data into different sets, one for your machine learning algorithms to learn on (the training set) and another to test them on (the testing set).</p> <p>Choosing a machine learning model and then evaluating whether or not your model has learned anything.</p> <p>Scikit-Learn offers Python implementations for doing all of these kinds of tasks (from preparing data to modelling data). Saving you from having to build them from scratch.</p>"},{"location":"introduction-to-scikit-learn/#what-does-this-notebook-cover","title":"What does this notebook cover?\u00b6","text":"<p>The Scikit-Learn library is very capable. However, learning everything off by heart isn't necessary. Instead, this notebook focuses some of the main use cases of the library.</p> <p>More specifically, we'll cover:</p> <p></p> <ol> <li>An end-to-end Scikit-Learn worfklow</li> <li>Getting the data ready</li> <li>Choosing the right maching learning estimator/aglorithm/model for your problem</li> <li>Fitting your chosen machine learning model to data and using it to make a prediction</li> <li>Evaluting a machine learning model</li> <li>Improving predictions through experimentation (hyperparameter tuning)</li> <li>Saving and loading a pretrained model</li> <li>Putting it all together in a pipeline</li> </ol> <p>Note: All of the steps in this notebook are focused on supervised learning (having data and labels). The other side of supervised learning is unsupervised learning (having data but no labels).</p> <p>After going through it, you'll have the base knolwedge of Scikit-Learn you need to keep moving forward.</p>"},{"location":"introduction-to-scikit-learn/#where-can-i-get-help","title":"Where can I get help?\u00b6","text":"<p>If you get stuck or think of something you'd like to do which this notebook doesn't cover, don't fear!</p> <p>The recommended steps you take are:</p> <ol> <li>Try it - Since Scikit-Learn has been designed with usability in mind, your first step should be to use what you know and try figure out the answer to your own question (getting it wrong is part of the process). If in doubt, run your code.</li> <li>Press SHIFT+TAB - See you can the docstring of a function (information on what the function does) by pressing SHIFT + TAB inside it. Doing this is a good habit to develop. It'll improve your research skills and give you a better understanding of the library.</li> <li>Search for it - If trying it on your own doesn't work, since someone else has probably tried to do something similar, try searching for your problem. You'll likely end up in 1 of 2 places:<ul> <li>Scikit-Learn documentation/user guide - the most extensive resource you'll find for Scikit-Learn information.</li> <li>Stack Overflow - this is the developers Q&amp;A hub, it's full of questions and answers of different problems across a wide range of software development topics and chances are, there's one related to your problem.</li> <li>ChatGPT - ChatGPT is very good at explaining code, however, it can make mistakes. Best to verify the code it writes first before using it. Try asking \"Can you explain the following code for me? {your code here}\" and then continue with follow up questions from there. Avoid blindly trusting code you didn't write for yourself.</li> </ul> </li> </ol> <p>An example of searching for a Scikit-Learn solution might be:</p> <p>\"how to tune the hyperparameters of a sklearn model\"</p> <p>Searching this on Google leads to the Scikit-Learn documentation for the <code>GridSearchCV</code> function: http://scikit-learn.org/stable/modules/grid_search.html</p> <p>The next steps here are to read through the documentation, check the examples and see if they line up to the problem you're trying to solve. If they do, rewrite the code to suit your needs, run it, and see what the outcomes are.</p> <ol> <li>Ask for help - If you've been through the above 3 steps and you're still stuck, you might want to ask your question on Stack Overflow or in the ZTM Machine Learning and AI Discord channel. Be as specific as possible and provide details on what you've tried.</li> </ol> <p>Remember, you don't have to learn all of the functions off by heart to begin with.</p> <p>What's most important is continually asking yourself, \"what am I trying to do with the data?\".</p> <p>Start by answering that question and then practicing finding the code which does it.</p> <p>Let's get started.</p> <p>First we'll import the libraries we've been using previously.</p> <p>We'll also check the version of <code>sklearn</code> we've got.</p>"},{"location":"introduction-to-scikit-learn/#0-an-end-to-end-scikit-learn-workflow","title":"0. An end-to-end Scikit-Learn workflow\u00b6","text":"<p>Before we get in-depth, let's quickly check out what an end-to-end Scikit-Learn workflow might look like.</p> <p>Once we've seen an end-to-end workflow, we'll dive into each step a little deeper.</p> <p>Specifically, we'll get hands-on with the following steps:</p> <ol> <li>Getting data ready (split into features and labels, prepare train and test steps)</li> <li>Choosing a model for our problem</li> <li>Fit the model to the data and use it to make a prediction</li> <li>Evaluate the model</li> <li>Experiment to improve</li> <li>Save a model for someone else to use</li> </ol> <p>Note: The following section is a bit information heavy but it is an end-to-end workflow. We'll go through it quite swiftly but we'll break it down more throughout the rest of the notebook. And since Scikit-Learn is such a vast library, capable of tackling many problems, the workflow we're using is only one example of how you can use it.</p>"},{"location":"introduction-to-scikit-learn/#random-forest-classifier-workflow-for-classifying-heart-disease","title":"Random Forest Classifier Workflow for Classifying Heart Disease\u00b6","text":""},{"location":"introduction-to-scikit-learn/#1-get-the-data-ready","title":"1. Get the data ready\u00b6","text":"<p>As an example dataset, we'll import <code>heart-disease.csv</code>.</p> <p>This file contains anonymised patient medical records and whether or not they have heart disease or not (this is a classification problem since we're trying to predict whether something is one thing or another).</p>"},{"location":"introduction-to-scikit-learn/#2-choose-the-model-and-hyperparameters","title":"2. Choose the model and hyperparameters\u00b6","text":"<p>Choosing a model often depends on the type of problem you're working on.</p> <p>For example, there are different models that Scikit-Learn recommends whether you're working on a classification or regression problem.</p> <p>You can see a map breaking down the different kinds of model options and recommendations in the Scikit-Learn documentation.</p> <p>Scikit-Learn refers to models as \"estimators\", however, they are often also referred to as <code>model</code> or <code>clf</code> (short for classifier).</p> <p>A model's hyperparameters are settings you can change to adjust it for your problem, much like knobs on an oven you can tune to cook your favourite dish.</p>"},{"location":"introduction-to-scikit-learn/#3-fit-the-model-to-the-data-and-use-it-to-make-a-prediction","title":"3. Fit the model to the data and use it to make a prediction\u00b6","text":"<p>Fitting a model a dataset involves passing it the data and asking it to figure out the patterns.</p> <p>If there are labels (supervised learning), the model tries to work out the relationship between the data and the labels.</p> <p>If there are no labels (unsupervised learning), the model tries to find patterns and group similar samples together.</p> <p>Most Scikit-Learn models have the <code>fit(X, y)</code> method built-in, where the <code>X</code> parameter is the features and the <code>y</code> parameter is the labels.</p> <p>In our case, we start by fitting a model on the training split (<code>X_train</code>, <code>y_train</code>).</p>"},{"location":"introduction-to-scikit-learn/#use-the-model-to-make-a-prediction","title":"Use the model to make a prediction\u00b6","text":"<p>The whole point of training a machine learning model is to use it to make some kind of prediction in the future.</p> <p>Once your model instance is trained, you can use the <code>predict()</code> method to predict a target value given a set of features.</p> <p>In other words, use the model, along with some new, unseen and unlabelled data to predict the label.</p> <p>Note: Data you predict on should be in the same shape and format as data you trained on.</p>"},{"location":"introduction-to-scikit-learn/#4-evaluate-the-model","title":"4. Evaluate the model\u00b6","text":"<p>Now we've made some predictions, we can start to use some more Scikit-Learn methods to figure out how good our model is.</p> <p>Each model or estimator has a built-in <code>score()</code> method.</p> <p>This method compares how well the model was able to learn the patterns between the features and labels.</p> <p>The <code>score()</code> method for each model uses a standard evaluation metric to measure your model's results.</p> <p>In the case of a classifier (our model), one of the most common evaluation metrics is accuracy (the fraction of correct predictions out of total predictions).</p> <p>Let's check out our model's accuracy on the training set.</p>"},{"location":"introduction-to-scikit-learn/#5-experiment-to-improve","title":"5. Experiment to improve\u00b6","text":"<p>The first model you build is often referred to as a baseline (a baseline is often even simpler than the model we've used, a baseline could be \"let's just by default predict the most common value and then try to improve\").</p> <p>Once you've got a baseline model, like we have here, it's important to remember, this is often not the final model you'll use.</p> <p>The next step in the workflow is to try and improve upon your baseline model.</p> <p>How?</p> <p>With one of the most important mottos in machine learning...</p> <p>Experiment, experiment, experiment!</p> <p>Experiments can come in many different forms.</p> <p>But let's break it into two.</p> <ol> <li>From a model perspective.</li> <li>From a data perspective.</li> </ol> <p>From a model perspective may involve things such as using a more complex model or tuning your models hyperparameters.</p> <p>From a data perspective may involve collecting more data or better quality data so your existing model has more of a chance to learn the patterns within.</p> <p>If you're already working on an existing dataset, it's often easier try a series of model perspective experiments first and then turn to data perspective experiments if you aren't getting the results you're looking for.</p> <p>One thing you should be aware of is if you're tuning a models hyperparameters in a series of experiments, your reuslts should always be cross-validated (we'll see this later on!).</p> <p>Cross-validation is a way of making sure the results you're getting are consistent across your training and test datasets (because it uses multiple versions of training and test sets) rather than just luck because of the order the original training and test sets were created.</p> <ul> <li>Try different hyperparameters.</li> <li>All different parameters should be cross-validated.<ul> <li>Note: Beware of cross-validation for time series problems (as for time series, you don't want to mix samples from the future with samples from the past).</li> </ul> </li> </ul> <p>Different models you use will have different hyperparameters you can tune.</p> <p>For the case of our model, the <code>RandomForestClassifier()</code>, we'll start trying different values for <code>n_estimators</code> (a measure for the number of trees in the random forest).</p> <p>By default, <code>n_estimators=100</code>, so how about we try values from <code>100</code> to <code>200</code> and see what happens (generally more is better)?</p>"},{"location":"introduction-to-scikit-learn/#6-save-a-model-for-someone-else-to-use","title":"6. Save a model for someone else to use\u00b6","text":"<p>When you've done a few experiments and you're happy with how your model is doing, you'll likely want someone else to be able to use it.</p> <p>This may come in the form of a teammate or colleague trying to replicate and validate your results or through a customer using your model as part of a service or application you offer.</p> <p>Saving a model also allows you to reuse it later without having to go through retraining it. Which is helpful, especially when your training times start to increase.</p> <p>You can save a Scikit-Learn model using Python's in-built <code>pickle</code> module.</p>"},{"location":"introduction-to-scikit-learn/#1-getting-the-data-ready","title":"1. Getting the data ready\u00b6","text":"<p>Data doesn't always come ready to use with a Scikit-Learn machine learning model.</p> <p>Three of the main steps you'll often have to take are:</p> <ul> <li>Splitting the data into features (usually <code>X</code>) and labels (usually <code>y</code>).</li> <li>Splitting the data into training and testing sets (and possibly a validation set).</li> <li>Filling (also called imputing) or disregarding missing values.</li> <li>Converting non-numerical values to numerical values (also call feature encoding).</li> </ul> <p>Let's see an example.</p>"},{"location":"introduction-to-scikit-learn/#11-make-sure-its-all-numerical","title":"1.1 Make sure it's all numerical\u00b6","text":"<p>Computers love numbers.</p> <p>So one thing you'll often have to make sure of is that your datasets are in numerical form.</p> <p>This even goes for datasets which contain non-numerical features that you may want to include in a model.</p> <p>For example, if we were working with a car sales dataset, how might we turn features such as <code>Make</code> and <code>Colour</code> into numbers?</p> <p>Let's figure it out.</p> <p>First, we'll import the <code>car-sales-extended.csv</code> dataset.</p>"},{"location":"introduction-to-scikit-learn/#111-nuemrically-encoding-data-with-pandas","title":"1.1.1 Nuemrically encoding data with pandas\u00b6","text":"<p>Another way we can numerically encode data is directly with pandas.</p> <p>We can use the <code>pandas.get_dummies()</code> (or <code>pd.get_dummies()</code> for short) method and then pass it our target columns.</p> <p>In return, we'll get a one-hot encoded version of our target columns.</p> <p>Let's remind ourselves of what our DataFrame looks like.</p>"},{"location":"introduction-to-scikit-learn/#12-what-if-there-were-missing-values-in-the-data","title":"1.2 What if there were missing values in the data?\u00b6","text":"<p>Holes in the data means holes in the patterns your machine learning model can learn.</p> <p>Many machine learning models don't work well or produce errors when they're used on datasets with missing values.</p> <p>A missing value can appear as a blank, as a <code>NaN</code> or something similar.</p> <p>There are two main options when dealing with missing values:</p> <ol> <li>Fill them with some given or calculated value (imputation) - For example, you might fill missing values of a numerical column with the mean of all the other values. The practice of calculating or figuring out how to fill missing values in a dataset is called imputing. For a great resource on imputing missing values, I'd recommend refering to the Scikit-Learn user guide.</li> <li>Remove them - If a row or sample has missing values, you may opt to remove them from your dataset completely. However, this potentially results in using less data to build your model.</li> </ol> <p>Note: Dealing with missing values differs from problem to problem, meaning there's no 100% best way to fill missing values across datasets and problem types. It will often take careful experimentation and practice to figure out the best way to deal with missing values in your own datasets.</p> <p>To practice dealing with missing values, let's import a version of the <code>car_sales</code> dataset with several missing values (namely <code>car-sales-extended-missing-data.csv</code>).</p>"},{"location":"introduction-to-scikit-learn/#121-fill-missing-data-with-pandas","title":"1.2.1 Fill missing data with pandas\u00b6","text":"<p>Let's see how we might fill missing values with pandas.</p> <p>For categorical values, one of the simplest ways is to fill the missing fields with the string <code>\"missing\"</code>.</p> <p>We could do this for the <code>Make</code> and <code>Colour</code> features.</p> <p>As for the <code>Doors</code> feature, we could use <code>\"missing\"</code> or we could fill it with the most common option of <code>4</code>.</p> <p>With the <code>Odometer (KM)</code> feature, we can use the mean value of all the other values in the column.</p> <p>And finally, for those samples which are missing a <code>Price</code> value, we can remove them (since <code>Price</code> is the target value, removing probably causes less harm than imputing, however, you could design an experiment to test this).</p> <p>In summary:</p> Column/Feature Fill missing value with <code>Make</code> <code>\"missing\"</code> <code>Colour</code> <code>\"missing\"</code> <code>Doors</code> 4 (most common value) <code>Odometer (KM)</code> mean of <code>Odometer (KM)</code> <code>Price</code> (target) NA, remove samples missing <code>Price</code> <p>Note: The practice of filling missing data with given or calculated values is called imputation. And it's important to remember there's no perfect way to fill missing data (unless it's with data that should've actually been there in the first place). The methods we're using are only one of many. The techniques you use will depend heavily on your dataset. A good place to look would be searching for \"data imputation techniques\".</p> <p>Let's start with the <code>Make</code> column.</p> <p>We can use the pandas method <code>fillna(value=\"missing\", inplace=True)</code> to fill all the missing values with the string <code>\"missing\"</code>.</p>"},{"location":"introduction-to-scikit-learn/#122-filling-missing-data-and-transforming-categorical-data-with-scikit-learn","title":"1.2.2 Filling missing data and transforming categorical data with Scikit-Learn\u00b6","text":"<p>Now we've filled the missing columns using pandas functions, you might be thinking, \"Why pandas? I thought this was a Scikit-Learn introduction?\".</p> <p>Not to worry, Scikit-Learn provides a class called <code>sklearn.impute.SimpleImputer()</code> which allows us to do a similar thing.</p> <p><code>SimpleImputer()</code> transforms data by filling missing values with a given <code>strategy</code> parameter.</p> <p>And we can use it to fill the missing values in our DataFrame as above.</p> <p>At the moment, our dataframe has no mising values.</p>"},{"location":"introduction-to-scikit-learn/#2-choosing-the-right-estimatoralgorithm-for-your-problem","title":"2. Choosing the right estimator/algorithm for your problem\u00b6","text":"<p>Once you've got your data ready, the next step is to choose an appropriate machine learning algorithm or model to find patterns in your data.</p> <p>Some things to note:</p> <ul> <li>Scikit-Learn refers to machine learning models and algorithms as estimators.</li> <li>Classification problem - predicting a category (heart disease or not).<ul> <li>Sometimes you'll see <code>clf</code> (short for classifier) used as a classification estimator instance's variable name.</li> </ul> </li> <li>Regression problem - predicting a number (selling price of a car).</li> <li>Unsupervised problem (data with no labels) - clustering (grouping unlabelled samples with other similar unlabelled samples).</li> </ul> <p>If you know what kind of problem you're working with, one of the next places you should look at is the Scikit-Learn algorithm cheatsheet.</p> <p>This cheatsheet gives you a bit of an insight into the algorithm you might want to use for the problem you're working on.</p> <p>It's important to remember, you don't have to explicitly know what each algorithm is doing on the inside to start using them.</p> <p>If you start to apply different algorithms but they don't seem to be working (not performing as well as you'd like), that's when you'd start to look deeper into each one.</p> <p>Let's check out the cheatsheet and follow it for some of the problems we're working on.</p> <p>You can see it's split into four main categories. Regression, classification, clustering and dimensionality reduction. Each has their own different purpose but the Scikit-Learn team has designed the library so the workflows for each are relatively similar.</p>"},{"location":"introduction-to-scikit-learn/#21-picking-a-machine-learning-model-for-a-regression-problem","title":"2.1 Picking a machine learning model for a regression problem\u00b6","text":"<p>Let's start with a regression problem (trying to predict a number). We'll use the California Housing dataset built into Scikit-Learn's <code>datasets</code> module.</p> <p>The goal of the California Housing dataset is to predict a given district's median house value (in hundreds of thousands of dollars) on things like the age of the home, the number of rooms, the number of bedrooms, number of people living the home and more.</p>"},{"location":"introduction-to-scikit-learn/#22-picking-a-machine-learning-model-for-a-classification-problem","title":"2.2 Picking a machine learning model for a classification problem\u00b6","text":"<p>Now, let's check out the choosing process for a classification problem.</p> <p>Say you were trying to predict whether or not a patient had heart disease based on their medical records.</p> <p>The dataset in <code>../data/heart-disease.csv</code> (or at <code>heart-disease.csv</code>) contains data for just that problem.</p>"},{"location":"introduction-to-scikit-learn/#what-about-the-other-models","title":"What about the other models?\u00b6","text":"<p>Looking at the Scikit-Learn aglorithm cheat-sheet and the examples above, you may have noticed we've skipped a few models.</p> <p>Why?</p> <p>The first reason is time.</p> <p>Covering every single one would take a fair bit longer than what we've done here. And the second one is the effectiveness of ensemble methods.</p> <p>A little tidbit for modelling in machine learning is:</p> <ul> <li>If you have structured data (tables, spreadsheets or dataframes), use ensemble methods, such as, a Random Forest.</li> <li>If you have unstructured data (text, images, audio, things not in tables), use deep learning or transfer learning (see the ZTM TensorFlow and PyTorch courses for more on deep learning).</li> </ul> <p>For this notebook, we're focused on structured data, which is why the Random Forest has been our model of choice.</p> <p>If you'd like to learn more about the Random Forest and why it's the war horse of machine learning, check out these resources:</p> <ul> <li>Random Forest Wikipedia</li> <li>An Implementation and Explanation of the Random Forest in Python by Will Koehrsen</li> </ul>"},{"location":"introduction-to-scikit-learn/#experiment-until-something-works","title":"Experiment until something works\u00b6","text":"<p>The beautiful thing is, the way the Scikit-Learn API is designed, once you know the way with one model, using another is much the same.</p> <p>And since a big part of being a machine learning engineer or data scientist is experimenting, you might want to try out some of the other models on the cheat-sheet and see how you go. The more you can reduce the time between experiments, the better.</p>"},{"location":"introduction-to-scikit-learn/#3-fit-the-model-to-data-and-using-it-to-make-predictions","title":"3. Fit the model to data and using it to make predictions\u00b6","text":"<p>Now you've chosen a model, the next step is to have it learn from the data so it can be used for predictions in the future.</p> <p>If you've followed through, you've seen a few examples of this already.</p>"},{"location":"introduction-to-scikit-learn/#31-fitting-a-model-to-data","title":"3.1 Fitting a model to data\u00b6","text":"<p>In Scikit-Learn, the process of having a machine learning model learn patterns from a dataset involves calling the <code>fit()</code> method and passing it data, such as, <code>fit(X, y)</code>.</p> <p>Where <code>X</code> is a feature array and <code>y</code> is a target array.</p> <p>Other names for <code>X</code> include:</p> <ul> <li>Data</li> <li>Feature variables</li> <li>Features</li> </ul> <p>Other names for <code>y</code> include:</p> <ul> <li>Labels</li> <li>Target variable</li> </ul> <p>For supervised learning there is usually an <code>X</code> and <code>y</code>.</p> <p>For unsupervised learning, there's no <code>y</code> (no labels).</p> <p>Let's revisit the example of using patient data (<code>X</code>) to predict whether or not they have heart disease (<code>y</code>).</p>"},{"location":"introduction-to-scikit-learn/#32-making-predictions-using-a-machine-learning-model","title":"3.2 Making predictions using a machine learning model\u00b6","text":"<p>Now we've got a trained model, one which has hoepfully learned patterns in the data, you'll want to use it to make predictions.</p> <p>Scikit-Learn enables this in several ways.</p> <p>Two of the most common and useful are <code>predict()</code> and <code>predict_proba()</code>.</p> <p>Let's see them in action.</p>"},{"location":"introduction-to-scikit-learn/#4-evaluating-a-model","title":"4. Evaluating a model\u00b6","text":"<p>Once you've trained a model, you'll want a way to measure how trustworthy its predictions are.</p> <p>Across the board, the main idea of evaluating a model is to compare the model's predictions to what they should've ideally been (the truth labels).</p> <p>Scikit-Learn implements 3 different methods of evaluating models.</p> <ol> <li>The <code>score()</code> method. Calling <code>score()</code> on a model instance will return a metric assosciated with the type of model you're using. The metric depends on which model you're using.</li> <li>The <code>scoring</code> parameter. This parameter can be passed to methods such as <code>cross_val_score()</code> or <code>GridSearchCV()</code> to tell Scikit-Learn to use a specific type of scoring metric.</li> <li>Problem-specific metric functions available in <code>sklearn.metrics</code>. Similar to how the <code>scoring</code> parameter can be passed different scoring functions, Scikit-Learn implements these as stand alone functions.</li> </ol> <p>The scoring function you use will also depend on the problem you're working on.</p> <p>Classification problems have different evaluation metrics and scoring functions to regression problems.</p> <p>Let's look at some examples.</p>"},{"location":"introduction-to-scikit-learn/#41-general-model-evaluation-with-score","title":"4.1 General model evaluation with <code>score()</code>\u00b6","text":"<p>If we bring down the code from our previous classification problem (building a classifier to predict whether or not someone has heart disease based on their medical records).</p> <p>We can see the <code>score()</code> method come into play.</p>"},{"location":"introduction-to-scikit-learn/#42-evaluating-your-models-using-the-scoring-parameter","title":"4.2 Evaluating your models using the <code>scoring</code> parameter\u00b6","text":"<p>The next step up from using <code>score()</code> is to use a custom <code>scoring</code> parameter with <code>cross_val_score()</code> or <code>GridSearchCV</code>.</p> <p>As you may have guessed, the <code>scoring</code> parameter you set will be different depending on the problem you're working on.</p> <p>We'll see some specific examples of different parameters in a moment but first let's check out <code>cross_val_score()</code>.</p> <p>To do so, we'll copy the heart disease classification code from above and then add another line at the top.</p>"},{"location":"introduction-to-scikit-learn/#421-classification-model-evaluation-metrics","title":"4.2.1 Classification model evaluation metrics\u00b6","text":"<p>Four of the main evaluation metrics/methods you'll come across for classification models are:</p> <ol> <li>Accuracy</li> <li>Area under ROC curve (receiver operating characteristic curve)</li> <li>Confusion matrix</li> <li>Classification report</li> </ol> <p>Let's have a look at each of these. We'll bring down the classification code from above to go through some examples.</p>"},{"location":"introduction-to-scikit-learn/#accuracy","title":"Accuracy\u00b6","text":"<p>Accuracy is the default metric for the <code>score()</code> function within each of Scikit-Learn's classifier models. And it's probably the metric you'll see most often used for classification problems.</p> <p>However, we'll see in a second how it may not always be the best metric to use.</p> <p>Scikit-Learn returns accuracy as a decimal but you can easily convert it to a percentage.</p>"},{"location":"introduction-to-scikit-learn/#area-under-receiver-operating-characteristic-roc-curve","title":"Area Under Receiver Operating Characteristic (ROC) Curve\u00b6","text":"<p>If this one sounds like a mouthful, its because reading the full name is.</p> <p>It's usually referred to as AUC for Area Under Curve and the curve they're talking about is the Receiver Operating Characteristic or ROC for short.</p> <p>So if hear someone talking about AUC or ROC, they're probably talking about what follows.</p> <p>ROC curves are a comparison of true postive rate (tpr) versus false positive rate (fpr).</p> <p>For clarity:</p> <ul> <li>True positive = model predicts 1 when truth is 1</li> <li>False positive = model predicts 1 when truth is 0</li> <li>True negative = model predicts 0 when truth is 0</li> <li>False negative = model predicts 0 when truth is 1</li> </ul> <p>Now we know this, let's see one. Scikit-Learn lets you calculate the information required for a ROC curve using the <code>roc_curve</code> function.</p>"},{"location":"introduction-to-scikit-learn/#confusion-matrix","title":"Confusion matrix\u00b6","text":"<p>Another fantastic way to evaluate a classification model is by using a confusion matrix.</p> <p>A confusion matrix is a quick way to compare the labels a model predicts and the actual labels it was supposed to predict.</p> <p>In essence, giving you an idea of where the model is getting confused.</p>"},{"location":"introduction-to-scikit-learn/#creating-a-confusion-matrix-using-scikit-learn","title":"Creating a confusion matrix using Scikit-Learn\u00b6","text":"<p>Scikit-Learn has multiple different implementations of plotting confusion matrices:</p> <ol> <li><code>sklearn.metrics.ConfusionMatrixDisplay.from_estimator(estimator, X, y)</code> - this takes a fitted estimator (like our <code>clf</code> model), features (<code>X</code>) and labels (<code>y</code>), it then uses the trained estimator to make predictions on <code>X</code> and compares the predictions to <code>y</code> by displaying a confusion matrix.</li> <li><code>sklearn.metrics.ConfusionMatrixDisplay.from_predictions(y_true, y_pred)</code> - this takes truth labels and predicted labels and compares them by displaying a confusion matrix.</li> </ol> <p>Note: Both of these methods/classes require Scikit-Learn 1.0+. To check your version of Scikit-Learn run:</p> <pre>import sklearn\nsklearn.__version__\n</pre> <p>If you don't have 1.0+, you can upgrade at: https://scikit-learn.org/stable/install.html</p>"},{"location":"introduction-to-scikit-learn/#classification-report","title":"Classification report\u00b6","text":"<p>The final major metric you should consider when evaluating a classification model is a classification report.</p> <p>A classification report is more so a collection of metrics rather than a single one.</p> <p>You can create a classification report using Scikit-Learn's sklearn.metrics.classification_report` method.</p> <p>Let's see one.</p>"},{"location":"introduction-to-scikit-learn/#422-regression-model-evaluation-metrics","title":"4.2.2 Regression model evaluation metrics\u00b6","text":"<p>Similar to classification, there are several metrics you can use to evaluate your regression models.</p> <p>We'll check out the following.</p> <ol> <li>R^2 (pronounced r-squared) or coefficient of determination - Compares your models predictions to the mean of the targets. Values can range from negative infinity (a very poor model) to 1. For example, if all your model does is predict the mean of the targets, its R^2 value would be 0. And if your model perfectly predicts a range of numbers it's R^2 value would be 1. Higher is better.</li> <li>Mean absolute error (MAE) - The average of the absolute differences between predictions and actual values. It gives you an idea of how wrong your predictions were. Lower is better.</li> <li>Mean squared error (MSE) - The average squared differences between predictions and actual values. Squaring the errors removes negative errors. It also amplifies outliers (samples which have larger errors). Lower is better.</li> </ol> <p>Let's see them in action. First, we'll bring down our regression model code again.</p>"},{"location":"introduction-to-scikit-learn/#423-evaluating-a-model-using-the-scoring-parameter","title":"4.2.3 Evaluating a model using the <code>scoring</code> parameter\u00b6","text":"<p>We've covered a bunch of ways to evaluate a model's predictions but haven't even touched the <code>scoring</code> parameter...</p> <p>Not to worry, it's very similar to what we've been doing!</p> <p>As a refresh, the <code>scoring</code> parameter can be used with a function like <code>cross_val_score()</code> to tell Scikit-Learn what evaluation metric to return using cross-validation.</p> <p>Let's check it out with our classification model and the heart disease dataset.</p>"},{"location":"introduction-to-scikit-learn/#43-using-different-evaluation-metrics-with-scikit-learn","title":"4.3 Using different evaluation metrics with Scikit-Learn\u00b6","text":"<p>Remember the third way of evaluating Scikit-Learn functions?</p> <ol> <li>Problem-specific metric functions. Similar to how the <code>scoring</code> parameter can be passed different scoring functions, Scikit-Learn implements these as stand alone functions.</li> </ol> <p>Well, we've kind of covered this third way of using evaulation metrics with Scikit-Learn.</p> <p>In essence, all of the metrics we've seen previously have their own function in Scikit-Learn.</p> <p>They all work by comparing an array of predictions, usually called <code>y_preds</code> to an array of actual labels, usually called <code>y_test</code> or <code>y_true</code>.</p>"},{"location":"introduction-to-scikit-learn/#classification-functions","title":"Classification functions\u00b6","text":"<p>For:</p> <ul> <li>Accuracy we can use <code>sklearn.metrics.accuracy_score</code></li> <li>Precision we can use <code>sklearn.metrics.precision_score</code></li> <li>Recall we can use <code>sklearn.metrics.recall_score</code></li> <li>F1 we can use <code>sklearn.metrics.f1_score</code></li> </ul>"},{"location":"introduction-to-scikit-learn/#regression-metrics","title":"Regression metrics\u00b6","text":"<p>We can use a similar setup for our regression problem, just with different methods.</p> <p>For:</p> <ul> <li>R^2 we can use <code>sklearn.metrics.r2_score</code></li> <li>MAE (mean absolute error) we can use <code>sklearn.metrics.mean_absolute_error</code></li> <li>MSE (mean squared error) we can use <code>sklearn.metrics.mean_squared_error</code></li> </ul>"},{"location":"introduction-to-scikit-learn/#5-improving-model-predictions-through-experimentation-hyperparameter-tuning","title":"5. Improving model predictions through experimentation (hyperparameter tuning)\u00b6","text":"<p>The first predictions you make with a model are generally referred to as baseline predictions.</p> <p>It's similar for the first evaluation metrics you get. These are generally referred to as baseline metrics.</p> <p>Your next goal is to improve upon these baseline metrics.</p> <p>How?</p> <p>Experiment, experiment, experiment!</p> <p>Two of the main methods to improve baseline metrics are:</p> <ol> <li>From a data perspective.</li> <li>From a model perspective.</li> </ol> <p>From a data perspective asks:</p> <ul> <li>Could we collect more data? In machine learning, more data is generally better, as it gives a model more opportunities to learn patterns.</li> <li>Could we improve our data? This could mean filling in misisng values or finding a better encoding (turning data into numbers) strategy.</li> </ul> <p>From a model perspective asks:</p> <ul> <li>Is there a better model we could use? If you've started out with a simple model, could you use a more complex one? (we saw an example of this when looking at the Scikit-Learn machine learning map, ensemble methods are generally considered more complex models)</li> <li>Could we improve the current model? If the model you're using performs well straight out of the box, can the hyperparameters be tuned to make it even better?</li> </ul> <p>Note: Patterns in data are also often referred to as data parameters. The difference between parameters and hyperparameters is a machine learning model seeks to find parameters in data on its own, where as, hyperparameters are settings on a model which a person (you) can adjust.</p> <p>Since we have two existing datasets, we'll look at improving our results from a model perspective.</p> <p>More specifically, we'll look at how we could improve our <code>RandomForestClassifier</code> and <code>RandomForestRegressor</code> models through hyperparameter tuning.</p> <p>What even are hyperparameters?</p> <p>Good question, let's check them out.</p> <p>First, we'll instantiate a <code>RandomForestClassifier</code>.</p>"},{"location":"introduction-to-scikit-learn/#51-tuning-hyperparameters-by-hand","title":"5.1 Tuning hyperparameters by hand\u00b6","text":"<p>So far we've worked with training and test datasets.</p> <p>You train a model on a training set and evaluate it on a test dataset.</p> <p>But hyperparameter tuning introduces a thrid set, a validation set.</p> <p>Now the process becomes:</p> <ol> <li>Train a model on the training data.</li> <li>(Try to) improve the model's hyperparameters on the validation set.</li> <li>Evaluate the model on the test set.</li> </ol> <p>If our starting dataset contained 100 different patient records labels indicating who had heart disease and who didn't and we wanted to build a machine learning model to predict who had heart disease and who didn't, it might look like this:</p> <p>Since we know we're using a <code>RandomForestClassifier</code> and we know the hyperparameters we want to adjust, let's see what it looks like.</p> <p>First, let's remind ourselves of the base parameters.</p>"},{"location":"introduction-to-scikit-learn/#52-hyperparameter-tuning-with-randomizedsearchcv","title":"5.2 Hyperparameter tuning with <code>RandomizedSearchCV</code>\u00b6","text":"<p>Scikit-Learn's <code>sklearn.model_selection.RandomizedSearchCV</code> allows us to randomly search across different hyperparameters to see which work best.</p> <p>It also stores details about the ones which work best!</p> <p>Let's see it in action.</p> <p>First, we create a dictionary of parameter distributions (collections of different values for specific hyperparamters) we'd like to search over.</p> <p>This dictionary comes in the form:</p> <pre>param_distributions = {\"hyperparameter_name\": [values_to_randomly_try]}\n</pre> <p>Where <code>\"hyperparameter_name\"</code> is the value of a specific hyperparameter for a model and <code>[values_to_randomly_try]</code> is a list of values for that specific hyperparamter to randomly try.</p>"},{"location":"introduction-to-scikit-learn/#53-hyperparameter-tuning-with-gridsearchcv","title":"5.3 Hyperparameter tuning with <code>GridSearchCV</code>\u00b6","text":"<p>There's one more way we could try to improve our model's hyperparamters.</p> <p>And it's with <code>sklearn.model_selection.GridSearchCV</code>.</p> <p>The main difference between <code>GridSearchCV</code> and <code>RandomizedSearchCV</code> is <code>GridSearchCV</code> searches across a grid of hyperparamters exhaustively (it will try every combination possible), where as, <code>RandomizedSearchCV</code> searches across a grid of hyperparameters randomly (stopping after <code>n_iter</code> combinations).</p> <p><code>GridSearchCV</code> also refers to a dictionary of parameter distributions as a parameter grid (via the parameter <code>param_grid</code>).</p> <p>For example, let's see our dictionary of hyperparameters.</p>"},{"location":"introduction-to-scikit-learn/#6-saving-and-loading-trained-machine-learning-models","title":"6. Saving and loading trained machine learning models\u00b6","text":"<p>Our <code>GridSearchCV</code> model (<code>gs_clf</code>) has the best results so far, we'll export it and save it to file.</p>"},{"location":"introduction-to-scikit-learn/#61-saving-and-loading-a-model-with-pickle","title":"6.1 Saving and loading a model with <code>pickle</code>\u00b6","text":"<p>We saw right at the start, one way to save a model is using Python's <code>pickle</code> module.</p> <p>We'll use <code>pickle</code>'s <code>dump()</code> method and pass it our model, <code>gs_clf</code>, along with the <code>open()</code> function containing a string for the filename we want to save our model as, along with the <code>\"wb\"</code> string which stands for \"write binary\", which is the file type <code>open()</code> will write our model as.</p>"},{"location":"introduction-to-scikit-learn/#62-saving-and-loading-a-model-with-joblib","title":"6.2 Saving and loading a model with <code>joblib</code>\u00b6","text":"<p>The other way to load and save models is with <code>joblib</code>. Which works relatively the same as <code>pickle</code>.</p> <p>To save a model, we can use <code>joblib</code>'s <code>dump()</code> function, passing it the model (<code>gs_clf</code>) and the desired filename.</p>"},{"location":"introduction-to-scikit-learn/#7-revisiting-the-entire-pipeline","title":"7. Revisiting the entire pipeline\u00b6","text":"<p>We've covered a lot. And so far, it seems to be all over the place, which it is.</p> <p>But not to worry, machine learning projects often start out like this.</p> <p>A whole bunch of experimenting and code all over the place at the start and then once you've found something which works, the refinement process begins.</p> <p>What would this refinement process look like?</p> <p>We'll use the car sales regression problem (predicting the sale price of cars) as an example.</p> <p>To tidy things up, we'll be using Scikit-Learn's <code>sklearn.pipeline.Pipeline</code> class.</p> <p>You can imagine <code>Pipeline</code> as being a way to string a number of different Scikit-Learn processes together.</p>"},{"location":"introduction-to-scikit-learn/#71-creating-a-regression-pipeline","title":"7.1 Creating a regression <code>Pipeline</code>\u00b6","text":"<p>You might recall when, way back in Section 2: Getting Data Ready, we dealt with the car sales data, to build a regression model on it, we had to encode the categorical features into numbers and fill the missing data.</p> <p>The code we used worked, but it was a bit all over the place.</p> <p>Good news is, <code>Pipeline</code> can help us clean it up.</p> <p>Let's remind ourselves what our <code>car-sales-extended-missing-data.csv</code> looks like in DataFrame form.</p>"},{"location":"introduction-to-scikit-learn/#where-to-next","title":"Where to next?\u00b6","text":"<p>If you've made it this far, congratulations! We've covered a lot of ground in the Scikit-Learn library.</p> <p>As you might've guessed, there's a lot more to be discovered.</p> <p>But for the time being, you should be equipped with some of the most useful features of the library to start trying to apply them to your own problems.</p> <p>Somewhere you might like to look next is to apply what you've learned above to a Kaggle competition.</p> <p>Kaggle competitions are great places to practice your data science and machine learning skills and compare your results with others.</p> <p>A great idea would be to try to combine the heart disease classification code, as well as the <code>Pipeline</code> code, to build a model for the Titanic dataset.</p> <p>Otherwise, if you'd like to figure out what else the Scikit-Learn library is capable of I'd highly recommend browsing through the Scikit-Learn User Guide and seeing what sparks your interest.</p> <p>Finally, as an extra-curriculum extension, you might want to look into trying out the CatBoost library for dealing with non-numerical data automatically.</p> <p>The CatBoost algorithm is advanced version of a decision tree (like a Random Forest with superpowers) and is used in production at several large technology companies, including Cloudflare.</p>"}]}